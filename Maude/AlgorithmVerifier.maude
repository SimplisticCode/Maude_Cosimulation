load cosim 

(omod AlgorithmVerifier is 
    protecting COSIMULATION .

    var RESTALGORITHM : ActionList .
    vars OUTPUTS INPUTS : Configuration .
    vars OUTPUT INPUT : PortId .
    vars ID1 ID2 : SUID . 
    vars STEPSIZE FUTURETIME : NzNat .
    vars TIME SUTIME INPUTTIME : Nat .
    var VALUE : FMIValue .
    var PORTVALUES : PortValueMap .
    var FEEDTHROUGH : OidSet .
    var CONTRACT : Contract .
    var SUINSTANCE : Object .

    ***

  *** FMI-standard fmistate transition:
  rl [setExp] : < ID1 : SU | fmistate : Instantiated > Initialization: ((fmiEvent: CreateExp SU: ID1) ; RESTALGORITHM) 
                 => < ID1 : SU | fmistate : ExperimentSetup > Initialization: RESTALGORITHM .

  rl [init] : < ID1 : SU | inputs : INPUTS , outputs : OUTPUTS, fmistate : ExperimentSetup >  
                                    Initialization: ((fmiEvent: EnterInitialization SU: ID1) ; RESTALGORITHM) 
           => < ID1 : SU | inputs : undefPorts(INPUTS, 0), outputs : undefPorts(OUTPUTS, 0), fmistate : Initialize > 
              Initialization: RESTALGORITHM .

  crl [simulate] : < ID1 : SU | inputs : INPUTS , outputs : OUTPUTS, fmistate : Initialize > Initialization: ( (fmiEvent: ExitInitialization SU: ID1) ; RESTALGORITHM)
                => < ID1 : SU | fmistate : Simulation > Initialization: RESTALGORITHM
                if allDef(INPUTS, 0) and allDef(OUTPUTS, 0)  .

  crl [terminate] : < ID1 : SU | time : TIME, inputs : INPUTS , outputs : OUTPUTS , fmistate : Simulation > endTime: TIME Termination: ((fmiEvent: Terminate SU: ID1) ; RESTALGORITHM)
                 => < ID1 : SU | fmistate : Terminated > endTime: TIME Termination: RESTALGORITHM
                 if allDef(OUTPUTS, TIME) and allDef(INPUTS, TIME) .

  rl [free] : < ID1 : SU | fmistate : Terminated > Termination: ((fmiEvent: FreeInstance SU: ID1) ; RESTALGORITHM) 
           => < ID1 : SU | fmistate : InstanceFreed > Termination: RESTALGORITHM .

  rl [unload] : < ID1 : SU | fmistate : InstanceFreed > Termination: ((fmiEvent: Unload SU: ID1) ; RESTALGORITHM)
              => < ID1 : SU | fmistate : Unloaded > Termination: RESTALGORITHM .

    *** Initialization
    crl [get-init] :
            < ID1 : SU | fmistate : Initialize, 
            outputs : (< OUTPUT : Output | status : Undef, value : VALUE, dependsOn : FEEDTHROUGH > OUTPUTS), 
                    inputs : INPUTS > 
                    (ID1 ! OUTPUT ==> ID2 ! INPUT)
                    Initialization: ((portEvent: Get SU: ID1 PId: OUTPUT) ; RESTALGORITHM) 
                    valuesToSet: PORTVALUES
                => < ID1 : SU | outputs : (< OUTPUT : Output | status : Def > OUTPUTS) > 
                    Initialization: RESTALGORITHM 
                    (ID1 ! OUTPUT ==> ID2 ! INPUT)
                    valuesToSet: insert((ID2 ! INPUT), < 0 ; VALUE >, PORTVALUES)
            if feedthroughSatisfied(FEEDTHROUGH, INPUTS, 0) .


   *** Inputs can only rely on one connection 
  crl [set-init] : < ID1 : SU | inputs : (< INPUT : Input | status : Undef > INPUTS), fmistate : Initialize > 
          Initialization: ((portEvent: Set SU: ID1 PId: INPUT)  ; RESTALGORITHM) 
          valuesToSet: (((ID1 ! INPUT) |-> < TIME ; VALUE >), PORTVALUES)
              => SUINSTANCE 
                     Initialization: RESTALGORITHM 
                        valuesToSet: PORTVALUES
            if SUINSTANCE := < ID1 : SU | inputs : (< INPUT : Input | time : TIME, status : Def, value : VALUE > INPUTS ) > .



    *** Simulation
    crl [get] : Algorithm: ((portEvent: Get SU: ID1 PId: OUTPUT) ; RESTALGORITHM)
                < ID1 : SU | outputs : (< OUTPUT : Output | time : TIME, status : Undef, value : VALUE, dependsOn : FEEDTHROUGH > OUTPUTS), inputs : INPUTS > 
                ( ID1 ! OUTPUT ==> ID2 ! INPUT)
                valuesToSet: PORTVALUES 
                => Algorithm: RESTALGORITHM
                valuesToSet: (((ID2 ! INPUT) |-> < TIME ; VALUE >), PORTVALUES)
                < ID1 : SU | outputs : (< OUTPUT : Output | status : Def > OUTPUTS) > 
                ( ID1 ! OUTPUT ==> ID2 ! INPUT) 
        if feedthroughSatisfied(FEEDTHROUGH, INPUTS, TIME) .
                
    crl [set] : Algorithm: ((portEvent: Set SU: ID1 PId: INPUT) ; RESTALGORITHM)
                    < ID1 : SU | time : SUTIME, fmistate : Simulation, inputs : (< INPUT : Input | contract : CONTRACT, time : INPUTTIME > INPUTS) > 
                    valuesToSet: (((ID1 ! INPUT) |-> < TIME ; VALUE >), PORTVALUES)
                => Algorithm: RESTALGORITHM
                    < ID1 : SU | inputs : (< INPUT : Input | time : TIME, value : VALUE > INPUTS) >
                    valuesToSet: PORTVALUES 
        if (CONTRACT == r and (TIME > INPUTTIME) and INPUTTIME == SUTIME) 
                or (CONTRACT == d and TIME == SUTIME) .

    crl [step-action] : Algorithm: ((stepEvent: ID1 StepSize: STEPSIZE) ; RESTALGORITHM)
                    < ID1 : SU | time : TIME, inputs : INPUTS, outputs : OUTPUTS, fmistate : Simulation > 
                => Algorithm: RESTALGORITHM
                    stepAction(< ID1 : SU | >, STEPSIZE)
                if canStep(TIME, TIME + STEPSIZE, INPUTS, OUTPUTS) .

    
***(
    rl [step-negotiation] : Algorithm: ((complexEvent: Get SU: ID1 PId: OUTPUT) ; RESTALGORITHM)
                < ID1 : SU | outputs : (< OUTPUT : Output | status : Undef, value : VALUE > OUTPUTS) > 
                => Algorithm: RESTALGORITHM
                < ID1 : SU | outputs : (< OUTPUT : Output | status : Def, value : VALUE > OUTPUTS) > .
                
    rl [loop-solving] : Algorithm: ((portEvent: Set SU: ID1 PId: INPUT) ; RESTALGORITHM)
                    < ID1 : SU | inputs : (< INPUT : Input | status : Undef > INPUTS) > 
                => Algorithm: RESTALGORITHM
                    < ID1 : SU | inputs : (< INPUT : Input | status : Undef > INPUTS) >  .

)

endom)