load cosim 

(omod AlgorithmVerifier is 
    protecting COSIMULATION .

    var OCH : Oid .
    vars RESTALGORITHM ALGO STEPNEGOALGO : ActionList .
    vars OUTPUTS INPUTS CONF : Configuration .
    vars OUTPUT INPUT : PortId .
    vars ID1 ID2 : SUID . 
    vars STEPSIZE FUTURETIME NEGOTIATEDSTEPSIZE ENDTIME : NzNat .
    vars TIME SUTIME INPUTTIME : Nat .
    var VALUE : FMIValue .
    var PORTVALUES : PortValueMap .
    vars FEEDTHROUGH SUIDs : OidSet .
    var SUIDsNE : NeOidSet . 
    var CONTRACT : Contract .
    var SUINSTANCE : Object .

*** How should this work?

 
  ***op run_on_ : Object GlobalState -> GlobalState . 
  ***eq run ALGO on {CONF} = 
    
  *** FMI-standard fmistate transition:
  rl [setExp] : {< ID1 : SU | fmistate : Instantiated > CONF
                < OCH : OrchestrationData | Initialization : ((fmiEvent: CreateExp SUs: SUIDsNE) ; RESTALGORITHM) > } 
                => {moveState(SUIDsNE, < ID1 : SU | > CONF, Instantiated, ExperimentSetup)
                 < OCH : OrchestrationData | Initialization : RESTALGORITHM > } .

  rl [init] : {< ID1 : SU | fmistate : ExperimentSetup > CONF
              < OCH : OrchestrationData | Initialization : ((fmiEvent: EnterInitialization SUs: SUIDsNE) ; RESTALGORITHM )> }      
           => { moveToInitialize(SUIDsNE, < ID1 : SU | > CONF)
                < OCH : OrchestrationData | Initialization : RESTALGORITHM >  } .


  crl [simulate] : { < ID1 : SU | fmistate : Initialize > CONF
                    < OCH : OrchestrationData | Initialization : (fmiEvent: ExitInitialization SUs: SUIDsNE), valuesToSet : empty > } 
                => { moveState(SUIDsNE, < ID1 : SU | > CONF, Initialize, Simulation)
                    < OCH : OrchestrationData | Initialization : emptyList > }
                if initializationDone(SUIDsNE, < ID1 : SU | fmistate : Initialize > CONF) .

  crl [terminate] : {< ID1 : SU | time : ENDTIME, inputs : INPUTS , outputs : OUTPUTS , fmistate : Simulation > CONF
                       < OCH : OrchestrationData | endTime : TIME, Algorithm : emptyList, Termination : ((fmiEvent: Terminate SUs: SUIDsNE) ; RESTALGORITHM) > }
                 => {
                     moveState(SUIDsNE, < ID1 : SU | > CONF, Simulation, Terminated)
                     < OCH : OrchestrationData | Termination : RESTALGORITHM >
                 }
                 if allDef(OUTPUTS, ENDTIME) and allDef(INPUTS, ENDTIME) .

  rl [free] : { < ID1 : SU | fmistate : Terminated > CONF
                < OCH : OrchestrationData | Termination : ((fmiEvent: FreeInstance SUs: SUIDsNE) ; RESTALGORITHM) > }
           => { moveState(SUIDsNE, < ID1 : SU | > CONF, Terminated, InstanceFreed)
                < OCH : OrchestrationData | Termination : RESTALGORITHM > } .

  rl [unload] : { < ID1 : SU | fmistate : InstanceFreed > CONF
                  < OCH : OrchestrationData | Termination : ((fmiEvent: Unload SUs: SUIDsNE) ; RESTALGORITHM) > }
              => { moveState(SUIDsNE, < ID1 : SU | > CONF, InstanceFreed, Unloaded)
                 < OCH : OrchestrationData | Termination : RESTALGORITHM > } .

    *** Initialization
    crl [get-init] :
            < ID1 : SU | fmistate : Initialize, 
            outputs : (< OUTPUT : Output | status : Undef, value : VALUE, dependsOn : FEEDTHROUGH > OUTPUTS), 
                    inputs : INPUTS > 
                    (ID1 ! OUTPUT ==> ID2 ! INPUT)
                    < OCH : OrchestrationData | Initialization : ((portEvent: Get SU: ID1 PId: OUTPUT) ; RESTALGORITHM), valuesToSet : PORTVALUES > 
                => < ID1 : SU | outputs : (< OUTPUT : Output | status : Def > OUTPUTS) > 
                    (ID1 ! OUTPUT ==> ID2 ! INPUT)
                    < OCH : OrchestrationData | Initialization : RESTALGORITHM, valuesToSet : insert((ID2 ! INPUT), < 0 ; VALUE >, PORTVALUES) > 
            if feedthroughSatisfied(FEEDTHROUGH, INPUTS, 0) .


   *** Inputs can only rely on one connection 
  crl [set-init] : < ID1 : SU | inputs : (< INPUT : Input | status : Undef > INPUTS), fmistate : Initialize > 
        < OCH : OrchestrationData | Initialization : ((portEvent: Set SU: ID1 PId: INPUT)  ; RESTALGORITHM), valuesToSet : (((ID1 ! INPUT) |-> < TIME ; VALUE >), PORTVALUES) >
              => SUINSTANCE  < OCH : OrchestrationData | Initialization : RESTALGORITHM, valuesToSet : PORTVALUES >
            if SUINSTANCE := < ID1 : SU | inputs : (< INPUT : Input | time : TIME, status : Def, value : VALUE > INPUTS ) > .


    *** Simulation
    crl [get] : < ID1 : SU | outputs : (< OUTPUT : Output | time : TIME, status : Undef, value : VALUE, dependsOn : FEEDTHROUGH > OUTPUTS), inputs : INPUTS > 
                ( ID1 ! OUTPUT ==> ID2 ! INPUT)
                < OCH : OrchestrationData | Algorithm : ((portEvent: Get SU: ID1 PId: OUTPUT) ; RESTALGORITHM), valuesToSet : PORTVALUES >
                => 
                < OCH : OrchestrationData | Algorithm : RESTALGORITHM, valuesToSet : (((ID2 ! INPUT) |-> < TIME ; VALUE >), PORTVALUES) >
                < ID1 : SU | outputs : (< OUTPUT : Output | status : Def > OUTPUTS) > 
                ( ID1 ! OUTPUT ==> ID2 ! INPUT) 
        if feedthroughSatisfied(FEEDTHROUGH, INPUTS, TIME) .
                
    crl [set] : 
            < OCH : OrchestrationData | Algorithm : ((portEvent: Set SU: ID1 PId: INPUT) ; RESTALGORITHM), valuesToSet : (((ID1 ! INPUT) |-> < TIME ; VALUE >), PORTVALUES) >
            < ID1 : SU | time : SUTIME, fmistate : Simulation, inputs : (< INPUT : Input | contract : CONTRACT, time : INPUTTIME > INPUTS) > 
            => 
            < OCH : OrchestrationData | Algorithm : RESTALGORITHM, valuesToSet : PORTVALUES >
            < ID1 : SU | inputs : (< INPUT : Input | time : TIME, value : VALUE > INPUTS) >
        if (CONTRACT == reactive and (TIME > INPUTTIME) and INPUTTIME == SUTIME) or (CONTRACT == delayed and TIME == SUTIME) .

    crl [step-action] : 
            < OCH : OrchestrationData | Algorithm : ((stepEvent: ID1 StepSize: STEPSIZE) ; RESTALGORITHM) >
                    < ID1 : SU | time : TIME, inputs : INPUTS, outputs : OUTPUTS, fmistate : Simulation > 
                => < OCH : OrchestrationData | Algorithm : RESTALGORITHM >
                    stepAction(< ID1 : SU | >, STEPSIZE)
                if canStep(TIME, TIME + STEPSIZE, INPUTS, OUTPUTS) .
endom)
    eof
    *** Next step look at Complex scenarios
    crl [step-negotiation] : 
                Algorithm: (
                    (complexEvent: StepNegotiation SaveSUs: SUIDsNENE RestoreSUs: SUIDsNENE Actions: ALGO) ; RESTALGORITHM)
                => Algorithm: RESTALGORITHM  .
     

endom)