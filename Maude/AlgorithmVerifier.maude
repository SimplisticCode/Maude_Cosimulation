load cosim 

(omod AlgorithmVerifier is 
    protecting COSIMULATION .
    sorts SimulationState InstrumentationState .
    vars SU1 SU2 ALG OUTPUT INPUT OCH : Oid .
    vars RESTALGORITHM ALGO STEPNEGOALGO : ActionList .
    vars OUTPUTS INPUTS CONF CONF1 INITSTATE STATE FINALSTATE : Configuration .
    vars STEPSIZE FUTURETIME NEGOTIATEDSTEPSIZE ENDTIME : NzNat .
    vars TIME SUTIME INPUTTIME NATVALUE ITERATION : Nat .
    var VALUE : FMIValue .
    var PORTVALUES : PortValueMap .
    vars FEEDTHROUGH SUIDs : OidSet .
    var SUIDsNE : NeOidSet . 
    var CONTRACT : Contract .
    vars SUINSTANCE ORCHESTRATOR SIMULATIONDATA ALGORITHMDATA : Object .
    var LOOPS : AlgebraicLoopSet .
    var UNITIALIZEDCONF : [Configuration] .

    *** To run multiple step
    op runs_on_ : Nat Configuration -> SimulationState [ctor] . 

    crl [run-iteration]: runs s ITERATION on INITSTATE =>
        runs ITERATION on FINALSTATE 
        if runAnyAlgorithm INITSTATE => 
            run: < ALG : AlgorithmData | Initialization : emptyList, CosimStep : emptyList, Termination : emptyList, ATTS:AttributeSet > 
            on: FINALSTATE .

    op run:_on:_with:_ : Object Configuration Object -> SimulationState [ctor]. 

    *** Not to be touched!
    op run:_on:_ : Object Configuration -> SimulationState [ctor]. 
    op runAnyAlgorithm_ : Configuration -> SimulationState [ctor] .
    crl [runAnyAlg] : runAnyAlgorithm INITSTATE => run: ORCHESTRATOR on: INITSTATE with: SIMULATIONDATA
    if LOOPS := tarjan(INITSTATE)
      /\ SUIDsNE := getSUIDsOfScenario(INITSTATE)
      /\ SIMULATIONDATA := initialOrchestrationData(1,LOOPS,SUIDsNE)
      /\ ALGORITHMDATA := initialAlgorithmData(1)
      /\ CONF := calculateSNSet(INITSTATE ALGORITHMDATA) SIMULATIONDATA 
      /\ {CONF} => { FINALSTATE } 
      /\ ORCHESTRATOR := getOrchestrator(FINALSTATE)
      /\ allSUsinUnloaded(SUIDsNE, FINALSTATE) .

    ops findContacts findInstr : Configuration -> InstrumentationState [ctor] .
    subsort Configuration < InstrumentationState .
    
    *** Everything that takes something frozen into something static should be frozen
    op allConstraintsDefined : Configuration -> Bool [frozen] .
    eq allConstraintsDefined(< SU1 : SU | inputs : (< INPUT : Input | contract : noContract > INPUTS) > CONF) = false .
    eq allConstraintsDefined(CONF) = true [owise] .

    rl [insr-delayed]: 
        findInstr(< SU1 : SU | inputs : (< INPUT : Input | contract : noContract > INPUTS) > CONF)
        =>
        findInstr(< SU1 : SU | inputs : (< INPUT : Input | contract : delayed > INPUTS) > CONF) .

    rl [insr-reactive]: 
        findInstr(< SU1 : SU | inputs : (< INPUT : Input | contract : noContract > INPUTS) > CONF)
        =>
        findInstr(< SU1 : SU | inputs : (< INPUT : Input | contract : reactive > INPUTS) > CONF) .

    crl [remove-findInstr]: findInstr(CONF) => CONF 
        if allConstraintsDefined(CONF) .
        
    *** Find an implementation such that when it runs the algortihm it satisfies the property defined by the user
    crl [findInstrumentation]: findContacts(INITSTATE) => CONF
        if findInstr(INITSTATE) => CONF
        /\ empty == tarjan(CONF) *** We do not allow loops in the found configuration
        /\ runAnyAlgorithm CONF => run: ORCHESTRATOR on: FINALSTATE with: SIMULATIONDATA
        /\ positive(FINALSTATE) .

    op positive : Configuration -> Bool .
    eq positive(CONF < "ctrl" : SU | inputs : (< "waterlevel" : Input | value : < NATVALUE > > INPUTS) >) = NATVALUE > 0 .

    *** Select the a value for parameter we want to do DSE on.
    op selectParams : [Configuration] -> [Configuration] .
    crl [dse] : selectParams(UNITIALIZEDCONF) => CONF 
    if UNITIALIZEDCONF => CONF
    /\ runAnyAlgorithm CONF => 
        run: < ALG : AlgorithmData | Initialization : emptyList, CosimStep : emptyList, Termination : emptyList, ATTS:AttributeSet > 
        on: FINALSTATE
        with: SIMULATIONDATA
    /\ above10(FINALSTATE) .

  op above10 : Configuration -> Bool .
  eq above10(CONF < "tank" : SU | localState : ( "waterlevel" |-> < NATVALUE >) >) = NATVALUE > 0 .

  *** FMI-standard fmistate transition:
  rl [setExp] : 
                run: < ALG : AlgorithmData | Initialization : ((fmiEvent: CreateExp SUs: SUIDsNE) ; RESTALGORITHM) > 
                on: < SU1 : SU | fmistate : Instantiated > CONF
                with: SIMULATIONDATA  
                => 
                run: < ALG : AlgorithmData | Initialization : RESTALGORITHM > 
                on: moveState(SUIDsNE, < SU1 : SU | > CONF, Instantiated, ExperimentSetup)
                with: SIMULATIONDATA .

  rl [init] : 
    run: < ALG : AlgorithmData | Initialization : ((fmiEvent: EnterInitialization SUs: SUIDsNE) ; RESTALGORITHM )> 
    on: < SU1 : SU | fmistate : ExperimentSetup > CONF
    with: SIMULATIONDATA         
    => 
    run: < ALG : AlgorithmData | Initialization : RESTALGORITHM > 
    on:  moveToInitialize(SUIDsNE, < SU1 : SU | > CONF)  
    with: SIMULATIONDATA .

  crl [simulate] : 
    run: < ALG : AlgorithmData | Initialization : (fmiEvent: ExitInitialization SUs: SUIDsNE) >
    on:  < SU1 : SU | fmistate : Initialize > CONF  
    with: < OCH : SimulationData | values : empty > 
    => 
    run: < ALG : AlgorithmData | Initialization : emptyList >  
    on:  moveState(SUIDsNE, < SU1 : SU | > CONF, Initialize, Simulation) 
    with: < OCH : SimulationData | > 
if initializationDone(SUIDsNE, < SU1 : SU | fmistate : Initialize > CONF) .

  crl [terminate] : 
    run: < ALG : AlgorithmData | endTime : TIME, CosimStep : emptyList, Termination : ((fmiEvent: Terminate SUs: SUIDsNE) ; RESTALGORITHM) >
    on: < SU1 : SU | time : ENDTIME, inputs : INPUTS , outputs : OUTPUTS , fmistate : Simulation > CONF 
    with: SIMULATIONDATA
    => 
    run: < ALG : AlgorithmData | Termination : RESTALGORITHM > 
    on: moveState(SUIDsNE, < SU1 : SU | > CONF, Simulation, Terminated) 
    with: SIMULATIONDATA
if allDef(OUTPUTS, ENDTIME) and allDef(INPUTS, ENDTIME) .

  rl [free] : 
  run: < ALG : AlgorithmData | Termination : ((fmiEvent: FreeInstance SUs: SUIDsNE) ; RESTALGORITHM) >
  on:  < SU1 : SU | fmistate : Terminated > CONF 
  with: SIMULATIONDATA
  => 
  run: < ALG : AlgorithmData | Termination : RESTALGORITHM >
  on:  moveState(SUIDsNE, < SU1 : SU | > CONF, Terminated, InstanceFreed) 
  with: SIMULATIONDATA .

  rl [unload] : 
  run: < ALG : AlgorithmData | Termination : ((fmiEvent: Unload SUs: SUIDsNE) ; RESTALGORITHM) >
  on: < SU1 : SU | fmistate : InstanceFreed > CONF 
  with: SIMULATIONDATA
  => run: < ALG : AlgorithmData | Termination : RESTALGORITHM > 
  on: moveState(SUIDsNE, < SU1 : SU | > CONF, InstanceFreed, Unloaded) 
  with: SIMULATIONDATA .

*** Initialization
crl [get-init] :
    run:  < ALG : AlgorithmData | Initialization : ((portEvent: Get SU: SU1 PId: OUTPUT) ; RESTALGORITHM) > 
    on: < SU1 : SU | fmistate : Initialize, 
            outputs : (< OUTPUT : Output | status : Undef, value : VALUE, dependsOn : FEEDTHROUGH > OUTPUTS), 
            inputs : INPUTS > 
            (SU1 ! OUTPUT ==> SU2 ! INPUT) CONF
    with: < OCH : SimulationData | values : PORTVALUES >
    => 
    run: < ALG : AlgorithmData | Initialization : RESTALGORITHM >
    on: < SU1 : SU | outputs : (< OUTPUT : Output | status : Def > OUTPUTS) > 
            (SU1 ! OUTPUT ==> SU2 ! INPUT) CONF             
    with: < OCH : SimulationData | values : insert((SU2 ! INPUT), < 0 ; VALUE >, PORTVALUES) >
    if feedthroughSatisfied(FEEDTHROUGH, INPUTS, 0) .

   *** Inputs can only rely on: one connection 
rl [set-init] : 
    run: < ALG : AlgorithmData | Initialization : ((portEvent: Set SU: SU1 PId: INPUT)  ; RESTALGORITHM) >
    on:  < SU1 : SU | inputs : (< INPUT : Input | status : Undef > INPUTS), fmistate : Initialize > CONF
    with: < OCH : SimulationData | values : (((SU1 ! INPUT) |-> < TIME ; VALUE >), PORTVALUES) >
    => 
    run: < ALG : AlgorithmData | Initialization : RESTALGORITHM >
    on:  < SU1 : SU | inputs : (< INPUT : Input | time : TIME, status : Def, value : VALUE > INPUTS ) > CONF
    with: < OCH : SimulationData | values : PORTVALUES > .

    *** Simulation
crl [get] : 
    run: < ALG : AlgorithmData | CosimStep : ((portEvent: Get SU: SU1 PId: OUTPUT) ; RESTALGORITHM) >
    on: CONF
        < SU1 : SU | outputs : (< OUTPUT : Output | time : TIME, value : VALUE, dependsOn : FEEDTHROUGH > OUTPUTS), inputs : INPUTS > 
        ( SU1 ! OUTPUT ==> SU2 ! INPUT)
    with: < OCH : SimulationData | values : PORTVALUES >
    => 
    run: < ALG : AlgorithmData | CosimStep : RESTALGORITHM >
    on: CONF < SU1 : SU | outputs : (< OUTPUT : Output | status : Def > OUTPUTS) > 
                ( SU1 ! OUTPUT ==> SU2 ! INPUT)
    with: < OCH : SimulationData | values : insert((SU2 ! INPUT), < TIME ; VALUE >, PORTVALUES) > 
if feedthroughSatisfied(FEEDTHROUGH, INPUTS, TIME) .
                
crl [set] : 
    run: < ALG : AlgorithmData | CosimStep : ((portEvent: Set SU: SU1 PId: INPUT) ; RESTALGORITHM) >
    on: CONF < SU1 : SU | time : SUTIME, fmistate : Simulation, inputs : (< INPUT : Input | contract : CONTRACT, time : INPUTTIME > INPUTS) >
    with: < OCH : SimulationData | values : (((SU1 ! INPUT) |-> < TIME ; VALUE >), PORTVALUES) >
    => 
    run: < ALG : AlgorithmData | CosimStep : RESTALGORITHM >
    on: CONF < SU1 : SU | inputs : (< INPUT : Input | time : TIME, value : VALUE > INPUTS) > 
    with: < OCH : SimulationData | values : PORTVALUES >
if ((CONTRACT == reactive and (TIME > INPUTTIME) and INPUTTIME == SUTIME) or (CONTRACT == delayed and TIME == SUTIME)) .

crl [step-action] : 
    run: < ALG : AlgorithmData | CosimStep : ((stepEvent: SU1 StepSize: STEPSIZE) ; RESTALGORITHM) >
    on: CONF < SU1 : SU | time : TIME, inputs : INPUTS, outputs : OUTPUTS, fmistate : Simulation >
    with: SIMULATIONDATA
    => 
    run: < ALG : AlgorithmData | CosimStep : RESTALGORITHM >
    on: CONF O:Object
    with: SIMULATIONDATA
if FUTURETIME := TIME + STEPSIZE
/\ canStep(TIME, FUTURETIME, INPUTS, OUTPUTS) 
/\ step(< SU1 : SU | >, STEPSIZE) => O:Object .

*** Next step look at Complex scenarios
*** Right now we just ignore them in the simulation
rl [step-negotiation] :
    run:
    < ALG : AlgorithmData | CosimStep : 
        ((complexEvent: StepNegotiation SaveSUs: SUIDsNE RestoreSUs: SUIDsNE Actions: ALGO) ; RESTALGORITHM) >
    on: CONF
    with: SIMULATIONDATA
    => 
    run: 
    < ALG : AlgorithmData | CosimStep : RESTALGORITHM > 
    on: CONF 
    with: SIMULATIONDATA .
    
rl [fixed-point] :
    run:
    < ALG : AlgorithmData | CosimStep : 
        ((complexEvent: Loop SaveSUs: SUIDsNE RestoreSUs: SUIDsNE Actions: ALGO) ; RESTALGORITHM) >
    on: CONF
    with: SIMULATIONDATA
    => 
    run: 
    < ALG : AlgorithmData | CosimStep : RESTALGORITHM > 
    on: CONF 
    with: SIMULATIONDATA .

endom)
    eof


    (frew runs 3 on initConfiguration .)

*** Design Space Exploration
(frew runAnyAlgorithm initConfDSE .)

(frew runAnyAlgorithm initConfiguration .)

( frew 
(run: (< "Orchestrator" : AlgorithmData | CosimStep :((
stepEvent: "ctrl" StepSize: 1);(
portEvent: Get SU: "ctrl" PId: "valveState");(
stepEvent: "tank" StepSize: 1);(
portEvent: Get SU: "tank" PId: "waterlevel");(
portEvent: Set SU: "ctrl" PId: "waterlevel");
portEvent: Set SU: "tank" PId: "valveState"),Initialization :((
fmiEvent: CreateExp SUs:("ctrl", "tank"));(
fmiEvent: EnterInitialization SUs:("ctrl", "tank"));(
portEvent: Get SU: "tank" PId: "waterlevel");(
portEvent: Set SU: "ctrl" PId: "waterlevel");(
portEvent: Get SU: "ctrl" PId: "valveState");(
portEvent: Set SU: "tank" PId: "valveState");
fmiEvent: ExitInitialization SUs:("ctrl", "tank")),SNSet : empty,Termination :((
fmiEvent: Terminate SUs:("ctrl", "tank"));(
fmiEvent: FreeInstance SUs:("ctrl", "tank"));
fmiEvent: Unload SUs:("ctrl", "tank")),actualStepSize : 1,defaultStepSize : 1,endTime : 1,guessOn : empty,simulationTime : 0,solvedSCC : empty,unsolvedSCC : empty,values : empty >)
on: (("ctrl" ! "valveState" ==> "tank" ! "valveState")(
"tank" ! "waterlevel" ==> "ctrl" ! "waterlevel")< "ctrl" : SU | canReject : false,fmistate : Instantiated,inputs : < "waterlevel" : Input |
    contract : delayed,status : Undef,time : 0,type : integer,value : < 0 > >,outputs : < "valveState" : Output | dependsOn : empty,status :
    Undef,time : 0,type : integer,value : < 0 > >,parameters : none,path : "",time : 0 > < "tank" : SU | canReject : false,fmistate :
    Instantiated,inputs : < "valveState" : Input | contract : delayed,status : Undef,time : 0,type : integer,value : < 0 > >,outputs : <
    "waterlevel" : Output | dependsOn : empty,status : Undef,time : 0,type : integer,value : < 0 > >,parameters : none,path : "",time : 0 >)
    ) .)


*** find Insrumentations
( search findContacts(initConfiguration) =>! C:Configuration . )
( frew findContacts(initConfigurationUninstrumented) . )

( search findContacts(initConfigurationUninstrumented) =>! C:Configuration . )
*** Find correct Parameters:
( search selectParams(initConfDSE)  =>! C:Configuration . )

( frew selectParams(initConfDSE)  . )

*** Deterministic
*** Go from an initial configuration to search for  
***Run any algorithm - show determinism
( search (runAnyAlgorithm initConfiguration)  =>! S:SimulationState . )
( search (runAnyAlgorithm initConfDSE)  =>! S:SimulationState . )

*** Search for bad states - safety properties
( search (runAnyAlgorithm initConfiguration) =>* run: O:Object on: (C:Configuration 
                < "tank" : SU | outputs : < "waterlevel" : Output | value : < 213 > > > ) . )

*** Somwthing good will happen
( search (runAnyAlgorithm initConfiguration) =>* run: O:Object on: (C:Configuration 
                < "tank" : SU | outputs : < "waterlevel" : Output | value : < 2546248239 > > > ) . )

              



(frew findInstr(< "ctrl" : SU | canReject : false,fmistate : Instantiated,inputs : < "waterlevel" : Input |
    contract : noContract,status : Undef,time : 0,type : integer,value : < 0 > >,outputs : < "valveState" : Output | dependsOn : empty,
    status : Undef,time : 0,type : integer,value : < 0 > >,parameters : none,path : "",time : 0 >
     < "tank" : SU | canReject : false,fmistate
    : Instantiated,inputs : < "valveState" : Input | contract : noContract,status : Undef,time : 0,type : integer,value : < 0 > >,outputs :
    < "waterlevel" : Output | dependsOn : empty,status : Undef,time : 0,type : integer,value : < 0 > >,parameters : none,path : "",time : 0
    >) .)
endom)


(frew run: < "Orchestrator" : AlgorithmData | CosimStep :((
stepEvent: "ctrl" StepSize: 1);(
portEvent: Get SU: "ctrl" PId: "valveState");(
stepEvent: "tank" StepSize: 1);(
portEvent: Get SU: "tank" PId: "waterlevel");(
portEvent: Set SU: "ctrl" PId: "waterlevel");
portEvent: Set SU: "tank" PId: "valveState"),Initialization : emptyList,SNSet : empty,Termination :((
fmiEvent: Terminate SUs:("ctrl", "tank"));(
fmiEvent: FreeInstance SUs:("ctrl", "tank"));
fmiEvent: Unload SUs:("ctrl", "tank")),actualStepSize : 1,defaultStepSize : 1,endTime : 2,guessOn : empty,simulationTime : 2,
    solvedSCC : empty,unsolvedSCC : empty,values : empty > on:(
"ctrl" ! "valveState" ==> "tank" ! "valveState")(
"tank" ! "waterlevel" ==> "ctrl" ! "waterlevel")< "ctrl" : SU | canReject : false,fmistate : Simulation,inputs : < "waterlevel" :
    Input | contract : delayed,status : Def,time : 1,type : integer,value : < 100 > >,localState : "valve" |-> < true >,outputs :
    < "valveState" : Output | dependsOn : empty,status : Def,time : 1,type : integer,value : < 1 > >,parameters :("high" |-> < 5
    >, "low" |-> < 0 >),path : "",time : 1 > < "tank" : SU | canReject : false,fmistate : Simulation,inputs : < "valveState" :
    Input | contract : delayed,status : Def,time : 1,type : integer,value : < 1 > >,localState : "waterlevel" |-> < 100 >,outputs
    : < "waterlevel" : Output | dependsOn : empty,status : Def,time : 1,type : integer,value : < 100 > >,parameters : "flow" |-> <
    100 >,path : "",time : 1 > . )

(frew run: < "Orchestrator" : AlgorithmData | CosimStep :((
stepEvent: "ctrl" StepSize: 1);(
portEvent: Get SU: "ctrl" PId: "valveState");(
stepEvent: "tank" StepSize: 1);(
portEvent: Get SU: "tank" PId: "waterlevel");(
portEvent: Set SU: "ctrl" PId: "waterlevel");
portEvent: Set SU: "tank" PId: "valveState"),Initialization : emptyList,SNSet : empty,Termination :((
fmiEvent: Terminate SUs:("ctrl", "tank"));(
fmiEvent: FreeInstance SUs:("ctrl", "tank"));
fmiEvent: Unload SUs:("ctrl", "tank")),actualStepSize : 1,defaultStepSize : 1,endTime : 2,guessOn : empty,simulationTime : 2,
    solvedSCC : empty,suids :("ctrl", "tank"),unsolvedSCC : empty,values : empty > on:(
"ctrl" ! "valveState" ==> "tank" ! "valveState")(
"tank" ! "waterlevel" ==> "ctrl" ! "waterlevel")< "ctrl" : SU | canReject : false,fmistate : Simulation,inputs : < "waterlevel" :
    Input | contract : delayed,status : Def,time : 1,type : integer,value : < 100 > >,localState : "valve" |-> < true >,outputs : <
    "valveState" : Output | dependsOn : empty,status : Def,time : 1,type : integer,value : < 1 > >,parameters :("high" |-> < 5 >,
    "low" |-> < 0 >),path : "",time : 1 > < "tank" : SU | canReject : false,fmistate : Simulation,inputs : < "valveState" : Input |
    contract : delayed,status : Def,time : 1,type : integer,value : < 1 > >,localState : "waterlevel" |-> < 100 >,outputs : <
    "waterlevel" : Output | dependsOn : empty,status : Def,time : 1,type : integer,value : < 100 > >,parameters : "flow" |-> < 100 >,
    path : "",time : 1 > .)