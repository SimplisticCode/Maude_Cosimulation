load SimulationUnit

(omod LOOPSolver is 
  protecting PerformActions .
    sorts Pair .

    op <_;_> : ActionList Configuration -> Pair [ctor] .
    op solveLoop : Configuration Algebraic  -> Configuration . 
    op breakLoop : EPortIdSet Configuration LoopType -> Configuration .
    op containsCycle : AlgebraicLoops -> Bool . 
    op loopStep : EPortIdSet Configuration ActionList -> Pair .

    op fst : Pair -> ActionList .
    op snd : Pair -> Configuration .

    var L : AlgebraicLoops .  
    var K : LoopType .
    vars C OUTPUTS INPUTS : Configuration .
    vars I O : PortId .
    vars ID1 ID2 : SUID .
    vars PSet GSet : EPortIdSet .
    var AL : ActionList .
    var T T1 : Nat .
    var S : NzNat .
    var FT : PortIdSet .
    var M : Mode .

    eq fst(< AL ; C >) = AL . 
    eq snd(< AL ; C >) = C . 

   *** Does the scenario contain any loop
   eq containsCycle(noLoops) = false .
   eq containsCycle(L) = true [owise] .

   eq solveLoop(C Algorithm: AL, AlgebraicLoop: PSet Type: K) = snd(loopStep(PSet, breakLoop(PSet, C, K), emptyList))
        Algorithm: (AL ; (complexEvent: Loop SaveSUs: getSUs(PSet, emptySUSet) RestoreSUs: getSUs(PSet, emptySUSet) 
        Actions: fst(loopStep(PSet, breakLoop(PSet, C, K), emptyList)))) .

    *** Forget All Connections depending on type of loop 
    ceq breakLoop((ID1 ! I) ;; PSet,   
                     < ID1 : SU | inputs : (< I : Input | type : M > INPUTS) > 
                     < ID2 : SU | outputs : (< O : Output | > OUTPUTS) > 
                     (ID2 ! O ==> ID1 ! I) guessOn: GSet C, K) = 
                        breakLoop((ID1 ! I) ;; PSet, < ID1 : SU | > < ID2 : SU | > guessOn: ((ID1 ! I) ;; GSet) C , K) 
                        if (K == R and M == r) or (K == F and M == d) .

    eq breakLoop(PSet, C, K) = C [owise] .

    *** Set value using Guess
    ceq loopStep((ID1 ! I) ;; PSet, 
                      < ID1 : SU | time : T, inputs : (< I : Input | time : T1, type : M > INPUTS) > 
                    guessOn: ((ID1 ! I) ;; GSet) stepSize: S C, AL) = 
            loopStep(PSet, 
                    setAction(< ID1 : SU | >, I, T1 + S)
                    guessOn: GSet stepSize: S C, 
                    (AL ; (event: Set SU: ID1 PId: I))) 
                    if (M == r and T1 == T) or (M == d and T == (T1 + S)) .

    *** Set value on input - Fix
    ceq loopStep((ID1 ! I) ;; PSet, 
                      < ID1 : SU | inputs : (< I : Input | time : T, type : M > INPUTS) > 
                      < ID2 : SU | outputs : (< O : Output | time : T1, status : Def > OUTPUTS) > 
                        (ID2 ! O ==> ID1 ! I) C, AL) = 
              loopStep(PSet, 
                      setAction(< ID1 : SU | >, I, T1)
                      < ID2 : SU | > (ID2 ! O ==> ID1 ! I) C, 
                      (AL ; (event: Set SU: ID1 PId: I))) 
                      if T1 > T .

    *** Get output value
    ceq loopStep((ID1 ! O) ;; PSet, 
                    < ID1 : SU | time : T, outputs : (< O : Output | status : Undef, dependsOn : FT > OUTPUTS), inputs : INPUTS > C, AL) = 
                    loopStep(PSet,
                      getAction(< ID1 : SU | >, O) C, 
                      (AL ; (event: Get SU: ID1 PId: O))) 
                      if feedthroughSatisfied(FT, INPUTS, T) .

    *** Step
    ceq loopStep((ID1 ! O) ;; PSet,  
                    < ID1 : SU | time : T, outputs : OUTPUTS, inputs : INPUTS > stepSize: S C, AL) = 
                  loopStep((ID1 ! O) ;; PSet,
                      stepAction(< ID1 : SU | >, S) 
                      stepSize: S C, (AL ; (event: Step SU: ID1 PId: emptySet)))
                    if canStep(T, (T + S), INPUTS, OUTPUTS) .

    eq loopStep(emptyLoop,C, AL) = < AL ; C  > .

endom)
