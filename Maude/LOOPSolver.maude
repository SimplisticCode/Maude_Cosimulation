load SimulationUnit
(omod LOOPSolver is 
  protecting SimulationUnit .
    sorts Pair .

    op <_;_> : ActionList Configuration -> Pair [ctor] .
    op solveLoop : Configuration AlgebraicLoop  -> Configuration . 
    op breakLoop : Set{EPortIdAsTRIV} Configuration LoopType -> Configuration .
    op containsCycle : Set{ALGEBRAICLOOPAsTRIV} -> Bool . 
    op loopStep : Set{EPortIdAsTRIV}  Configuration ActionList -> Pair .
    op solveLoopConf : Configuration AlgebraicLoop -> Configuration .
    op solveLoopAlgorithm : Configuration AlgebraicLoop -> ActionList .

    op fst : Pair -> ActionList .
    op snd : Pair -> Configuration .

    var LOOPS : Set{ALGEBRAICLOOPAsTRIV} .  
    var LOOPTYPE : LoopType .
    vars CONF OUTPUTS INPUTS : Configuration .
    vars INPUT OUTPUT : PortId .
    vars ID1 ID2 : SUID .
    vars PSet GSet : Set{EPortIdAsTRIV} .
    var ALGO : ActionList .
    var TIME T1 : Nat .
    var STEP : NzNat .
    var FEEDTHROUGH : Set{OIdAsTRIV}  .
    var MODE : Mode .
    var SUIDS : Set{OIdAsTRIV}  .

    eq fst(< ALGO ; CONF >) = ALGO . 
    eq snd(< ALGO ; CONF >) = CONF . 

   *** Does the scenario contain any loop
   eq containsCycle(empty) = false .
   eq containsCycle(LOOPS) = true [owise] .

   eq solveLoop(CONF Algorithm: ALGO, AlgebraicLoop: PSet Type: LOOPTYPE) = solveLoopConf(CONF, AlgebraicLoop: PSet Type: LOOPTYPE)
        Algorithm: (ALGO ; (solveLoopAlgorithm(CONF, AlgebraicLoop: PSet Type: LOOPTYPE))) .

  eq solveLoopConf(CONF, AlgebraicLoop: PSet Type: LOOPTYPE) = snd(loopStep(PSet, breakLoop(PSet, CONF, LOOPTYPE), emptyList)) .

  ceq solveLoopAlgorithm(CONF, AlgebraicLoop: PSet Type: LOOPTYPE) = 
    complexEvent: Loop SaveSUs: SUIDS RestoreSUs: SUIDS Actions: fst(loopStep(PSet, breakLoop(PSet, CONF, LOOPTYPE), emptyList))
        if SUIDS := getSUs(PSet, empty) .

    *** Forget All Connections depending on type of loop 
    ceq breakLoop((ID1 ! INPUT) ;; PSet,   
                     < ID1 : SU | inputs : (< INPUT : Input | type : MODE > INPUTS) > 
                     < ID2 : SU | outputs : (< OUTPUT : Output | > OUTPUTS) > 
                     (ID2 ! OUTPUT ==> ID1 ! INPUT) guessOn: GSet CONF, LOOPTYPE) = 
                        breakLoop((ID1 ! INPUT) ;; PSet, < ID1 : SU | > < ID2 : SU | > guessOn: ((ID1 ! INPUT) ;; GSet) CONF, LOOPTYPE) 
                        if (LOOPTYPE == R and MODE == r) or (LOOPTYPE == F and MODE == d) .

    eq breakLoop(PSet, CONF, LOOPTYPE) = CONF [owise] .

    *** Set value using Guess
    ceq loopStep((ID1 ! INPUT) ;; PSet, 
                      < ID1 : SU | time : TIME, inputs : (< INPUT : Input | time : T1, type : MODE > INPUTS) > 
                    guessOn: ((ID1 ! INPUT) ;; GSet) stepSize: STEP CONF, ALGO) = 
            loopStep(PSet, 
                    setAction(< ID1 : SU | >, INPUT, T1 + STEP)
                    guessOn: GSet stepSize: STEP CONF, 
                    (ALGO ; (event: Set SU: ID1 PId: INPUT))) 
                    if (MODE == r and T1 == TIME) or (MODE == d and TIME == (T1 + STEP)) .

    *** Set value on input - Fix
    ceq loopStep((ID1 ! INPUT) ;; PSet, 
                      < ID1 : SU | inputs : (< INPUT : Input | time : TIME, type : MODE > INPUTS) > 
                      < ID2 : SU | outputs : (< OUTPUT : Output | time : T1, status : Def > OUTPUTS) > 
                        (ID2 ! OUTPUT ==> ID1 ! INPUT) CONF, ALGO) = 
              loopStep(PSet, 
                      setAction(< ID1 : SU | >, INPUT, T1)
                      < ID2 : SU | > (ID2 ! OUTPUT ==> ID1 ! INPUT) CONF, 
                      (ALGO ; (event: Set SU: ID1 PId: INPUT))) 
                      if T1 > TIME .

    *** Get output value
    ceq loopStep((ID1 ! OUTPUT) ;; PSet, 
                    < ID1 : SU | time : TIME, outputs : (< OUTPUT : Output | status : Undef, dependsOn : FEEDTHROUGH > OUTPUTS), inputs : INPUTS > CONF, ALGO) = 
                    loopStep(PSet,
                      getAction(< ID1 : SU | >, OUTPUT) CONF, 
                      (ALGO ; (event: Get SU: ID1 PId: OUTPUT))) 
                      if feedthroughSatisfied(FEEDTHROUGH, INPUTS, TIME) .

    *** Step
    ceq loopStep((ID1 ! OUTPUT) ;; PSet,  
                    < ID1 : SU | time : TIME, outputs : OUTPUTS, inputs : INPUTS > stepSize: STEP CONF, ALGO) = 
                  loopStep((ID1 ! OUTPUT) ;; PSet,
                      stepAction(< ID1 : SU | >, STEP) 
                      stepSize: STEP CONF, (ALGO ; (event: Step SU: ID1 PId: empty)))
                    if canStep(TIME, (TIME + STEP), INPUTS, OUTPUTS) .

    eq loopStep(empty,CONF, ALGO) = < ALGO ; CONF  > .

endom)
