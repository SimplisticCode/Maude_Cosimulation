load ScenarioAnalyser

(omod SCENARIO is 
   protecting ScenarioAnalyser .
    sort GlobalState .

  *** Definition of the scenario
  *** External Connections - all ports have unique name
  op externalConnection : ->  Configuration .    
  op simulationUnits : -> Configuration .      *** SUs - ID * input ports * and outputs
  op scenario : Configuration Configuration -> Configuration . 
  op validScenario : Configuration Configuration -> Bool .
  op setup : -> GlobalState .
  op `{_`} : Configuration -> GlobalState .
  op calculateSNSet : Configuration -> Configuration .

  vars ID1 ID2 : SUID .
  vars INPUT OUTPUT : PortId .
  vars SUs CONNECTIONS INPUTS OUTPUTS CONF SCENARIOMODEL : Configuration .
  var SUIDs : OidSet .
  var TYPE : PortType .
  var SCCs : AlgebraicLoopSet .

  *** One to one check - change into different input types
  eq validScenario((ID1 ! OUTPUT ==> ID2 ! INPUT ) CONNECTIONS,  
  < ID1 : SU | outputs : < OUTPUT : Output | type : TYPE > OUTPUTS > 
  < ID2 : SU | inputs : < INPUT : Input | type : TYPE > INPUTS > SUs) 
  = validScenario(CONNECTIONS, < ID1 : SU | > < ID2 : SU | > SUs) .
  eq validScenario(none, SUs) = true .
  eq validScenario(CONNECTIONS, SUs) = false [owise] .
  *** Only one output per input

  *** Calculation of the members of the set of SUs that should be backtracked in the step negotiation
  ceq calculateSNSet(< ID1 : SU | inputs : (< INPUT : Input | contract : r > INPUTS) > 
                     < ID2 : SU | outputs : (< OUTPUT : Output | > OUTPUTS) > 
                      (ID2 ! OUTPUT ==> ID1 ! INPUT) (SNSet: (ID1 , SUIDs))  CONF) = 
                      calculateSNSet(< ID1 : SU | > < ID2 : SU | > (ID2 ! OUTPUT ==> ID1 ! INPUT) 
                      (SNSet: (ID1 , ID2 , SUIDs)) CONF) 
                      if not ID2 in SUIDs .
  
  ceq calculateSNSet(< ID1 : SU | canReject : true > (SNSet: SUIDs) CONF ) = 
        calculateSNSet(< ID1 : SU | > (SNSet: (ID1 , SUIDs)) CONF )
                                         if not ID1 in SUIDs .                             
  eq calculateSNSet(CONF) = CONF [owise] .

  ***Encoding of the Scenario 
  *** Coupling or connections
eq externalConnection = ("tank" ! "waterlevel" ==> "ctrl" ! "waterlevel") ("ctrl" ! "valveState" ==> "tank" ! "valveState") .

eq simulationUnits = (< "tank" : SU | path : "" , time : 0, inputs : (< "valveState" : Input | value : < 0 >, type : integer, time : 0, contract : d, status : Undef  >), outputs : (< "waterlevel" : Output | value : < 0 >, type : integer, time : 0, status : Undef, dependsOn : empty >), fmistate : Instantiated, canReject : false >)

(< "ctrl" : SU | path : "" , time : 0, inputs : (< "waterlevel" : Input | value : < 0 >, type : integer, time : 0, contract : d, status : Undef >), outputs : (< "valveState" : Output | value : < 0 >, type : integer, time : 0, status : Undef, dependsOn : empty >), fmistate : Instantiated, canReject : false >) .


ceq scenario(CONNECTIONS, SUs) = CONNECTIONS SUs 
    if validScenario(CONNECTIONS, SUs) .

  eq scenario(CONNECTIONS, SUs) = none [owise] .

  ceq setup = { CONF }
    if SCENARIOMODEL := scenario(externalConnection, simulationUnits)
    /\ SCCs := tarjan(SCENARIOMODEL)
    /\ CONF := calculateSNSet(SCENARIOMODEL stepSize: 1 endTime: 1 Algorithm: emptyList Termination: emptyList Initialization: emptyList SNSet: empty guessOn: empty SolvedSCC: empty UnsolvedSCC: SCCs valuesToSet: empty) .
   
endom)
eof

( red getAllPorts(scenario(externalConnection, simulationUnits), empty) .)

( red tarjan(scenario(externalConnection, simulationUnits)) . )

( red validScenario(externalConnection, simulationUnits) . )