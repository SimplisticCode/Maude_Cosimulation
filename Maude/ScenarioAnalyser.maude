load Environment 

(omod ScenarioAnalyser is
    protecting ScenarioEnvironment .

    op tarjan : Configuration -> Set{ALGEBRAICLOOPAsTRIV} .
    op dfs : Set{EPortIdAsTRIV} Environment Configuration -> DFSR .
    op dfs1 : EPortId Environment Configuration -> DFSR .

    var P : EPortId .
    vars PORTSET SUCCESORS : Set{EPortIdAsTRIV} .
    var IM : Set{IndexMapAsTRIV} .
    var C : Configuration .
    var SCCs : SetList{EPortIdAsTRIV} .
    var N N1 N2 : NzNat .
    var M : Nat .
    vars E E1 E2 : Environment .
    vars DFSRESULT DFSRESULT1 : DFSR .
    var STACKTUPLE : PStackTuple .
    vars OLDSTACK STACK SCCSTACK : List{EPortIdAsTRIV} .

    ceq tarjan(C) = getLoops(dfsrEnv(dfs(PORTSET, E, C)), C) 
        if PORTSET := getAllPorts(C, empty) /\ IM := createIndexMap(PORTSET, empty) /\ 
        E := env(emptyList, nil, 1, IM) .

    *** P has been visisted before - N is non-zero!
    ceq dfs(P ;; PORTSET, env(STACK, SCCs, M, map(P, N) ;; IM), C) = natEnv(min(N, N1), E) 
       if DFSRESULT := dfs(PORTSET, env(STACK, SCCs, M, map(P, N) ;; IM), C) 
       /\ N1 := num(DFSRESULT) 
       /\ E := dfsrEnv(DFSRESULT) .

    *** Dead end - no successor!
    eq dfs(empty, E, C) = natEnv(100000, E) .

    *** P has not been visited before - none of the other cases match
    ceq dfs(P ;; PORTSET, E, C) = natEnv(min(N1, N2), E2) 
        if DFSRESULT := dfs1(P, E, C) /\
            E1 := dfsrEnv(DFSRESULT) /\
            N1 := num(DFSRESULT) /\
            DFSRESULT1 := dfs(PORTSET, E1, C) /\
            N2 := num(DFSRESULT1) /\
            E2 := dfsrEnv(DFSRESULT1) 
         [owise] .

    *** If we can find a Node with a lower index we use the lower index
    ceq dfs1(P, E, C) = dfs(SUCCESORS, E1, C)
        if SUCCESORS := findSuccesors(P, C) /\ 
           E1 := addStackIncr(P, E) /\ 
           (num (dfs(SUCCESORS, E1, C)) < getSN(E)) .
            

    *** If we cannot find a Node with a lower index
    ceq dfs1(P, E, C) = natEnv(100000, 
            env(OLDSTACK, getSCC(DFSRESULT) ; elems(SCCSTACK), getSN(dfsrEnv(DFSRESULT)), setInfty(SCCSTACK, getIM(DFSRESULT))))
                if SUCCESORS := findSuccesors(P, C) 
                /\ E1 := addStackIncr(P, E) 
                /\ DFSRESULT := dfs(SUCCESORS, E1, C) 
                /\ STACKTUPLE := split(P, getStack(DFSRESULT))
                /\ OLDSTACK := sndStack(STACKTUPLE) 
                /\ SCCSTACK := fstStack(STACKTUPLE) [owise] .    
endom)

eof


(red split(('SU1 ! 'S), ('SU1 ! 'R) :: (('SU1 ! 'S) :: (('SU1 ! 'T) :: emptyList)) ) .)

( frew [100] setup . )

( red tarjan(simulationUnits externalConnection) . )

( red portInMap('msd1 ! 'fk, map('msd1 ! 'fk,1) ;; map('msd1 ! 'v1,0)) .)

( red getSCC(natEnv(100000,env('msd1 ! 'fk :: emptyList,nil,2,map('msd1 ! 'fk,1) ;; map('msd1 ! 'v1,0);; map('msd1 ! 'x1,0);; map('msd1 ! 'z,0);; map('msd2 !
    'fk,0);; map('msd2 ! 'v1,0);; map('msd2 ! 'x1,0);; map('msd2 ! 'z,0)))) .)

( red num(natEnv(100000,env('msd1 ! 'fk,nil,2,map('msd1 ! 'fk,1) ;; map('msd1 ! 'v1,0);; map('msd1 ! 'x1,0);; map('msd1 ! 'z,0);; map('msd2 !
    'fk,0);; map('msd2 ! 'v1,0);; map('msd2 ! 'x1,0);; map('msd2 ! 'z,0)))) . )

( red dfsrEnv(natEnv(100000,env('msd1 ! 'fk,nil,2,map('msd1 ! 'fk,1) ;; map('msd1 ! 'v1,0);; map('msd1 ! 'x1,0);; map('msd1 ! 'z,0);; map('msd2 !
    'fk,0);; map('msd2 ! 'v1,0);; map('msd2 ! 'x1,0);; map('msd2 ! 'z,0)))) .
)

( red findSuccesors(('msd1 ! 'x1), simulationUnits externalConnection) .)

( red min(1000, 1) .)

( red dfs(getAllPorts((simulationUnits externalConnection), empty), env(emptyList, nil, 1, createIndexMap(getAllPorts((simulationUnits externalConnection), empty), empty)), (simulationUnits externalConnection)) . )

( red dfsrEnv(natEnv(100000,env(emptyST,('msd1 ! 'z)**('msd2 ! 'z)**('msd1 ! 'x1);;('msd2 ! 'v1);;('msd2 ! 'fk);;('msd1 !
    'v1);; 'msd1 ! 'fk,8,map('msd1 ! 'fk,100000);; map('msd1 ! 'v1,100000);; map('msd1 ! 'x1,100000);; map('msd1 ! 'z,100000);; map('msd2 ! 'fk,100000);; map('msd2 ! 'v1,100000);; map('msd2 ! 'x1,0);;
    map('msd2 ! 'z,100000)))) . )


( red dfsrEnv(dfs(getAllPorts(simulationUnits externalConnection, empty), env(emptyST, nil, 1, createIndexMap(getAllPorts(simulationUnits externalConnection, empty), empty)), simulationUnits externalConnection)) . )


(red dfs(('msd1 ! 'fk);;('msd1 ! 'v1);;('msd1 ! 'x1);;('msd1 ! 'z);;('msd2 ! 'fk);;('msd2 ! 'v1);;('msd2 ! 'x1);; 'msd2 ! 'z,env(emptyList,
    nil,1,map('msd1 ! 'fk,0);; map('msd1 ! 'v1,0);; map('msd1 ! 'x1,0);; map('msd1 ! 'z,0);; map('msd2 ! 'fk,0);; map('msd2 ! 'v1,0);;
    map('msd2 ! 'x1,0);; map('msd2 ! 'z,0)),(
'msd1 ! 'v1 ==> 'msd2 ! 'v1)(
'msd1 ! 'x1 ==> 'msd2 ! 'x1)(
'msd1 ! 'z ==> 'msd2 ! 'z)(
'msd2 ! 'fk ==> 'msd1 ! 'fk)< 'msd1 : SU | canReject : false,inputs : < 'fk : Input | status : Undef,time : 0,contract : r >,outputs :(< 'v1 :
    Output | dependsOn : empty,status : Undef,time : 0 > < 'x1 : Output | dependsOn : empty,status : Undef,time : 0 > < 'z : Output | dependsOn
    : empty,status : Undef,time : 0 >),state : Instantiated,time : 0 > < 'msd2 : SU | canReject : false,inputs :(< 'v1 : Input | status : Undef,
    time : 0,contract : r > < 'x1 : Input | status : Undef,time : 0,contract : r > < 'z : Input | status : Undef,time : 0,contract : d >),outputs : < 'fk :
    Output | dependsOn :('v1 ;; 'x1),status : Undef,time : 0 >,state : Instantiated,time : 0 >) . )


(red dfs1(('msd1 ! 'fk), env(emptyList,
    nil,1,map('msd1 ! 'fk,0);; map('msd1 ! 'v1,0);; map('msd1 ! 'x1,0);; map('msd1 ! 'z,0);; map('msd2 ! 'fk,0);; map('msd2 ! 'v1,0);;
    map('msd2 ! 'x1,0);; map('msd2 ! 'z,0)), (
'msd1 ! 'v1 ==> 'msd2 ! 'v1)(
'msd1 ! 'x1 ==> 'msd2 ! 'x1)(
'msd1 ! 'z ==> 'msd2 ! 'z)(
'msd2 ! 'fk ==> 'msd1 ! 'fk)< 'msd1 : SU | canReject : false,inputs : < 'fk : Input | status : Undef,time : 0,contract : r >,outputs :(< 'v1 :
    Output | dependsOn : empty,status : Undef,time : 0 > < 'x1 : Output | dependsOn : empty,status : Undef,time : 0 > < 'z : Output | dependsOn
    : empty,status : Undef,time : 0 >),state : Instantiated,time : 0 > < 'msd2 : SU | canReject : false,inputs :(< 'v1 : Input | status : Undef,
    time : 0,contract : r > < 'x1 : Input | status : Undef,time : 0,contract : r > < 'z : Input | status : Undef,time : 0,contract : d >),outputs : < 'fk :
    Output | dependsOn :('v1 ;; 'x1),status : Undef,time : 0 >,state : Instantiated,time : 0 >) . )
