load Algorithm
(omod SimulationUnit is
   protecting Ports + Algorithm .
   sort fmiState .
   
   *** The different states of the FMI standard
   ops Instantiated ExperimentSetup Initialize Simulation Terminated InstanceFreed Unloaded : -> fmiState [ctor] . 

   ***Classes
   class SU | time : Nat, inputs : Configuration, outputs : Configuration, canReject : Bool, state : fmiState .

   op askStepSize : Object NzNat -> NzNat .
   op feedthroughSatisfied : PortIdSet Configuration Nat -> Bool .
   op allDef : Configuration Nat -> Bool .
   op undefPorts : Configuration Nat -> Configuration .
   op undefInputs : Configuration -> Configuration .  
   op allInputsDef : Configuration Nat Nat -> Bool .
   op allInputsSet : Configuration -> Bool .
   op canStep : Nat NzNat Configuration Configuration -> Bool .

   op getAction : Object PortId -> Object .
   op setAction : Object PortId Nat -> Object .
   op stepAction : Object NzNat -> Object .

   var ID : SUID .
   vars PId I O : PortId .
   vars TIME SUTIME : Nat .
   vars C INPUTS OUTPUTS : Configuration .
   var PS : PortStatus .
   var FT : PortIdSet .
   vars FUTURETIME STEP : NzNat .

   *** Checks if all feedthrough constraints are satisfied
   eq feedthroughSatisfied(emptySet, C, TIME) = true .
   eq feedthroughSatisfied(PId :: FT, < PId : Input | status : Undef > C, TIME) = false .
   eq feedthroughSatisfied(PId :: FT, < PId : Input | time : TIME, status : Def > C, TIME) =  feedthroughSatisfied(FT, C, TIME) .

   eq allDef(none, TIME) = true .
   eq allDef(< PId : Port | status : PS, time : TIME > C, TIME) = PS == Def and allDef(C, TIME) .

   eq allInputsDef(none, SUTIME, FUTURETIME) = true .
   eq allInputsDef(< PId : Input | time : SUTIME, type : d, status : PS > C, SUTIME, FUTURETIME) = PS == Def and allInputsDef(C, SUTIME, FUTURETIME) .
   eq allInputsDef(< PId : Input | time : FUTURETIME, type : r,  status : PS > C, SUTIME, FUTURETIME ) = PS == Def and allInputsDef(C, SUTIME, FUTURETIME) .

   eq undefPorts(none, TIME) = none .
   eq undefPorts(< PId : Port | > C, TIME) =  < PId : Port | status : Undef, time : TIME > undefPorts(C, TIME) .

   eq undefInputs(none) = none .
   eq undefInputs(< PId : Port | > C) =  < PId : Port | status : Undef > undefInputs(C) .

   eq allInputsSet(none) = true .
   eq allInputsSet(< ID : SU | inputs : INPUTS > C) = allDef(INPUTS, 0) and allInputsSet(C) .

   eq canStep(SUTIME, FUTURETIME, INPUTS, OUTPUTS) =  allInputsDef(INPUTS, SUTIME, FUTURETIME) and allDef(OUTPUTS, SUTIME) . 

   *** For the moment we allow all steps - should updated to reflect the nondeterminism of the step negotiation!
   eq askStepSize(< ID : SU | >, STEP) = STEP .

  *** Updates the time and status of the input
  eq getAction(< ID : SU | time : TIME, outputs : (< O : Output | > OUTPUTS) >, O) = < ID : SU | outputs : (< O : Output | time : TIME, status : Def > OUTPUTS) > .

  eq setAction(< ID : SU | inputs : (< I : Input | > INPUTS) > , I, TIME) =  < ID : SU | inputs : (< I : Input | time : TIME, status : Def > INPUTS) > .

  *** Updates the time and the status of the outputs
  ceq stepAction(< ID : SU | time : TIME, outputs : OUTPUTS >, STEP) = < ID : SU | time : FUTURETIME, outputs : undefPorts(OUTPUTS, FUTURETIME) > 
    if FUTURETIME := TIME + STEP .

endom)