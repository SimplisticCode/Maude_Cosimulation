load Algorithm

(omod SimulationUnit is
   protecting Algorithm + RANDOM + STRING + LOCALSTATE .
   sort fmiState StepState .
   
   *** The different states of the FMI standard
   ops Instantiated ExperimentSetup Initialize Simulation Terminated InstanceFreed Unloaded : -> fmiState [ctor] . 

   ***Classes
   class SU |
     path : String, 
     time : Nat, 
     inputs : Configuration, ***Input ports
     outputs : Configuration, ***Output ports
     canReject : Bool, 
     fmistate : fmiState,
     parameters : LocalState,
     localState : LocalState .

   op askStepSize : Object NzNat -> NzNat .
   op feedthroughSatisfied : OidSet Configuration Nat -> Bool .
   op allDef : Configuration Nat -> Bool .
   op undefPorts : Configuration Nat -> Configuration .
   op allInputsDef : Configuration Nat Nat -> Bool .
   op allInputsSet : Configuration -> Bool .
   op canStep : Nat NzNat Configuration Configuration -> Bool .
   op getAction : Object OidSet -> Object .
   op setAction : Object OidSet FMIValue Nat -> Object .
   op stepAction : Object NzNat -> Object .
   ops getAllReactivePorts getAllPorts : Configuration PortSet -> PortSet .
   op commonTime : OidSet Configuration NzNat -> Bool . 

   vars SU1 SU2 : SUID .
   vars PORTID INPUT OUTPUT : PortId .
   vars TIME SUTIME VALVESTATE WATERLEVEL : Nat .
   vars CONF INPUTS OUTPUTS SAVEDSUs : Configuration .
   var VALUE : FMIValue .
   var EVALUE : PortValueAndTime .
   var PORTSTATUS : PortStatus .
   vars FEEDTHROUGH PORTS SUIDs : OidSet .
   vars FUTURETIME STEP : NzNat .
   var PORTSET : PortSet .
   vars VALUEMAP PORTVALUES GUESSES : PortValueMap .
   var CONTRACT : Contract .
   var EPORTID : EPortId .

   *** Get All ports in the scenario:
  ceq getAllPorts(< SU1 : SU | inputs : (< INPUT : Input | > INPUTS) > CONF, PORTSET) = 
    getAllPorts(< SU1 : SU | inputs : INPUTS > CONF,  ((SU1 ! INPUT) , PORTSET))
    if not (SU1 ! INPUT) in PORTSET .

  ceq getAllPorts(< SU1 : SU | outputs : (< OUTPUT : Output | > OUTPUTS) > CONF, PORTSET) = 
    getAllPorts(< SU1 : SU | outputs : OUTPUTS > CONF, ((SU1 ! OUTPUT) , PORTSET))
      if not (SU1 ! OUTPUT) in PORTSET .

  eq getAllPorts(CONF, PORTSET) = PORTSET [owise] . 

  eq commonTime(empty, CONF, TIME) = true .
  eq commonTime((SU1, SUIDs), < SU1 : SU | time : TIME > CONF, TIME) = commonTime(SUIDs, CONF, TIME) .
  eq commonTime(SUIDs, CONF, TIME) = false [owise] .

  ceq getAllReactivePorts(< SU1 : SU | inputs : (< INPUT : Input | contract : reactive > INPUTS) > CONF, PORTSET) = getAllReactivePorts(< SU1 : SU | inputs : INPUTS > CONF, ((SU1 ! INPUT) , PORTSET))
    if not (SU1 ! INPUT) in PORTSET .
  eq getAllReactivePorts(CONF, PORTSET) = PORTSET [owise] . 

   *** Checks if all feedthrough constraints are satisfied
   eq feedthroughSatisfied(empty, CONF, TIME) = true .
   eq feedthroughSatisfied((PORTID , FEEDTHROUGH), < PORTID : Input | status : Undef > CONF, TIME) = false .
   ceq feedthroughSatisfied((PORTID , FEEDTHROUGH), < PORTID : Input | time : TIME > CONF, SUTIME) = false 
    if TIME =/= SUTIME .
   eq feedthroughSatisfied((PORTID , FEEDTHROUGH), < PORTID : Input | time : TIME, status : Def > CONF, TIME) =  feedthroughSatisfied(FEEDTHROUGH, CONF, TIME) .

   eq allDef(none, TIME) = true .
   eq allDef(< PORTID : Port | status : PORTSTATUS, time : TIME > CONF, TIME) = PORTSTATUS == Def and allDef(CONF, TIME) .

   eq allInputsDef(none, SUTIME, FUTURETIME) = true .
   eq allInputsDef(< PORTID : Input | time : TIME, contract : CONTRACT, status : PORTSTATUS > CONF, SUTIME, FUTURETIME) = PORTSTATUS == Def and ((CONTRACT == reactive and TIME == FUTURETIME) or (CONTRACT == delayed and TIME == SUTIME))
        and allInputsDef(CONF, SUTIME, FUTURETIME) .

   eq undefPorts(none, TIME) = none .
   eq undefPorts(< PORTID : Port | > CONF, TIME) =  < PORTID : Port | value : < random(TIME) >, status : Undef, time : TIME > undefPorts(CONF, TIME) .

   eq allInputsSet(none) = true .
   eq allInputsSet(< SU1 : SU | inputs : INPUTS > CONF) = allDef(INPUTS, 0) and allInputsSet(CONF) .

   eq canStep(SUTIME, FUTURETIME, INPUTS, OUTPUTS) = 
      allInputsDef(INPUTS, SUTIME, FUTURETIME) and allDef(OUTPUTS, SUTIME) . 

   *** For the moment we allow all steps - should updated to reflect the nondeterminism of the step negotiation!
   eq askStepSize(< SU1 : SU | >, STEP) = STEP .

  *** Updates the time and status of the outputs
  eq getAction(< SU1 : SU | >, empty) = < SU1 : SU | > .
  eq getAction(< SU1 : SU | time : TIME, outputs : (< OUTPUT : Output | > OUTPUTS) >, (OUTPUT , PORTS)) = 
    getAction(< SU1 : SU | outputs : (< OUTPUT : Output | time : TIME, status : Def > OUTPUTS) >, PORTS) .


  eq setAction(< SU1 : SU | > , empty, VALUE, TIME) =  < SU1 : SU | > .
  eq setAction(< SU1 : SU | inputs : (< INPUT : Input | > INPUTS) > , (INPUT , PORTS), VALUE, TIME) = 
            setAction(< SU1 : SU | inputs : (< INPUT : Input | time : TIME, value : VALUE,  status : Def > INPUTS) >, PORTS, VALUE, TIME) .

  *** Updates the time and the status of the outputs
  ceq stepAction(< SU1 : SU | time : TIME, outputs : OUTPUTS >, STEP) 
    = < SU1 : SU | time : FUTURETIME, outputs : undefPorts(OUTPUTS, FUTURETIME) > 
    if FUTURETIME := TIME + STEP .


  *** Not done yet - need to specify all properties
  op restoreSUs : Configuration Configuration -> Configuration .
  eq restoreSUs(none, CONF) = CONF .
  eq restoreSUs(< SU1 : SU | >  SAVEDSUs, < SU1 : SU | >  CONF) = restoreSUs(SAVEDSUs, CONF) .

  op hasConverged : PortSet PortValueMap PortValueMap -> Bool . 
  eq hasConverged(empty, PORTVALUES, GUESSES) = true .
  eq hasConverged((EPORTID, PORTSET), ((EPORTID |-> EVALUE), PORTVALUES), ((EPORTID |-> EVALUE), GUESSES)) = hasConverged(PORTSET, PORTVALUES, GUESSES) .
  eq hasConverged(PORTSET, PORTVALUES, GUESSES) = false [owise] .

  op saveSUs : OidSet Configuration -> Configuration .
  eq saveSUs(empty, CONF) = none .
  eq saveSUs((SU1, SUIDs), < SU1 : SU | > CONF) = < SU1 : SU | > saveSUs(SUIDs, CONF) .


  op step : Object NzNat -> StepState [ctor] .
  subsort Object < StepState .

endom)