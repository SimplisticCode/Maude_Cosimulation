load LOOPSolver 

 
(fmod PAIR{X :: TRIV, Y :: TRIV} is 
 sort Pair{X, Y} . 
 op <_;_> : X$Elt Y$Elt -> Pair{X, Y} . 
 op 1st : Pair{X, Y} -> X$Elt . 
 op 2nd : Pair{X, Y} -> Y$Elt . 
 
 var A : X$Elt . 
 var B : Y$Elt . 
 eq 1st(< A ; B >) = A . 
 eq 2nd(< A ; B >) = B . 
endfm)

(omod StepFinder is
  protecting LOOPSolver .
  sorts findStepPair .
      
  op <_++_> : NzNat ActionList -> findStepPair [ctor] .

  *** Current State x Initial State -> Nat
  op findStep : SUIdSet Configuration Configuration ActionList -> findStepPair .
  op calculateSNSet : Configuration -> Configuration .
  op needsStepNegotiation : SUIdSet -> Bool .
  op getStep : findStepPair -> NzNat .
  op getAL : findStepPair -> ActionList .
  op stepFindingDone : SUIdSet Configuration NzNat -> Bool .

   vars ID1 ID2 : SUID .
   var SUIDs : SUIdSet .
   vars I O : PortId .
   vars TIME INPUTTIME OUTPUTTIME : Nat .
   vars STEPSIZE FUTURETIME1 FUTURETIME1 : NzNat .
   vars INPUTS OUTPUTS INPUTS1 : Configuration . 
   vars CONF C1 : Configuration .
   var ALGO : ActionList .
   var FEEDTHROUGH : PortIdSet .
   var LOOP : Algebraic .  
   var LOOPS : AlgebraicLoops .  

   eq stepFindingDone(emptySUSet, CONF, STEPSIZE) = true .
   eq stepFindingDone(ID1 ++ SUIDs, < ID1 : SU | time : FUTURETIME1 > CONF, STEPSIZE) = FUTURETIME1 == STEPSIZE and stepFindingDone(SUIDs, CONF, STEPSIZE) .


   eq getStep( < STEPSIZE ++ ALGO >) = STEPSIZE .
   eq getAL( < STEPSIZE ++ ALGO >) = ALGO .

  *** Step negotiation is needed if at least one SU can reject a Step
  eq needsStepNegotiation(emptySUSet) = false .
  eq needsStepNegotiation(SUIDs) = true [owise] .

   *** Calculation of the members of the set of SUs that should be backtracked in the step negotiation
  ceq calculateSNSet(< ID1 : SU | inputs : (< I : Input | type : r > INPUTS) > 
                      < ID2 : SU | outputs : (< O : Output | > OUTPUTS) > 
                      (ID2 ! O ==> ID1 ! I) (SNSet: (ID1 ++ SUIDs))  CONF) = 
                      calculateSNSet(< ID1 : SU | > < ID2 : SU | > (ID2 ! O ==> ID1 ! I) 
                      (SNSet: (ID1 ++ ID2 ++ SUIDs)) CONF) 
                      if not ID2 in SUIDs .
  
  ceq calculateSNSet(< ID1 : SU | canReject : true > (SNSet: SUIDs) CONF ) = 
        calculateSNSet(< ID1 : SU | > (SNSet: (ID1 ++ SUIDs)) CONF )
                                         if not ID1 in SUIDs .                                    
  eq calculateSNSet(CONF) = CONF [owise] .

  *** Get case (only on reactive outputs)
  ceq findStep(ID1 ++ ID2 ++ SUIDs, 
                    < ID2 : SU | time : TIME, outputs : (< O : Output | status : Undef, dependsOn : FEEDTHROUGH > OUTPUTS), inputs : INPUTS1 >
                    < ID1 : SU | inputs : (< I : Input | type : r > INPUTS) > (ID2 ! O ==> ID1 ! I) CONF, C1, ALGO) = 
                    findStep(ID1 ++ ID2 ++ SUIDs, getAction(< ID2 : SU | >, O) < ID1 : SU | >  
                    (ID2 ! O ==> ID1 ! I) CONF, C1, ALGO ; (event: Get SU: ID2 PId: O)) 
                    if feedthroughSatisfied(FEEDTHROUGH, INPUTS1, TIME) .

  *** Set case (only on reactive Inputs)
  ceq findStep(ID1 ++ ID2 ++ SUIDs, 
                      < ID1 : SU | inputs : (< I : Input | time : INPUTTIME, type : r > INPUTS) > 
                      < ID2 : SU | outputs : (< O : Output | time : OUTPUTTIME, status : Def > OUTPUTS) > 
                        (ID2 ! O ==> ID1 ! I) CONF, C1, ALGO) = 
              findStep(ID1 ++ ID2 ++ SUIDs, setAction(< ID1 : SU | >, I, OUTPUTTIME) < ID2 : SU | > (ID2 ! O ==> ID1 ! I) CONF, C1, ALGO ; (event: Set SU: ID1 PId: I)) 
              if INPUTTIME < OUTPUTTIME .

  ***Stepping case
  ceq findStep(ID1 ++ SUIDs,  
                    < ID1 : SU | time : TIME, outputs : OUTPUTS, inputs : INPUTS > stepSize: STEPSIZE CONF, C1, ALGO) = 
                  findStep(ID1 ++ SUIDs,
                  stepAction(< ID1 : SU | >, FUTURETIME1) stepSize: FUTURETIME1 CONF, C1, ALGO ; (event: Step SU: ID1 PId: emptySet))
                    if canStep(TIME, (TIME + STEPSIZE), INPUTS, OUTPUTS) /\ FUTURETIME1 := askStepSize(< ID1 : SU | >, STEPSIZE) .

  *** Restart search and and update step size for next iteration of search
  ceq findStep(ID1 ++ ID2 ++ SUIDs, 
                        < ID1 : SU | time : FUTURETIME1 > 
                        < ID2 : SU | time : FUTURETIME1 > CONF, C1 stepSize: STEPSIZE, ALGO) = 
              findStep(ID1 ++ ID2 ++ SUIDs, C1 stepSize: min(FUTURETIME1, FUTURETIME1), C1 stepSize: min(FUTURETIME1, FUTURETIME1), ALGO)   
                    if FUTURETIME1 =/= FUTURETIME1 . 
                    *** The simulations should both have stepped, but not to the same time

  *** Solve Algebraic Loops *** Information should be carried over!
  eq findStep(SUIDs, CONF SCC: (LOOP # LOOPS), C1 SCC: (LOOP # LOOPS), ALGO) = findStep(SUIDs, solveLoopConf(CONF SCC: LOOPS, LOOP), C1 SCC: LOOPS, ALGO ; solveLoopAlgorithm(CONF SCC: LOOPS, LOOP)) [owise] . 

  ceq findStep(SUIDs, CONF stepSize: STEPSIZE, C1, ALGO) = < STEPSIZE ++ ALGO > if stepFindingDone(SUIDs, CONF, STEPSIZE) . 

endom)

eof 
( red calculateSNSet(simulationUnits externalConnection SNSet: emptySUSet) . )

( red findStep('msd1 ++ 'msd2 ++ 'msd3 , simulationUnits externalConnection, simulationUnits externalConnection, emptyList) . )