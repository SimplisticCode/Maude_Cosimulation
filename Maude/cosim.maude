load StepFinder

(omod COSIMULATION is 
   protecting StepFinder .
   sort GlobalState .

   op performStepNegotiation : Configuration -> Configuration .
   op performGlobalStep : Configuration -> Configuration .
   op allSUinSimulation : Configuration -> Bool .
   op `{_`} : Configuration -> GlobalState .
   op getAllPorts : Configuration Set{EPortIdAsTRIV} -> Set{EPortIdAsTRIV} .
   op simulationStepDone : Configuration -> Bool .
   op getEnableOutputs : Configuration Configuration Nat -> Set{OIdAsTRIV} .
   op ValuesToSet : Configuration SUID Nat Configuration -> Set{PortValueMapEntryAsTRIV} .
   op ValuesToSetInit : Configuration SUID Configuration -> Set{PortValueMapEntryAsTRIV} .

   vars ID1 ID2 : SUID .
   var SUIDs : Set{OIdAsTRIV} .
   vars INPUT OUTPUT : PortId .
   vars TIME TIME1 TIME2 VALUE : Nat .
   vars INPUTS OUTPUTS OUTPUTSSETABLE CONF : Configuration . 
   var STATE : fmiState .
   vars ALGO STEPNEGOALGO : ActionList .
   vars FEEDTHROUGH PORTIDSET : Set{OIdAsTRIV} .
   var PORTS : Set{EPortIdAsTRIV} .
   vars STEPSIZE NEGOTIATEDSTEPSIZE FUTURETIME ENDTIME : NzNat .
   var LOOP : AlgebraicLoop .  
   vars LOOPS SOLVEDLOOPS : Set{ALGEBRAICLOOPAsTRIV} .  
   var INPUTTYPE : Contract .
   var STEPRes : findStepPair .
   var PORTVALUES : Set{PortValueMapEntryAsTRIV} .
   var SUINSTANCE : Object .
   var EVENT : Action .

  eq simulationStepDone(< ID1 : SU | time : TIME, inputs : INPUTS, outputs : OUTPUTS > CONF) = TIME > 0 and allDef(INPUTS, TIME) and allDef(OUTPUTS, TIME) and simulationStepDone(CONF) .
  eq simulationStepDone(CONF) = true [owise] .

  *** Step Negotiation
  ceq performStepNegotiation(CONF SNSet: SUIDs stepSize: STEPSIZE Algorithm: ALGO) = 
                              CONF SNSet: empty Algorithm: (ALGO ; EVENT) stepSize: NEGOTIATEDSTEPSIZE
                              if needsStepNegotiation(SUIDs) 
                              /\ STEPRes := findStep(SUIDs, CONF stepSize: STEPSIZE, CONF stepSize: STEPSIZE, emptyList) 
                              /\ NEGOTIATEDSTEPSIZE := getStep(STEPRes) 
                              /\ STEPNEGOALGO := getAL(STEPRes)
                              /\ EVENT := complexEvent: StepNegotiation SaveSUs: SUIDs RestoreSUs: SUIDs Actions: STEPNEGOALGO .

  ceq performStepNegotiation(CONF SNSet: SUIDs) = CONF if not needsStepNegotiation(SUIDs) .  

  *** Get All ports in the scenario:
  ceq getAllPorts(< ID1 : SU | inputs : (< INPUT : Input | > INPUTS) > CONF, PORTS) = getAllPorts(< ID1 : SU | > CONF,  (ID1 ! INPUT) ;; PORTS )
            if not (ID1 ! INPUT) in PORTS .

  ceq getAllPorts(< ID1 : SU | outputs : (< OUTPUT : Output | > OUTPUTS) > CONF, PORTS) = getAllPorts(< ID1 : SU | > CONF,  (ID1 ! OUTPUT) ;; PORTS )
            if not (ID1 ! OUTPUT) in PORTS .

  eq getAllPorts(CONF, PORTS) = PORTS [owise] . 

  *** All SUs are in the simulation state
  eq allSUinSimulation(< ID1 : SU | state : STATE > CONF) = STATE == Simulation and allSUinSimulation(CONF) . 
  eq allSUinSimulation(CONF) = true [owise] .

  eq getEnableOutputs(none, INPUTS, TIME) = empty . 
  ceq getEnableOutputs(< OUTPUT : Output | status : Undef, dependsOn : FEEDTHROUGH > OUTPUTS, INPUTS, TIME) = OUTPUT ;; getEnableOutputs(OUTPUTS, INPUTS, TIME)
        if feedthroughSatisfied(FEEDTHROUGH, INPUTS, TIME) .

  eq getEnableOutputs(< OUTPUT : Output | > OUTPUTS, INPUTS, TIME) = getEnableOutputs(OUTPUTS, INPUTS, TIME) [owise] .

  eq ValuesToSet(none, ID1, TIME, CONF) = empty .
  ceq ValuesToSet(< INPUT : Input | time : TIME1, contract : INPUTTYPE > INPUTS, ID1, TIME,
                                CONF < ID2 : SU | outputs : (< OUTPUT : Output | value : VALUE, time : TIME2, status : Def > OUTPUTS) > (ID2 ! OUTPUT ==> ID1 ! INPUT)) 
                        = (INPUT => < TIME2 ; VALUE >) ;; ValuesToSet(INPUTS, ID1, TIME, CONF < ID2 : SU | > (ID2 ! OUTPUT ==> ID1 ! INPUT)) 
                        if TIME1 < TIME2 and ((INPUTTYPE == d and TIME1 < TIME) or (INPUTTYPE == r and TIME == TIME1)) .

  eq ValuesToSet(< INPUT : Input | > INPUTS, ID1, TIME, CONF) = ValuesToSet(INPUTS, ID1, TIME, CONF) [owise] .

  eq ValuesToSetInit(none, ID1, CONF) = empty .
  eq ValuesToSetInit(< INPUT : Input | status : Undef > INPUTS, ID1, 
                    CONF < ID2 : SU | outputs : (< OUTPUT : Output | value : VALUE, status : Def > OUTPUTS) > (ID2 ! OUTPUT ==> ID1 ! INPUT)) 
                        = (INPUT => < 0 ; VALUE >) ;; ValuesToSetInit(INPUTS, ID1, CONF < ID2 : SU | outputs : (< OUTPUT : Output | status : Def > OUTPUTS) > ) .
  eq ValuesToSetInit(< INPUT : Input | > INPUTS, ID1, CONF) = ValuesToSetInit(INPUTS, ID1, CONF) [owise] .

  *** Perform the global simulation step
  *** Set input                     
  ceq performGlobalStep(CONF < ID1 : SU | time : TIME, inputs : INPUTS > Algorithm: ALGO) = 
      performGlobalStep(CONF SUINSTANCE Algorithm: (ALGO ; EVENT))
                        if PORTVALUES := ValuesToSet(INPUTS, ID1, TIME, CONF) 
                        /\ PORTIDSET := getPortFromMap(PORTVALUES) 
                        /\ PORTVALUES =/= empty 
                        /\ SUINSTANCE := setActionPortMap( < ID1 : SU | >, PORTVALUES) 
                        /\ EVENT := portEvent: Set SU: ID1 PId: PORTIDSET .
  *** Step
  ceq performGlobalStep(CONF < ID1 : SU | time : TIME, inputs : INPUTS, outputs : OUTPUTS > stepSize: STEPSIZE endTime: ENDTIME Algorithm: ALGO)  = 
      performGlobalStep(CONF SUINSTANCE stepSize: STEPSIZE endTime: ENDTIME Algorithm: (ALGO ; EVENT))
                        if FUTURETIME := TIME + STEPSIZE 
                        /\ canStep(TIME, FUTURETIME, INPUTS, OUTPUTS) and FUTURETIME <= ENDTIME 
                        /\ SUINSTANCE := stepAction(< ID1 : SU | >, STEPSIZE)
                        /\ EVENT := stepEvent: ID1 StepSize: STEPSIZE . 

  *** Get
    ceq performGlobalStep(CONF < ID1 : SU | time : TIME, inputs : INPUTS, outputs : OUTPUTS >  Algorithm: ALGO) =
        performGlobalStep(CONF SUINSTANCE Algorithm: (ALGO ; EVENT)) 
                        if PORTIDSET := getEnableOutputs(OUTPUTS, INPUTS, TIME)
                        /\ PORTIDSET =/= empty 
                        /\ SUINSTANCE := getAction(< ID1 : SU | >, PORTIDSET)
                        /\ EVENT := portEvent: Get SU: ID1 PId: PORTIDSET . 
                      
  *** Algebraic Loop - solve and remove loop
  eq performGlobalStep(CONF UnsolvedSCC: (LOOP ;; LOOPS) SolvedSCC: SOLVEDLOOPS) = performGlobalStep(solveLoop(CONF UnsolvedSCC: LOOPS SolvedSCC: (LOOP ;; SOLVEDLOOPS), LOOP)) [owise] .

  *** 
  ceq performGlobalStep(CONF) = CONF if simulationStepDone(CONF) .

  *** FMI-standard state transition:
  rl [setExp] : < ID1 : SU | state : Instantiated > Algorithm: ALGO 
                 => < ID1 : SU | state : ExperimentSetup > Algorithm: (ALGO ; (fmiEvent: CreateExp SU: ID1)) .

  rl [init] : < ID1 : SU | inputs : INPUTS , outputs : OUTPUTS, state : ExperimentSetup >  Algorithm: ALGO 
           => < ID1 : SU | inputs : undefPorts(INPUTS, 0), outputs : undefPorts(OUTPUTS, 0), state : Initialize > 
              Algorithm: (ALGO ; (fmiEvent: EnterInitialization SU: ID1)).

  crl [simulate] : < ID1 : SU | inputs : INPUTS , outputs : OUTPUTS, state : Initialize > CONF Algorithm: ALGO 
                => < ID1 : SU | state : Simulation > CONF Algorithm: (ALGO ; EVENT)
                if allDef(INPUTS, 0) and allDef(OUTPUTS, 0) and allInputsSet(CONF) 
                /\ EVENT := fmiEvent: ExitInitialization SU: ID1 .

  crl [terminate] : < ID1 : SU | time : TIME, inputs : INPUTS , outputs : OUTPUTS , state : Simulation > endTime: TIME Algorithm: ALGO 
                 => < ID1 : SU | state : Terminated > endTime: TIME Algorithm: (ALGO ; (fmiEvent: Terminate SU: ID1))
                 if allDef(OUTPUTS, TIME) and allDef(INPUTS, TIME) .

  rl [free] : < ID1 : SU | state : Terminated > Algorithm: ALGO 
           => < ID1 : SU | state : InstanceFreed > Algorithm: (ALGO ; (fmiEvent: FreeInstance SU: ID1)) .

  rl [unload] : < ID1 : SU | state : InstanceFreed > Algorithm: ALGO
              => < ID1 : SU | state : Unloaded > Algorithm: (ALGO ; (fmiEvent: Unload SU: ID1)) .

   *** Initalization Procedure 
   crl [get-init] : < ID1 : SU | outputs : OUTPUTS, inputs : INPUTS, state : Initialize > Algorithm: ALGO 
                  => 
                  getAction(< ID1 : SU | >, getEnableOutputs(OUTPUTS, INPUTS, 0))                  
                  Algorithm: (ALGO ; (portEvent: Get SU: ID1 PId: getEnableOutputs(OUTPUTS, INPUTS, 0))) 
                if getEnableOutputs(OUTPUTS, INPUTS, 0) =/= empty .

   *** Inputs can only rely on one connection 
   crl [set-init] : < ID1 : SU | inputs : INPUTS, state : Initialize > Algorithm: ALGO CONF
                        => setActionPortMap(< ID1 : SU | >, ValuesToSetInit(INPUTS, ID1, CONF)) Algorithm: (ALGO ; (portEvent: Set SU: ID1 PId: getPortFromMap(ValuesToSetInit(INPUTS, ID1, CONF)))) CONF
        if ValuesToSetInit(INPUTS, ID1, CONF) =/= empty .

  ***rl [init-loop] : CONF UnsolvedSCC: (L ;; LOOPS) => solveLoop(CONF UnsolvedSCC: LOOPS, L) .                 

 ***Complex scenarios with save and restore - this should 

  ***If the scenario contains SUs that require step negotiation
  ***The step negotiation
  crl [stepNego] : { CONF SNSet: SUIDs} => 
          { performStepNegotiation(CONF SNSet: SUIDs)}
          if needsStepNegotiation(SUIDs) and allSUinSimulation(CONF) .


  crl [simulationStep]: { CONF SNSet: SUIDs} => 
          { performGlobalStep(CONF SNSet: SUIDs) }
        if (not needsStepNegotiation(SUIDs)) and allSUinSimulation(CONF) .

   *** Definition of system
  op externalConnection : ->  Configuration .    *** External Connections - all ports have unique name
  op simulationUnits : -> Configuration .      *** SUs - ID * input ports * and outputs


***Encoding of the Scenario 
eq externalConnection = ('msd1 ! 'x1 ==> 'msd2 ! 'x1) ('msd1 ! 'v1 ==> 'msd2 ! 'v1) ('msd1 ! 'z ==> 'msd2 ! 'z) ('msd2 ! 'fk ==> 'msd1 ! 'fk) ('msd3 ! 'B ==> 'msd4 ! 'A) ('msd4 ! 'B ==> 'msd3 ! 'A) .

eq simulationUnits = (< 'msd1 : SU | path : "A" , time : 0, inputs : (< 'fk : Input | value : 0, time : 0, contract : r, status : Undef  >), outputs : (< 'x1 : Output | value : 0, time : 0, status : Undef, dependsOn : empty >) (< 'z : Output | value : 0, time : 0, status : Undef, dependsOn : empty >) (< 'v1 : Output | value : 0, time : 0, status : Undef, dependsOn : empty >), state : Instantiated, canReject : false >)

 	 (< 'msd2 : SU | path : "A" , time : 0, inputs : (< 'x1 : Input | value : 0, time : 0, contract : r, status : Undef  >) (< 'v1 : Input | value : 0, time : 0, contract : r, status : Undef  >) (< 'z : Input | value : 0, time : 0, contract : d, status : Undef  >), outputs : (< 'fk : Output | value : 0, time : 0, status : Undef, dependsOn : ( 'x1 ;; 'v1 ) >), state : Instantiated, canReject : false >)

 	 (< 'msd3 : SU | path : "A" , time : 0, inputs : (< 'A : Input | value : 0, time : 0, contract : r, status : Undef  >), outputs : (< 'B : Output | value : 0, time : 0, status : Undef, dependsOn : empty >), state : Instantiated, canReject : false >)

 	 (< 'msd4 : SU | path : "A" , time : 0, inputs : (< 'A : Input | value : 0, time : 0, contract : r, status : Undef  >), outputs : (< 'B : Output | value : 0, time : 0, status : Undef, dependsOn : empty >), state : Instantiated, canReject : false >) .


endom)

eof

*** Validering af Input

*** Check for termination - not useful 
(search setup =>! X:Configuration . )
show search graph .

( frew [20] setup . )

( frew [20] setup using fmi_rules_setExpt . )
( red needsStepNegotiation(setup) . )
( red allSUinSimulation(setup) . )

( red breakLoop(('msd1 ! 'x1) ;; ('msd2 ! 'x1) ;; ('msd2 ! 'v1) ;; ('msd1 ! 'v1), (simulationUnits externalConnection stepSize: 1 endTime: 1 Algorithm: emptyList SNSet: empty guessOn: emptyLoop) , R) . )

( red getSUs(('msd1 ! 'x1) ;; ('msd2 ! 'x1) ;; ('msd2 ! 'v1) ;; ('msd1 ! 'v1), empty) .)

( red findStep(setup,setup) . )
( red getAllPorts(simulationUnits, emptyLoop) . )

set trace on .
trace exclude FULL-MAUDE . set trace substitution off . set trace eq off . 