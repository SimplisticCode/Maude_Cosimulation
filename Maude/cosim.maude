load StepFinder

(omod COSIMULATION is 
   protecting StepFinder .
   sort GlobalState .

   op performStepNegotiation : Configuration -> Configuration .
   op performGlobalStep : Configuration -> Configuration .
   op allSUinSimulation : Configuration -> Bool .
   op `{_`} : Configuration -> GlobalState .
   op getPorts : Configuration EPortIdSet -> EPortIdSet .
   op simulationStepDone : Configuration -> Bool .

   vars ID1 ID2 : SUID .
   var SUIDs : SUIdSet .
   vars I O : PortId .
   vars T T1 T2 : Nat .
   vars INPUTS OUTPUTS C : Configuration . 
   var ST : fmiState .
   var AL : ActionList .
   var FT : PortIdSet .
   var P : EPortIdSet .
   var S : NzNat .
   var L : Algebraic .  
   var LOOPS : AlgebraicLoops .  
   var M : Mode .
   var STEPRes : findStepPair .

  eq simulationStepDone(< ID1 : SU | time : T, inputs : INPUTS, outputs : OUTPUTS > C) = T > 0 and allDef(INPUTS, T) and allDef(OUTPUTS, T) and simulationStepDone(C) .
  eq simulationStepDone(C) = true [owise] .

  *** Step Negotiation
  ceq performStepNegotiation(C SNSet: SUIDs stepSize: S Algorithm: AL) = 
                              C SNSet: emptySUSet 
                                Algorithm: (AL ; (complexEvent: StepNegotiation SaveSUs: SUIDs RestoreSUs: SUIDs 
                                Actions: getAL(STEPRes)))
                              (stepSize: getStep(STEPRes))
                              if needsStepNegotiation(SUIDs) /\ STEPRes := findStep(SUIDs, C stepSize: S, C stepSize: S, emptyList) .

  ceq performStepNegotiation(C SNSet: SUIDs) = C if not needsStepNegotiation(SUIDs) .  

  *** Get All ports in the scenario:
  ceq getPorts(< ID1 : SU | inputs : (< I : Input | > INPUTS) > C, P) = getPorts(< ID1 : SU | > C,  (ID1 ! I) ;; P )
            if not (ID1 ! I) in P .

  ceq getPorts(< ID1 : SU | outputs : (< O : Output | > OUTPUTS) > C, P) = getPorts(< ID1 : SU | > C,  (ID1 ! O) ;; P )
            if not (ID1 ! O) in P .

  eq getPorts(C, P) = P [owise] . 

  *** All SUs are in the simulation state
  eq allSUinSimulation(< ID1 : SU | state : ST > C) = ST == Simulation and allSUinSimulation(C) . 
  eq allSUinSimulation(C) = true [owise] .

  *** Perform the global simulation step
  *** Set input
  ceq performGlobalStep(C < ID1 : SU | time : T, inputs : (< I : Input | time : T1, type : M > INPUTS) > 
                          < ID2 : SU | outputs : (< O : Output | time : T2, status : Def > OUTPUTS) > 
                         (ID2 ! O ==> ID1 ! I) Algorithm: AL) = 
            performGlobalStep(C setAction( < ID1 : SU | >, I, T2) < ID2 : SU | > 
                         (ID2 ! O ==> ID1 ! I) 
                         Algorithm: (AL ; (event: Set SU: ID1 PId: I)))
                         if T1 < T2 and ((M == d and T1 < T) or (M == r and T == T1)) .

  *** Step
  ceq performGlobalStep(C < ID1 : SU | time : T, inputs : INPUTS, outputs : OUTPUTS > stepSize: S endTime: T2 Algorithm: AL)  = 
      performGlobalStep(C 
                        stepAction(< ID1 : SU | >, S)
                        stepSize: S endTime: T2 Algorithm: (AL ; (event: Step SU: ID1 PId: emptySet)))
                        if canStep(T, (T + S), INPUTS, OUTPUTS) and (T + S) <= T2 . 

  *** Get
  ceq performGlobalStep(C < ID1 : SU | time : T, inputs : INPUTS, outputs : (< O : Output | status : Undef, dependsOn : FT > OUTPUTS) >       Algorithm: AL) =
                    performGlobalStep(C getAction(< ID1 : SU | >, O) Algorithm: (AL ; (event: Get SU: ID1 PId: O)))  
                    if feedthroughSatisfied(FT, INPUTS, T) .

  *** Algebraic Loop - solve and remove loop
  eq performGlobalStep(C SCC: (L # LOOPS)) = solveLoop(C SCC: LOOPS, L) [owise] .

  *** 
  ceq performGlobalStep(C) = C if simulationStepDone(C) .

  *** FMI-standard state transition:
  rl [setExp] : < ID1 : SU | state : Instantiated > Algorithm: AL 
                 => < ID1 : SU | state : ExperimentSetup > Algorithm: (AL ; (fmiEvent: CreateExp SU: ID1)) .

  rl [init] : < ID1 : SU | inputs : INPUTS , outputs : OUTPUTS, state : ExperimentSetup >  Algorithm: AL 
           => < ID1 : SU | inputs : undefPorts(INPUTS, 0), outputs : undefPorts(OUTPUTS, 0), state : Initialize > 
              Algorithm: (AL ; (fmiEvent: EnterInitialization SU: ID1)).

  crl [simulate] : < ID1 : SU | inputs : INPUTS , outputs : OUTPUTS, state : Initialize > C Algorithm: AL 
                => < ID1 : SU | state : Simulation > C Algorithm: (AL ; (fmiEvent: ExitInitialization SU: ID1))
                if allDef(INPUTS, 0) and allDef(OUTPUTS, 0) and allInputsSet(C) .

  crl [terminate] : < ID1 : SU | time : T, inputs : INPUTS , outputs : OUTPUTS , state : Simulation > endTime: T Algorithm: AL 
                 => < ID1 : SU | state : Terminated > endTime: T Algorithm: (AL ; (fmiEvent: Terminate SU: ID1))
                 if allDef(OUTPUTS, T) and allDef(INPUTS, T) .

  rl [free] : < ID1 : SU | state : Terminated > Algorithm: AL 
           => < ID1 : SU | state : InstanceFreed > Algorithm: (AL ; (fmiEvent: FreeInstance SU: ID1)) .

  rl [unload] : < ID1 : SU | state : InstanceFreed > Algorithm: AL
              => < ID1 : SU | state : Unloaded > Algorithm: (AL ; (fmiEvent: Unload SU: ID1)) .


   *** Initalization Procedure 
   crl [get-init] :  < ID1 : SU | outputs : ((< O : Output | status : Undef , dependsOn : FT >) OUTPUTS) , inputs : INPUTS, state : Initialize > Algorithm: AL 
                  => 
                  getAction(< ID1 : SU | >, O)                  
                  Algorithm: (AL ; (event: Get SU: ID1 PId: O)) if feedthroughSatisfied(FT, INPUTS, 0) .

   *** Inputs can only rely on one connection 
   rl [set-init] :  < ID1 : SU | inputs : (< I : Input | status : Undef > INPUTS), state : Initialize > Algorithm: AL 
                    < ID2 : SU | outputs : (< O : Output | status : Def > OUTPUTS) > (ID2 ! O ==> ID1 ! I)
                        => 
                           setAction(< ID1 : SU | >, I, 0)
                           < ID2 : SU | > (ID2 ! O ==> ID1 ! I) Algorithm: (AL ; (event: Set SU: ID1 PId: I)) .


  ***rl [init-loop] : C SCC: (L # LOOPS) => solveLoop(C SCC: LOOPS, L) .                 

 ***Complex scenarios with save and restore - this should 

  ***If the scenario contains SUs that require step negotiation
  ***The step negotiation
  crl [stepNego] : { C SNSet: SUIDs} => 
          { performStepNegotiation(C SNSet: SUIDs)}
          if needsStepNegotiation(SUIDs) and allSUinSimulation(C) .


  crl [simulationStep]: { C SNSet: SUIDs} => 
          { performGlobalStep(C SNSet: SUIDs) }
        if (not needsStepNegotiation(SUIDs)) and allSUinSimulation(C) .

   *** Definition of system
  op externalConnection : ->  Configuration .    *** External Connections - all ports have unique name
  op simulationUnits : -> Configuration .      *** SUs - ID * input ports * and outputs


***Encoding of the Scenario 
eq externalConnection = ('msd1 ! 'x1 ==> 'msd2 ! 'x1) ('msd1 ! 'v1 ==> 'msd2 ! 'v1) ('msd2 ! 'fk ==> 'msd1 ! 'fk) ('msd2 ! 'z ==> 'msd3 ! 'z) ('msd3 ! 'G ==> 'msd2 ! 'G) .

eq simulationUnits = (< 'msd3 : SU | time : 0, inputs : (< 'z : Input | time : 0, type : d, status : Undef  >), outputs : (< 'G : Output | time : 0, status : Undef, dependsOn : ( 'z ) >), state : Instantiated, canReject : true >)

 	 (< 'msd2 : SU | time : 0, inputs : (< 'v1 : Input | time : 0, type : r, status : Undef  >) (< 'x1 : Input | time : 0, type : d, status : Undef  >) (< 'G : Input | time : 0, type : r, status : Undef  >), outputs : (< 'fk : Output | time : 0, status : Undef, dependsOn : ( 'x1 :: 'v1 ) >) (< 'z : Output | time : 0, status : Undef, dependsOn : emptySet >), state : Instantiated, canReject : true >)

 	 (< 'msd1 : SU | time : 0, inputs : (< 'fk : Input | time : 0, type : r, status : Undef  >), outputs : (< 'x1 : Output | time : 0, status : Undef, dependsOn : emptySet >) (< 'v1 : Output | time : 0, status : Undef, dependsOn : emptySet >), state : Instantiated, canReject : true >) .



endom)

eof

*** Check for termination - not useful 
(search setup =>! X:Configuration . )
show search graph .

( frew [20] setup . )

( frew [20] setup using fmi_rules_setExpt . )
( red needsStepNegotiation(setup) . )
( red allSUinSimulation(setup) . )

( red breakLoop(('msd1 ! 'x1) ;; ('msd2 ! 'x1) ;; ('msd2 ! 'v1) ;; ('msd1 ! 'v1), (simulationUnits externalConnection stepSize: 1 endTime: 1 Algorithm: emptyList SNSet: emptySUSet guessOn: emptyLoop) , R) . )

( red getSUs(('msd1 ! 'x1) ;; ('msd2 ! 'x1) ;; ('msd2 ! 'v1) ;; ('msd1 ! 'v1), emptySUSet) .)

( red findStep(setup,setup) . )
( red getPorts(simulationUnits, emptyLoop) . )

set trace on .
trace exclude FULL-MAUDE . set trace substitution off . set trace eq off . 