load Scenario

(omod COSIMULATION is 
   protecting StepFinder + SCENARIO .

   op performStepNegotiation : Configuration -> Configuration .
   op performGlobalStep : Configuration -> Configuration .
   op allSUsinSimulation : Configuration -> Bool .
   op simulationStepDone : Configuration -> Bool .
   op allSUsinSimulation : Configuration -> Bool .

   vars ID1 ID2 : SUID .
   vars INPUT OUTPUT : PortId .
   vars SUTIME INPUTTIME TIME : Nat .
   var VALUE : FMIValue .
   vars INPUTS OUTPUTS CONF STARTCONF SCENARIOMODEL CONF1 : Configuration . 
   var STATE : fmiState .
   vars ALGO STEPNEGOALGO INIT TERM : ActionList .
   vars FEEDTHROUGH : OidSet .
   var SUIDsNE : NeOidSet . 
   vars STEPSIZE NEGOTIATEDSTEPSIZE FUTURETIME ENDTIME : NzNat .
   var LOOP : AlgebraicLoop .  
   vars LOOPS SOLVEDLOOPS LOOPTOSOLVE SCCs : AlgebraicLoopSet .  
   vars PORTVALUES : PortValueMap .
   var SUINSTANCE : Object .
   var EVENT : Action .

  eq simulationStepDone(< ID1 : SU | time : TIME, inputs : INPUTS, outputs : OUTPUTS > CONF) = TIME > 0 and allDef(INPUTS, TIME) and allDef(OUTPUTS, TIME) and simulationStepDone(CONF) .
  eq simulationStepDone(CONF) = true [owise] .

  *** Step Negotiation
  ceq performStepNegotiation(CONF actualStepSize: STEPSIZE SNSet: SUIDsNE Algorithm: ALGO) = 
                              CONF SNSet: empty Algorithm: (ALGO ; EVENT) actualStepSize: NEGOTIATEDSTEPSIZE
                              if STARTCONF := CONF actualStepSize: STEPSIZE
                              /\ < NEGOTIATEDSTEPSIZE ++ STEPNEGOALGO > := findStep(SUIDsNE, STARTCONF, STARTCONF, emptyList)
                              /\ EVENT := complexEvent: StepNegotiation SaveSUs: SUIDsNE RestoreSUs: SUIDsNE Actions: STEPNEGOALGO .

  eq performStepNegotiation(CONF SNSet: empty) = CONF .  

  *** All SUs are in the simulation fmistate
  eq allSUsinSimulation(< ID1 : SU | fmistate : STATE > CONF) = STATE == Simulation and allSUsinSimulation(CONF) . 
  eq allSUsinSimulation(CONF) = true [owise] .

  *** All SUs unloaded
  eq allSUsinSimulation(< ID1 : SU | fmistate : STATE > CONF) = STATE == Unloaded and allSUsinSimulation(CONF) . 
  eq allSUsinSimulation(CONF) = true [owise] .

  *** FMI-standard fmistate transition:
  rl [setExp] : < ID1 : SU | fmistate : Instantiated > Initialization: ALGO 
                 => < ID1 : SU | fmistate : ExperimentSetup > Initialization: (ALGO ; (fmiEvent: CreateExp SU: ID1)) .

  rl [init] : < ID1 : SU | inputs : INPUTS , outputs : OUTPUTS, fmistate : ExperimentSetup >  Initialization: ALGO 
           => < ID1 : SU | inputs : undefPorts(INPUTS, 0), outputs : undefPorts(OUTPUTS, 0), fmistate : Initialize > 
              Initialization: (ALGO ; (fmiEvent: EnterInitialization SU: ID1)).

  crl [simulate] : < ID1 : SU | inputs : INPUTS , outputs : OUTPUTS, fmistate : Initialize > CONF Initialization: ALGO 
                => < ID1 : SU | fmistate : Simulation > CONF Initialization: (ALGO ; EVENT)
                if allDef(INPUTS, 0) and allDef(OUTPUTS, 0) and allInputsSet(CONF) 
                /\ EVENT := fmiEvent: ExitInitialization SU: ID1 .

  crl [terminate] : < ID1 : SU | time : TIME, inputs : INPUTS , outputs : OUTPUTS , fmistate : Simulation > endTime: TIME Termination: ALGO 
                 => < ID1 : SU | fmistate : Terminated > endTime: TIME Termination: (ALGO ; (fmiEvent: Terminate SU: ID1))
                 if allDef(OUTPUTS, TIME) and allDef(INPUTS, TIME) .

  rl [free] : < ID1 : SU | fmistate : Terminated > Termination: ALGO 
           => < ID1 : SU | fmistate : InstanceFreed > Termination: (ALGO ; (fmiEvent: FreeInstance SU: ID1)) .

  rl [unload] : < ID1 : SU | fmistate : InstanceFreed > Termination: ALGO
              => < ID1 : SU | fmistate : Unloaded > Termination: (ALGO ; (fmiEvent: Unload SU: ID1)) .

  *** Error handling in Maude

  *** Simulation Procedure
  *** Perform the global simulation step
  *** Set input          
  *** Reactive           
  ceq performGlobalStep(CONF < ID1 : SU | time : SUTIME, inputs : (< INPUT : Input | time : INPUTTIME, contract : r > INPUTS) > 
                        Algorithm: ALGO valuesToSet: (((ID1 ! INPUT) |-> < TIME ; VALUE >) , PORTVALUES)) = 
      performGlobalStep(CONF SUINSTANCE Algorithm: (ALGO ; EVENT) valuesToSet: PORTVALUES)
                        if TIME > SUTIME and INPUTTIME == TIME   
                        /\ SUINSTANCE := < ID1 : SU | inputs : (< INPUT : Input | value : VALUE, time : TIME > INPUTS) >
                        /\ EVENT := portEvent: Set SU: ID1 PId: INPUT .

  *** Delayed           
  ceq performGlobalStep(CONF < ID1 : SU | time : SUTIME, inputs : (< INPUT : Input | time : INPUTTIME, contract : d > INPUTS) > 
                        Algorithm: ALGO valuesToSet: (((ID1 ! INPUT) |-> < TIME ; VALUE >) , PORTVALUES)) = 
      performGlobalStep(CONF SUINSTANCE Algorithm: (ALGO ; EVENT) valuesToSet: PORTVALUES)
                        if TIME == SUTIME and INPUTTIME < TIME   
                        /\ SUINSTANCE := < ID1 : SU | inputs : (< INPUT : Input | value : VALUE, time : TIME > INPUTS) >
                        /\ EVENT := portEvent: Set SU: ID1 PId: INPUT .

  *** Step
  ceq performGlobalStep(CONF < ID1 : SU | time : TIME, inputs : INPUTS, outputs : OUTPUTS > actualStepSize: STEPSIZE endTime: ENDTIME Algorithm: ALGO)  = 
      performGlobalStep(CONF SUINSTANCE actualStepSize: STEPSIZE endTime: ENDTIME Algorithm: (ALGO ; EVENT))
                        if FUTURETIME := TIME + STEPSIZE 
                        /\ canStep(TIME, FUTURETIME, INPUTS, OUTPUTS) and FUTURETIME <= ENDTIME 
                        /\ SUINSTANCE := stepAction(< ID1 : SU | >, STEPSIZE)
                        /\ EVENT := stepEvent: ID1 StepSize: STEPSIZE . 

  *** Get
  ceq performGlobalStep(CONF < ID1 : SU | outputs : (< OUTPUT : Output | time : TIME, status : Undef, value : VALUE, dependsOn : FEEDTHROUGH > OUTPUTS), inputs : INPUTS >  Algorithm: ALGO valuesToSet: PORTVALUES
                                    (ID1 ! OUTPUT ==> ID2 ! INPUT)) =
                      performGlobalStep(CONF SUINSTANCE Algorithm: (ALGO ; EVENT) 
                      valuesToSet: insert((ID2 ! INPUT), < TIME ; VALUE >, PORTVALUES))
                      if SUINSTANCE := getAction(< ID1 : SU | >, OUTPUT)
                      /\ EVENT := portEvent: Get SU: ID1 PId: OUTPUT . 
                      
  
  *** Algebraic Loop - solve and remove loop
  eq performGlobalStep(CONF UnsolvedSCC: (LOOP , LOOPS) SolvedSCC: SOLVEDLOOPS) = 
    performGlobalStep(solveLoop(CONF UnsolvedSCC: LOOPS SolvedSCC: (LOOP , SOLVEDLOOPS), LOOP)) [owise] .

  *** Return the configuration is the simulation is done
  ceq performGlobalStep(CONF) = CONF
    if simulationStepDone(CONF) .
  
  *** Reset and start over if the endtime is not reached, reset loopsSolver and StepNegotiation
  ***ceq performGlobalStep(CONF endTime: ENDTIME) = CONF endTime: ENDTIME
  ***  if simulationStepDone(CONF) and endTime: ENDTIME .

  *** Extract the algortihm and call verify to verify it
 *** crl [get-algortihm]: CONF Algorithm: ALGO Initialization: INIT Termination: TERM => 
 ***                      Algorithm: ALGO Initialization: INIT Termination: TERM
  ***            if simulationDone(CONF) .

  *** Initialization Procedure 
  crl [get-init] :
              < ID1 : SU | fmistate : Initialize, inputs : INPUTS, 
                outputs : (< OUTPUT : Output | status : Undef, value : VALUE, dependsOn : FEEDTHROUGH > OUTPUTS) > 
                      (ID1 ! OUTPUT ==> ID2 ! INPUT) 
                      Initialization: ALGO 
                      valuesToSet: PORTVALUES
                  => SUINSTANCE Initialization: (ALGO ; EVENT) 
                      (ID1 ! OUTPUT ==> ID2 ! INPUT)
                      valuesToSet: insert((ID2 ! INPUT), < 0 ; VALUE >, PORTVALUES)
                if SUINSTANCE := < ID1 : SU | outputs : (< OUTPUT : Output | status : Def > OUTPUTS) > 
                  /\ feedthroughSatisfied(FEEDTHROUGH, INPUTS, 0)
                  /\ EVENT := portEvent: Get SU: ID1 PId: OUTPUT . 


   *** Inputs can only rely on one connection 
  crl [set-init] : < ID1 : SU | inputs : (< INPUT : Input | status : Undef > INPUTS), fmistate : Initialize > 
          Initialization: ALGO 
          valuesToSet: (((ID1 ! INPUT) |-> < TIME ; VALUE >), PORTVALUES)
              => SUINSTANCE Initialization: (ALGO ; EVENT) valuesToSet: PORTVALUES
                      if SUINSTANCE := < ID1 : SU | inputs : (< INPUT : Input | status : Def, value : VALUE > INPUTS ) >
                      /\ EVENT := portEvent: Set SU: ID1 PId: INPUT .

  ***rl [init-loop] : CONF UnsolvedSCC: (L ;; LOOPS) => solveLoop(CONF UnsolvedSCC: LOOPS, L) .                 

  ***If the scenario contains SUs that require step negotiation
  ***The step negotiation
  crl [stepNego] : { CONF SNSet: SUIDsNE } => 
          { performStepNegotiation(CONF SNSet: SUIDsNE)}
          if allSUsinSimulation(CONF) .


  crl [simulationStep]: { CONF } => 
          { performGlobalStep(CONF) }
        if allSUsinSimulation(CONF) .


  crl [getAlgortihm]: { SCENARIOMODEL } => 
                 { Algorithm: ALGO Termination: TERM Initialization: INIT }
      if initialState(SCENARIOMODEL)
      /\ SCCs := tarjan(SCENARIOMODEL)
      /\ CONF := calculateSNSet(SCENARIOMODEL actualStepSize: 1 defaultStepSize: 1 endTime: 1 Algorithm: emptyList Termination: emptyList Initialization: emptyList SNSet: empty guessOn: empty SolvedSCC: empty UnsolvedSCC: SCCs valuesToSet: empty) 
      /\ {CONF} => { CONF1 Algorithm: ALGO Termination: TERM Initialization: INIT } 
      /\ allSUsinSimulation(CONF1) .
    
***(
  op getAlgortihm : Configuration -> Configuration .
  ceq getAlgortihm(SCENARIOMODEL) = Algorithm: ALGO Termination: TERM Initialization: INIT 
  if SCCs := tarjan(SCENARIOMODEL)
      /\ CONF := calculateSNSet(SCENARIOMODEL actualStepSize: 1 defaultStepSize: 1 endTime: 1 Algorithm: emptyList Termination: emptyList Initialization: emptyList SNSet: empty guessOn: empty SolvedSCC: empty UnsolvedSCC: SCCs valuesToSet: empty) 
      /\ {CONF} => { CONF1 Algorithm: ALGO Termination: TERM Initialization: INIT } 
      /\ simulationDone(CONF1) .
      )


  op init : -> GlobalState .
  eq init = { scenario(externalConnection, simulationUnits) } .

  op initialState : Configuration -> Bool .
  eq initialState(CONF actualStepSize: STEPSIZE) = false .
  eq initialState(CONF) = true [owise] .


endom)

eof

(show all .)
q 

( frew [100] setup . )

(search setup. )

(search in COSIMULATION : setup =>1 C:Configuration . )

show search graph .

(red validScenario(externalConnection, simulationUnits) . )

( red allSUsinSimulation(setup) . )

( red breakLoop(('msd1 ! 'x1) ;; ('msd2 ! 'x1) ;; ('msd2 ! 'v1) ;; ('msd1 ! 'v1), (simulationUnits externalConnection actualStepSize: 1 endTime: 1 Algorithm: emptyList SNSet: empty guessOn: emptyLoop) , R) . )

( red findStep(setup,setup) . )
( red getAllPorts(simulationUnits, empty) . )

set trace on .
trace exclude FULL-MAUDE . set trace substitution off . set trace eq off . 

(red allSUsinSimulation(("ctrl" ! "valveState" ==> "tank" ! "valveState")(
"tank" ! "waterlevel" ==> "ctrl" ! "waterlevel")< "ctrl" : SU | canReject : false,fmistate : Unloaded,inputs : < "waterlevel" : Input |
    contract : d,status : Undef,time : 0,type : integer,value : < 0 > >,outputs : < "valveState" : Output | dependsOn : empty,status :
    Undef,time : 0,type : integer,value : < 0 > >,parameters : none,path : "",time : 0 > < "tank" : SU | canReject : false,fmistate :
    Unloaded,inputs : < "valveState" : Input | contract : d,status : Undef,time : 0,type : integer,value : < 0 > >,outputs : <
    "waterlevel" : Output | dependsOn : empty,status : Undef,time : 0,type : integer,value : < 0 > >,parameters : none,path : "",time : 0 > ) . )