load Scenario
*** Do things to start
(omod COSIMULATION is 
   protecting StepFinder + SCENARIO .

   op performStepNegotiation : Configuration -> Configuration .
   op performGlobalStep : Configuration -> Configuration .
   op allSUsinSimulation : Configuration -> Bool .
   op simulationStepDone : Configuration -> Bool .
   op allSUsinUnloaded : Configuration -> Bool .

  
   vars ID1 ID2 : SUID .
   vars INPUT OUTPUT : PortId .
   vars SUTIME INPUTTIME TIME : Nat .
   var VALUE : FMIValue .
   vars INPUTS OUTPUTS CONF STARTCONF SCENARIOMODEL CONF1 SUS : Configuration . 
   var STATE : fmiState .
   vars ALGO STEPNEGOALGO INIT TERM : ActionList .
   vars FEEDTHROUGH SUIDs : OidSet .
   var SUIDsNE : NeOidSet . 
   vars STEPSIZE NEGOTIATEDSTEPSIZE FUTURETIME ENDTIME : NzNat .
   var LOOP : AlgebraicLoop .  
   vars LOOPS SOLVEDLOOPS LOOPTOSOLVE : AlgebraicLoopSet .  
   vars PORTVALUES : PortValueMap .
   var SUINSTANCE : Object .
   var EVENT : Action .
   vars STATE1 STATE2 : fmiState .

  eq simulationStepDone(< ID1 : SU | time : TIME, inputs : INPUTS, outputs : OUTPUTS > CONF) = TIME > 0 and allDef(INPUTS, TIME) and allDef(OUTPUTS, TIME) and simulationStepDone(CONF) .
  eq simulationStepDone(CONF) = true [owise] .

  *** Step Negotiation
  ceq performStepNegotiation(CONF 
                        < "Orchestrator" : OrchestrationData | actualStepSize : STEPSIZE, SNSet : SUIDsNE, Algorithm : ALGO > ) = 
                        < "Orchestrator" : OrchestrationData | actualStepSize : NEGOTIATEDSTEPSIZE, SNSet : empty, Algorithm : (ALGO ; EVENT) > CONF
                              if STARTCONF := CONF < "Orchestrator" : OrchestrationData | >
                              /\ < NEGOTIATEDSTEPSIZE ++ STEPNEGOALGO > := findStep(SUIDsNE, STARTCONF, STARTCONF, emptyList)
                              /\ EVENT := complexEvent: StepNegotiation SaveSUs: SUIDsNE RestoreSUs: SUIDsNE Actions: STEPNEGOALGO .

  eq performStepNegotiation(CONF < "Orchestrator" : OrchestrationData | SNSet : empty > ) 
                              = CONF < "Orchestrator" : OrchestrationData | > .  

  *** All SUS are in the simulation fmistate
  eq allSUsinSimulation(< ID1 : SU | fmistate : STATE > SUS) = STATE == Simulation and allSUsinSimulation(SUS) . 
  eq allSUsinSimulation(CONF) = true [owise] .

  *** All SUS unloaded
  eq allSUsinUnloaded(< ID1 : SU | fmistate : STATE > SUS) = STATE == Unloaded and allSUsinUnloaded(SUS) . 
  eq allSUsinUnloaded(CONF) = true [owise] .

  ***SUS -> fmiState -> fmiState -> SUS
  op moveState : Configuration fmiState fmiState -> Configuration .
  eq moveState(< ID1 : SU | fmistate : STATE1 > SUS, STATE1, STATE2) = 
     < ID1 : SU | fmistate : STATE2 > moveState(SUS, STATE1, STATE2) .
  eq moveState(CONF, STATE1, STATE2) = CONF [owise] .

  op moveToInitialize : Configuration -> Configuration .
  eq moveToInitialize(< ID1 : SU | inputs : INPUTS , outputs : OUTPUTS, fmistate : ExperimentSetup > SUS) = 
     < ID1 : SU | fmistate : Initialize, inputs : undefPorts(INPUTS, 0), outputs : undefPorts(OUTPUTS, 0) > moveToInitialize(SUS) .
  eq moveToInitialize(CONF) = CONF [owise] .

  *** FMI-standard fmistate transition:
  *** Initialize all - to have fewer states
  rl [setExp] : { < ID1 : SU | fmistate : Instantiated > CONF
                  < "Orchestrator" : OrchestrationData | Initialization : ALGO > }
                 => { moveState(< ID1 : SU | > CONF, Instantiated, ExperimentSetup)
                    < "Orchestrator" : OrchestrationData | Initialization : (ALGO ; (fmiEvent: CreateExp SU: ID1)) > } .


  rl [init] : { < ID1 : SU | fmistate : ExperimentSetup > CONF
                  < "Orchestrator" : OrchestrationData | Initialization : ALGO > } 
           => { moveToInitialize(< ID1 : SU | > CONF)
                    < "Orchestrator" : OrchestrationData | Initialization : (ALGO ; (fmiEvent: EnterInitialization SU: ID1)) > } .
           

  crl [simulate] : { < ID1 : SU | inputs : INPUTS , outputs : OUTPUTS, fmistate : Initialize > CONF
                    < "Orchestrator" : OrchestrationData | Initialization : ALGO > } 
                => { moveState(< ID1 : SU | > CONF, Initialize, Simulation)
                    < "Orchestrator" : OrchestrationData | Initialization : (ALGO ; EVENT) > }
                if allDef(INPUTS, 0) and allDef(OUTPUTS, 0)
                /\ EVENT := fmiEvent: ExitInitialization SU: ID1 .

  crl [terminate] : { < ID1 : SU | time : ENDTIME, inputs : INPUTS , outputs : OUTPUTS , fmistate : Simulation > CONF
                  < "Orchestrator" : OrchestrationData | Termination : ALGO, endTime : ENDTIME > }
                 => { moveState(< ID1 : SU | > CONF, Simulation, Terminated)
                  < "Orchestrator" : OrchestrationData | Termination : (ALGO ; (fmiEvent: Terminate SU: ID1)) > } 
                 if allDef(OUTPUTS, ENDTIME) and allDef(INPUTS, ENDTIME) .

  rl [free] : { < ID1 : SU | fmistate : Terminated > CONF
                  < "Orchestrator" : OrchestrationData | Termination : ALGO > }
                 => { moveState(< ID1 : SU | > CONF, Terminated, InstanceFreed)
                  < "Orchestrator" : OrchestrationData | Termination : (ALGO ; (fmiEvent: FreeInstance SU: ID1)) > } .

  rl [unload] : { < ID1 : SU | fmistate : InstanceFreed > CONF
                  < "Orchestrator" : OrchestrationData | Termination : ALGO > }
                 => { moveState(< ID1 : SU | > CONF, InstanceFreed, Unloaded)
                  < "Orchestrator" : OrchestrationData | Termination : (ALGO ; (fmiEvent: Unload SU: ID1)) > } .

  *** Error handling in Maude

  *** Simulation Procedure
  *** Perform the global simulation step
  *** Set input          
  *** Reactive           
  ceq performGlobalStep(CONF < ID1 : SU | time : SUTIME, inputs : (< INPUT : Input | time : INPUTTIME, contract : r > INPUTS) > 
          < "Orchestrator" : OrchestrationData | Algorithm : ALGO, valuesToSet : (((ID1 ! INPUT) |-> < TIME ; VALUE >), PORTVALUES) >) = 
      performGlobalStep(CONF SUINSTANCE 
            < "Orchestrator" : OrchestrationData | Algorithm : (ALGO ; EVENT), valuesToSet : PORTVALUES >)
            if TIME > INPUTTIME and INPUTTIME == SUTIME   
            /\ SUINSTANCE := < ID1 : SU | inputs : (< INPUT : Input | value : VALUE, time : TIME > INPUTS) >
            /\ EVENT := portEvent: Set SU: ID1 PId: INPUT .

  *** Delayed           
  ceq performGlobalStep(CONF < ID1 : SU | time : SUTIME, inputs : (< INPUT : Input | time : INPUTTIME, contract : d > INPUTS) > 
      < "Orchestrator" : OrchestrationData | Algorithm : ALGO, valuesToSet : (((ID1 ! INPUT) |-> < TIME ; VALUE >), PORTVALUES) >) = 
      performGlobalStep(CONF SUINSTANCE 
            < "Orchestrator" : OrchestrationData | Algorithm : (ALGO ; EVENT), valuesToSet : PORTVALUES >)
            if TIME == SUTIME and INPUTTIME < SUTIME   
                /\ SUINSTANCE := < ID1 : SU | inputs : (< INPUT : Input | value : VALUE, time : TIME > INPUTS) >
                /\ EVENT := portEvent: Set SU: ID1 PId: INPUT .

  *** Step
  ceq performGlobalStep(CONF < ID1 : SU | time : TIME, inputs : INPUTS, outputs : OUTPUTS > 
    < "Orchestrator" : OrchestrationData | Algorithm : ALGO, actualStepSize : STEPSIZE, endTime : ENDTIME >)
      = 
      performGlobalStep(CONF SUINSTANCE 
              < "Orchestrator" : OrchestrationData | Algorithm : (ALGO ; EVENT) > )
                        if FUTURETIME := TIME + STEPSIZE 
                        /\ canStep(TIME, FUTURETIME, INPUTS, OUTPUTS) and FUTURETIME <= ENDTIME 
                        /\ SUINSTANCE := stepAction(< ID1 : SU | >, STEPSIZE)
                        /\ EVENT := stepEvent: ID1 StepSize: STEPSIZE . 

  *** Get
  ceq performGlobalStep(CONF < ID1 : SU | outputs : (< OUTPUT : Output | time : TIME, status : Undef, value : VALUE, dependsOn : FEEDTHROUGH > OUTPUTS), inputs : INPUTS >  
  < "Orchestrator" : OrchestrationData | Algorithm : ALGO, valuesToSet : PORTVALUES > 
        (ID1 ! OUTPUT ==> ID2 ! INPUT)) =
    performGlobalStep(CONF SUINSTANCE 
      < "Orchestrator" : OrchestrationData | Algorithm : (ALGO ; EVENT), valuesToSet : insert((ID2 ! INPUT), < TIME ; VALUE >, PORTVALUES) >)
              if feedthroughSatisfied(FEEDTHROUGH, INPUTS, TIME)
                /\ SUINSTANCE := < ID1 : SU | outputs : (< OUTPUT : Output | status : Def > OUTPUTS) >
                /\ EVENT := portEvent: Get SU: ID1 PId: OUTPUT . 
                      
  
  *** Algebraic Loop - solve and remove loop
  eq performGlobalStep(CONF 
      < "Orchestrator" : OrchestrationData | unsolvedSCC : (LOOP , LOOPS), solvedSCC : SOLVEDLOOPS > ) = 
    performGlobalStep(
      solveLoop(CONF < "Orchestrator" : OrchestrationData | unsolvedSCC : LOOPS, solvedSCC : (LOOP , SOLVEDLOOPS) >, LOOP)) [owise] .

  *** Return the configuration is the simulation is done
  ceq performGlobalStep(CONF) = CONF
    if simulationStepDone(CONF) .
  
  *** Reset and start over if the endtime is not reached, reset loopsSolver and StepNegotiation
  ***ceq performGlobalStep(CONF endTime: ENDTIME) = CONF endTime: ENDTIME
  ***  if simulationStepDone(CONF) and endTime: ENDTIME .

  *** Extract the algortihm and call verify to verify it
 *** crl [get-algortihm]: CONF Algorithm: ALGO Initialization: INIT Termination: TERM => 
 ***                      Algorithm: ALGO Initialization: INIT Termination: TERM
  ***            if simulationDone(CONF) .

  *** Initialization Procedure 
  crl [get-init] :
              < ID1 : SU | fmistate : Initialize, inputs : INPUTS, 
                outputs : (< OUTPUT : Output | status : Undef, value : VALUE, dependsOn : FEEDTHROUGH > OUTPUTS) > 
                      (ID1 ! OUTPUT ==> ID2 ! INPUT)
                      < "Orchestrator" : OrchestrationData | Initialization : ALGO, valuesToSet : PORTVALUES > 
                  => < ID1 : SU | outputs : (< OUTPUT : Output | status : Def > OUTPUTS) > 
                      (ID1 ! OUTPUT ==> ID2 ! INPUT)
                      < "Orchestrator" : OrchestrationData | Initialization : (ALGO ; EVENT), valuesToSet : insert((ID2 ! INPUT), < 0 ; VALUE >, PORTVALUES) >  
                if feedthroughSatisfied(FEEDTHROUGH, INPUTS, 0)
                  /\ EVENT := portEvent: Get SU: ID1 PId: OUTPUT . 


   *** Inputs can only rely on one connection 
  crl [set-init] : < ID1 : SU | inputs : (< INPUT : Input | status : Undef > INPUTS), fmistate : Initialize > 
        < "Orchestrator" : OrchestrationData | Initialization : ALGO, valuesToSet : (((ID1 ! INPUT) |-> < TIME ; VALUE >), PORTVALUES) >
              => < ID1 : SU | inputs : (< INPUT : Input | status : Def, value : VALUE > INPUTS ) >
                  < "Orchestrator" : OrchestrationData | Initialization : (ALGO ; EVENT), valuesToSet : PORTVALUES >
                      if EVENT := portEvent: Set SU: ID1 PId: INPUT .

  ***rl [init-loop] : CONF unsolvedSCC: (L ;; LOOPS) => solveLoop(CONF unsolvedSCC: LOOPS, L) .                 

  ***If the scenario contains SUS that require step negotiation
  ***The step negotiation
  crl [stepNego] : { CONF  < "Orchestrator" : OrchestrationData | SNSet : SUIDsNE > } => 
          { performStepNegotiation(CONF < "Orchestrator" : OrchestrationData | > ) }
          if allSUsinSimulation(CONF) .
 

  crl [simulationStep]: { CONF < "Orchestrator" : OrchestrationData | SNSet : empty > } => 
          { performGlobalStep(CONF < "Orchestrator" : OrchestrationData | > ) }
        if allSUsinSimulation(CONF) .


  crl [getAlgortihm]: { SCENARIOMODEL } => 
                 { < "Orchestrator" : OrchestrationData | > }
      if initialState(SCENARIOMODEL)
      /\ LOOPS := tarjan(SCENARIOMODEL)
      /\ CONF := calculateSNSet(SCENARIOMODEL initialOrchestrationData(1,1,LOOPS)) 
      /\ {CONF} => { CONF1 < "Orchestrator" : OrchestrationData | > } 
      /\ allSUsinUnloaded(CONF1) .
    
***(
  op getAlgortihm : Configuration -> Configuration .
  ceq getAlgortihm(SCENARIOMODEL) = Algorithm: ALGO Termination: TERM Initialization: INIT 
  if SCCs := tarjan(SCENARIOMODEL)
      /\ CONF := calculateSNSet(SCENARIOMODEL actualStepSize: 1 defaultStepSize: 1 endTime: 1 Algorithm: emptyList Termination: emptyList Initialization: emptyList SNSet: empty guessOn: empty solvedSCC: empty unsolvedSCC: SCCs valuesToSet: empty) 
      /\ {CONF} => { CONF1 Algorithm: ALGO Termination: TERM Initialization: INIT } 
      /\ simulationDone(CONF1) .
      )


  op init : -> GlobalState .
  eq init = { scenario(externalConnection, simulationUnits) } .

  op initialState : Configuration -> Bool .
  eq initialState(CONF < "Orchestrator" : OrchestrationData | >) = false .
  eq initialState(CONF) = true [owise] .


endom)

eof

(show all .)
q 

( frew [100] setup . )

( red moveState(setup, Instantiated, ExperimentSetup) . )


(search setup. )

(search in COSIMULATION : setup =>1 C:Configuration . )

show search graph .

(red validScenario(externalConnection, simulationUnits) . )

( red allSUsinSimulation(setup) . )

( red breakLoop(('msd1 ! 'x1) ;; ('msd2 ! 'x1) ;; ('msd2 ! 'v1) ;; ('msd1 ! 'v1), (simulationUnits externalConnection actualStepSize: 1 endTime: 1 Algorithm: emptyList SNSet: empty guessOn: emptyLoop) , R) . )

( red findStep(setup,setup) . )
( red getAllPorts(simulationUnits, empty) . )

set trace on .
trace exclude FULL-MAUDE . set trace substitution off . set trace eq off . 

(red moveState(("ctrl" ! "valveState" ==> "tank" ! "valveState")(
"tank" ! "waterlevel" ==> "ctrl" ! "waterlevel")< "ctrl" : SU | canReject : false,fmistate : Instantiated,inputs : < "waterlevel" : Input |
    contract : d,status : Undef,time : 0,type : integer,value : < 0 > >,outputs : < "valveState" : Output | dependsOn : empty,status :
    Undef,time : 0,type : integer,value : < 0 > >,parameters : none,path : "",time : 0 > < "tank" : SU | canReject : false,fmistate :
    Instantiated,inputs : < "valveState" : Input | contract : d,status : Undef,time : 0,type : integer,value : < 0 > >,outputs : <
    "waterlevel" : Output | dependsOn : empty,status : Undef,time : 0,type : integer,value : < 0 > >,parameters : none,path : "",time : 0 >,
    Instantiated, ExperimentSetup ) . )