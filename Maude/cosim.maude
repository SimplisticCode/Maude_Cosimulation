load Scenario

(omod COSIMULATION is 
   protecting StepFinder + SCENARIO .

   op performStepNegotiation : Configuration -> Configuration .
   op performGlobalStep : Configuration -> Configuration .
   op allSUinSimulation : Configuration -> Bool .
   op simulationStepDone : Configuration -> Bool .
   op getEnableOutputs : Configuration Configuration Nat OidSet -> OidSet .

   vars ID1 ID2 : SUID .
   vars INPUT OUTPUT : PortId .
   vars SUTIME TIME TIME1 TIME2 : Nat .
   var VALUE : FMIValue .
   vars INPUTS OUTPUTS CONF STARTCONF : Configuration . 
   var STATE : fmiState .
   vars ALGO STEPNEGOALGO : ActionList .
   vars SUIDs FEEDTHROUGH : OidSet .
   var SUIDsNE : NeOidSet . 
   vars STEPSIZE NEGOTIATEDSTEPSIZE FUTURETIME ENDTIME : NzNat .
   var LOOP : AlgebraicLoop .  
   vars LOOPS SOLVEDLOOPS LOOPTOSOLVE : AlgebraicLoopSet .  
   var INPUTTYPE : Contract .
   vars PORTVALUES : PortValueMap .
   var SUINSTANCE : Object .
   var EVENT : Action .

  eq simulationStepDone(< ID1 : SU | time : TIME, inputs : INPUTS, outputs : OUTPUTS > CONF) = TIME > 0 and allDef(INPUTS, TIME) and allDef(OUTPUTS, TIME) and simulationStepDone(CONF) .
  eq simulationStepDone(CONF) = true [owise] .

  *** Step Negotiation
  ceq performStepNegotiation(CONF actualStepSize: STEPSIZE UnsolvedSCC: LOOPS SolvedSCC: SOLVEDLOOPS
                                 SNSet: SUIDsNE Algorithm: ALGO) = 
                              CONF SNSet: empty Algorithm: (ALGO ; EVENT) actualStepSize: NEGOTIATEDSTEPSIZE
                                UnsolvedSCC: LOOPS SolvedSCC: SOLVEDLOOPS
                                ***UnsolvedSCC: (LOOPS - LOOPTOSOLVE)  SolvedSCC: (SOLVEDLOOPS ;; LOOPTOSOLVE)
                              if STARTCONF := CONF actualStepSize: STEPSIZE UnsolvedSCC: LOOPS SolvedSCC: SOLVEDLOOPS
                              /\ < NEGOTIATEDSTEPSIZE ++ STEPNEGOALGO > := findStep(SUIDsNE, STARTCONF, STARTCONF, emptyList)
                              ***/\ LOOPTOSOLVE := loopsInStepNegotiation(LOOPS, SUIDs, CONF) 
                              *** I need to break the loop (by removing the reactive connections) here to avoid it
                              /\ EVENT := complexEvent: StepNegotiation SaveSUs: SUIDsNE RestoreSUs: SUIDsNE Actions: STEPNEGOALGO .

  eq performStepNegotiation(CONF SNSet: empty) = CONF .  

  *** All SUs are in the simulation fmistate
  eq allSUinSimulation(< ID1 : SU | fmistate : STATE > CONF) = STATE == Simulation and allSUinSimulation(CONF) . 
  eq allSUinSimulation(CONF) = true [owise] .

  *** FMI-standard fmistate transition:
  rl [setExp] : < ID1 : SU | fmistate : Instantiated > Initialization: ALGO 
                 => < ID1 : SU | fmistate : ExperimentSetup > Initialization: (ALGO ; (fmiEvent: CreateExp SU: ID1)) .

  rl [init] : < ID1 : SU | inputs : INPUTS , outputs : OUTPUTS, fmistate : ExperimentSetup >  Initialization: ALGO 
           => < ID1 : SU | inputs : undefPorts(INPUTS, 0), outputs : undefPorts(OUTPUTS, 0), fmistate : Initialize > 
              Initialization: (ALGO ; (fmiEvent: EnterInitialization SU: ID1)).

  crl [simulate] : < ID1 : SU | inputs : INPUTS , outputs : OUTPUTS, fmistate : Initialize > CONF Initialization: ALGO 
                => < ID1 : SU | fmistate : Simulation > CONF Initialization: (ALGO ; EVENT)
                if allDef(INPUTS, 0) and allDef(OUTPUTS, 0) and allInputsSet(CONF) 
                /\ EVENT := fmiEvent: ExitInitialization SU: ID1 .

  crl [terminate] : < ID1 : SU | time : TIME, inputs : INPUTS , outputs : OUTPUTS , fmistate : Simulation > endTime: TIME Termination: ALGO 
                 => < ID1 : SU | fmistate : Terminated > endTime: TIME Termination: (ALGO ; (fmiEvent: Terminate SU: ID1))
                 if allDef(OUTPUTS, TIME) and allDef(INPUTS, TIME) .

  rl [free] : < ID1 : SU | fmistate : Terminated > Termination: ALGO 
           => < ID1 : SU | fmistate : InstanceFreed > Termination: (ALGO ; (fmiEvent: FreeInstance SU: ID1)) .

  rl [unload] : < ID1 : SU | fmistate : InstanceFreed > Termination: ALGO
              => < ID1 : SU | fmistate : Unloaded > Termination: (ALGO ; (fmiEvent: Unload SU: ID1)) .

  *** Error handling in Maude

  *** Simulation Procedure
  *** Perform the global simulation step
  *** Set input                     
  ceq performGlobalStep(CONF < ID1 : SU | time : SUTIME, inputs : (< INPUT : Input | > INPUTS) > 
                        Algorithm: ALGO valuesToSet: (((ID1 ! INPUT) |-> < TIME ; VALUE >) , PORTVALUES)) = 
      performGlobalStep(CONF SUINSTANCE Algorithm: (ALGO ; EVENT) valuesToSet: PORTVALUES)
                        if SUINSTANCE := < ID1 : SU | inputs : (< INPUT : Input | value : VALUE > INPUTS) >
                        /\ EVENT := portEvent: Set SU: ID1 PId: INPUT .
  *** Step
  ceq performGlobalStep(CONF < ID1 : SU | time : TIME, inputs : INPUTS, outputs : OUTPUTS > actualStepSize: STEPSIZE endTime: ENDTIME Algorithm: ALGO)  = 
      performGlobalStep(CONF SUINSTANCE actualStepSize: STEPSIZE endTime: ENDTIME Algorithm: (ALGO ; EVENT))
                        if FUTURETIME := TIME + STEPSIZE 
                        /\ canStep(TIME, FUTURETIME, INPUTS, OUTPUTS) and FUTURETIME <= ENDTIME 
                        /\ SUINSTANCE := stepAction(< ID1 : SU | >, STEPSIZE)
                        /\ EVENT := stepEvent: ID1 StepSize: STEPSIZE . 

  *** Get
  ceq performGlobalStep(CONF < ID1 : SU | outputs : (< OUTPUT : Output | time : TIME, status : Undef, value : VALUE, dependsOn : FEEDTHROUGH > OUTPUTS), inputs : INPUTS >  Algorithm: ALGO valuesToSet: PORTVALUES
                                    (ID1 ! OUTPUT ==> ID2 ! INPUT)) =
                      performGlobalStep(CONF SUINSTANCE Algorithm: (ALGO ; EVENT) 
                      valuesToSet: insert((ID2 ! INPUT), < TIME ; VALUE >, PORTVALUES))
                      if SUINSTANCE := getAction(< ID1 : SU | >, OUTPUT)
                      /\ EVENT := portEvent: Get SU: ID1 PId: OUTPUT . 
                      
  
  *** Algebraic Loop - solve and remove loop
  eq performGlobalStep(CONF UnsolvedSCC: (LOOP , LOOPS) SolvedSCC: SOLVEDLOOPS) = 
    performGlobalStep(solveLoop(CONF UnsolvedSCC: LOOPS SolvedSCC: (LOOP , SOLVEDLOOPS), LOOP)) [owise] .

  *** Return the configuration is the simulation is done
  ceq performGlobalStep(CONF) = CONF if simulationStepDone(CONF) .

  *** Initialization Procedure 
  
  crl [get-init] :
              < ID1 : SU | fmistate : Initialize, 
                outputs : (< OUTPUT : Output | status : Undef, value : VALUE, dependsOn : FEEDTHROUGH > OUTPUTS), 
                      inputs : INPUTS > 
                      (ID1 ! OUTPUT ==> ID2 ! INPUT)
                      Initialization: ALGO valuesToSet: PORTVALUES CONF
                  => SUINSTANCE Initialization: (ALGO ; EVENT) 
                      (ID1 ! OUTPUT ==> ID2 ! INPUT)
                      valuesToSet: insert((ID2 ! INPUT), < 0 ; VALUE >, PORTVALUES) CONF
                if SUINSTANCE := < ID1 : SU | outputs : (< OUTPUT : Output | status : Def > OUTPUTS) > 
                  /\ feedthroughSatisfied(FEEDTHROUGH, INPUTS, 0)
                  /\ EVENT := portEvent: Get SU: ID1 PId: OUTPUT . 


   *** Inputs can only rely on one connection 
  crl [set-init] : < ID1 : SU | inputs : (< INPUT : Input | status : Undef > INPUTS), fmistate : Initialize > 
          Initialization: ALGO CONF 
          valuesToSet: (((ID1 ! INPUT) |-> < TIME ; VALUE >), PORTVALUES)
              => SUINSTANCE Initialization: (ALGO ; EVENT) valuesToSet: PORTVALUES CONF
                      if SUINSTANCE := < ID1 : SU | inputs : (< INPUT : Input | status : Def, value : VALUE > INPUTS ) >
                      /\ EVENT := portEvent: Set SU: ID1 PId: INPUT .

  ***rl [init-loop] : CONF UnsolvedSCC: (L ;; LOOPS) => solveLoop(CONF UnsolvedSCC: LOOPS, L) .                 

  ***If the scenario contains SUs that require step negotiation
  ***The step negotiation
  crl [stepNego] : { CONF SNSet: SUIDsNE } => 
          { performStepNegotiation(CONF SNSet: SUIDsNE)}
          if allSUinSimulation(CONF) .


  crl [simulationStep]: { CONF } => 
          { performGlobalStep(CONF) }
        if allSUinSimulation(CONF) .

endom)

eof

(show all .)
q 

( frew [100] setup . )

(search setup. )

(search in COSIMULATION : setup =>1 C:Configuration . )

show search graph .

(red validScenario(externalConnection, simulationUnits) . )

( red allSUinSimulation(setup) . )

( red breakLoop(('msd1 ! 'x1) ;; ('msd2 ! 'x1) ;; ('msd2 ! 'v1) ;; ('msd1 ! 'v1), (simulationUnits externalConnection actualStepSize: 1 endTime: 1 Algorithm: emptyList SNSet: empty guessOn: emptyLoop) , R) . )

( red findStep(setup,setup) . )
( red getAllPorts(simulationUnits, empty) . )

set trace on .
trace exclude FULL-MAUDE . set trace substitution off . set trace eq off . 