\section{Preliminaries}\label{sc:background}
\subsection{Maude /Rewriting Logic}
\simon{Peter, I guess you have some text for this section.}

\subsubsection{Model checking}
\simon{Is this section needed?}


\subsection{Co-simulation}
Co-simulation enables global simulation of a system consisting of multiple black-box SUs. 
An SU has a dedicated solver calculating the behaviour trace of the dynamical system it represents. 
A dynamical system represents a function from time and space into some often multi-dimensional and continuous space. 
Examples include population growth, water flow, and pendulums. 
Interaction of the system with the external environment happens through inputs and outputs~\cite{Gomes2019a,Kubler2000}.

SUs are coupled through their inputs and outputs.
A coupling indicates that the state of one SU is reliant on the state of another SU.
A coupling can be seen as an invariant saying that the value on a coupled input and output must be identical at all times - known as a coupling restriction. 
However, in practice, the coupling restrictions can only be satisfied at specific points in time, referred to as communication points. 
Therefore, each SU makes assumptions about the evolution of the input values between the communication points to satisfy the invariant.
These assumptions cause accumulable errors in the co-simulation~\cite{Arnold2014}.

The orchestrator computes the behavioural trace of all SUs trying to satisfy their coupling restrictions by exchanging values. 
The orchestrator aims to find the communication points minimizing the co-simulation error while ensuring that the SUs move in lockstep. 
Studies \cite{Gomes2019,Oakes2021,Gomes2018f,Schweizer2015c,Gomes2018a} show that optimal communication points depend on the implementation of the SUs.

We now introduce our definition of an SU in \cref{def:fmu}.
It is based on \cite{Broman2013,Gomes2019c,thrane2021} and represents an abstract version of an SU.

\begin{definition}[Simulation Unit]\label{def:fmu}
  An SU with identifier $c$ is represented by the tuple
  $$\tuple{\stateset{c}, \inputs{c}, \outputs{c}, \fset{c}, \fget{c}, \fdoStep{c}},$$
  where:
  \begin{compactitem}
    \item $\stateset{c}$ represents the state space.
    \item $\inputs{c}$ and $\outputs{c}$ the set of input and output variables, respectively.
    The union of the inputs and outputs is called the variables of the SU:
    $\variables{c} = \inputs{c} \cup \outputs{c}$ 
    \item $\values$ is the set of values that a variable can hold and let $\valuesExchanged : \timebase \times \values$ be the set of abstract values exchanged between input and output variables.
    The functions
    $\fset{c} : \stateset{c} \times \inputs{c} \times \valuesExchanged \to \stateset{c}$ and $\fget{c}: \stateset{c} \times \outputs{c} \to \valuesExchanged$ respectively sets an inputs and gets an outputs. 
    \item $\fdoStep{c}: \stateset{c} \times \stepbase \to \stateset{c} \times \stepbase $ is a function that instructs the SU to compute its state after a given time duration. If an SU is in state $\stateafter{c}{t}$ at time $t$, $(\stateafter{c}{t+h}, h) = \fdoStep{c}(\stateafter{c}{t}, H)$ approximates the state $\stateafter{c}{t+h}$ of the corresponding model at time $t+h$, where $h \leq H$. 
  \end{compactitem}
\end{definition}

The state of SU $A$ at time $t$ is denoted $\stateafter{A}{t}$.
The function $\fdoStep{c}$ returns a step size because some SUs implement error estimation and may conclude that taking a step size of $H$ will result in an intolerable error meaning the SU takes a smaller step than planned.

A collection of coupled SUs forms a scenario.
We provide a formal description of a scenario in \cref{def:cosim_scenario}.

\begin{definition}[Scenario]\label{def:cosim_scenario}
  A scenario is a structure $\tuple{\fmus, \coupling, \mayReject, \allfeedthroughs, \allreactivity, \alldelayed}$ where 
  \begin{compactitem}
    \item Each identifier $c \in \fmus$ is associated with an SU, as defined in \cref{def:fmu}
    \item $\coupling(u)=y$ means that the output $y$ is connected to input $u$.   
    Let $\allinputs = \bigcup_{c \in \fmus} \inputs{c}$ and $\alloutputs = \bigcup_{c \in \fmus} \outputs{c}$, then $\coupling : \allinputs \to \alloutputs$. 
    \item $\mayReject \subseteq \fmus$ denotes the SUs that implement error estimation. 
    \item The function
    $\allreactivity : \allinputs \to \mathbb{B}$ is total and provide non-confidential information about the SUs' input approximation functions.
    $\allreactivity(\inputvar{c}) = \true$ means that the function $\fdoStep{c}$ assumes that the timestamp $t_{SU}$ of the state of SU $c$ ($\stateafter{c}{t_{SU}}$) is less than the timestamp $t_v$ of the value $v = \tuple{t_V,\dontcare}$ set on the input $\inputvar{c}$.
    \item  Finally, the set of feed-through components, $\allfeedthroughs = \bigcup_{c \in \fmus} \feedthrough{c}$, where the input $\inputvar{c} \in \inputs{c}$ feeds through to output $\outputvar{c} \in \outputs{c}$, that is, $(\inputvar{c},\outputvar{c}) \in \feedthrough{c}$, when there exists $v_1, v_2 \in \valuesExchanged$ and $\state{c} \in \stateset{c}$, such that
    $\fget{c} (\fset{c}(\state{c}, \inputvar{c}, v_1), \outputvar{c}) \neq \fget{c} (\fset{c}(\state{c}, \inputvar{c}, v_2), \outputvar{c}).$
  \end{compactitem}
\end{definition}

We have based \cref{def:cosim_scenario} on the FMI standard. 
However, feed-through and reactivity are extensions of the standard, introduced to cover a broad class of simulation scenarios.

\subsubsection{Instrumentation}
We refer to an input variable $\inputvar{c} \in \allinputs \land \neg \allreactivity(\inputvar{c})$ as a delayed input. 
While an input variable $\inputvar{c}$ where $\inputvar{c} \in \allinputs \land \allreactivity(\inputvar{c})$ is referred to as a reactive input. 

We describe the 

\subsection{Co-simulation algorithms}\label{sc:cosimalgo}
The orchestrator runs the co-simulation by interpreting/executing a co-simulation algorithm.

A co-simulation algorithm consists of an initialization procedure, a co-simulation step, and some additional FMI functions changing the mode of an SU.
Our work concentrates in the paper on the co-simulation step, which we refer to as the algorithm throughout the paper. 
The reason for this is that the other aspects of a co-simulation algorithm can be derived from the presented method.  

The co-simulation step is responsible for advancing all SUs $\fmus$, and all inputs and outputs $(\allinputs \cup \alloutputs)$, from the initial times $t$ to a future time $t+H, \textrm{ where } H > 0$.

The purpose of the co-simulation step $P$ is defined using the Hoare-triple in.

\begin{align*}
a
\end{align*}

A co-simulation step $P$ is a sequence of instructions of the SU's functions $\fset{c},\fget{c}$, and $\fdoStep{c}$. 
Each index $i$ of the sequence $P[i]$ represents an action in the algorithm, for example, if $P$ is the co-simulation step in \cref{alg:algorithm_1} $P[0] = \fdoStep{A}(\stateafter{A}{0}, \dontcare)$. \Cref{fig:algorithms} shows three different co-simulation steps of the scenario in \cref{fig:simpleexample}. 

\begin{figure}[htb]
  \centering
  \begin{minipage}[t]{.325\textwidth}
    \begin{algorithm}[H]
      \caption{}
      \label{alg:algorithm_1}
      \begin{algorithmic}[1]
        \scriptsize
        \State $(\stateafter{A}{H},H) \gets \fdoStep{A}(\stateafter{A}{0}, H)$
        \State $(\stateafter{B}{H},H) \gets \fdoStep{B}(\stateafter{B}{0}, H)$
        \State $f_{v} \gets \fget{A}(\stateafter{A}{H}, \outputvar{f})$
        \State $g_{v} \gets \fget{B}(\stateafter{B}{H}, \outputvar{g})$
        \State $\stateafter{B}{H} \gets \fset{B}(\stateafter{B}{s}, \inputvar{f}, f_{v})$
        \State $\stateafter{A}{H} \gets \fset{A}(\stateafter{A}{H},\inputvar{g},g_{v})$
      \end{algorithmic}
    \end{algorithm}
  \end{minipage}
  \begin{minipage}[t]{0.325\textwidth}
    \begin{algorithm}[H]
      \caption{}
      \label{alg:algorithm_2}
      \begin{algorithmic}[1]
        \scriptsize
        \State $(\stateafter{B}{H},H) \gets \fdoStep{B}(\stateafter{B}{0}, H)$
        \State $(\stateafter{A}{H},H) \gets \fdoStep{A}(\stateafter{A}{0}, H)$
        \State $g_v \gets \fget{B}(\stateafter{B}{H}, \outputvar{g})$
        \State $\stateafter{A}{H} \gets \fset{A}(\stateafter{A}{H}, \inputvar{g}, g_v)$
        \State $f_v \gets \fget{A}(\stateafter{A}{H}, \outputvar{f})$
        \State $\stateafter{B}{H} \gets \fset{B}(\stateafter{B}{H}, \inputvar{f}, f_v)$
      \end{algorithmic}
    \end{algorithm}
  \end{minipage}
  \begin{minipage}[t]{0.325\textwidth}
    \begin{algorithm}[H]
      \caption{}
      \label{alg:algorithm_3}
      \begin{algorithmic}[1]
        \scriptsize
        \State $(\stateafter{B}{H},H) \gets \fdoStep{B}(\stateafter{B}{0}, H)$
        \State $g_v \gets \fget{B}(\stateafter{B}{H}, \outputvar{g})$
        \State $\stateafter{A}{0} \gets \fset{A}(\stateafter{A}{0}, \inputvar{g}, g_v)$
        \State $f_v \gets \fget{A}(\stateafter{A}{0}, \outputvar{f})$
        \State $\stateafter{B}{H} \gets \fset{B}(\stateafter{B}{H}, \inputvar{f}, f_v)$
        \State $(\stateafter{A}{H},H) \gets \fdoStep{A}(\stateafter{A}{0}, H)$
      \end{algorithmic}
    \end{algorithm}
    \vspace{4pt}
  \end{minipage}
  \caption{Three algorithms conforming to the FMI Standard (version 2.0) of the scenario in \cref{fig:simpleexample}.}
  \label{fig:algorithms}
\end{figure}

Although the three algorithms in \cref{fig:algorithms} consist of the same actions, they are not equivalent, and simulating with one algorithm instead of one of the others could drastically change the co-simulation result as shown in \cite{Gomes2019c}. 
They showed that the scenario would be simulated correctly by obeying the contracts. 
We assume that the contracts in the scenario are constant through the simulation, which is the case for most commercially used SUs.
At the end of \cref{sec:correctcosim}, we show which of these algorithms is correct.

A co-simulation step $P$ is executed using a valuation $c$. The valuation $v \triangleq \tuple{H, guess}$ consists of the parameters of the co-simulation step $P$.  $H \in \stepbase$ defines the step size, and $guess : \inputs{algebraic} \to \valuesExchanged$ is a total function linking all inputs in $\inputs{algebraic}$ to a guess that tries to satisfy the algebraic loops. Using the example from \cref{alg:algorithm_1}, the action at index 0 in $P$ applied with the valuation $\tuple{1,\dontcare}$ is: $P[0](c) = \fdoStep{A}(\stateafter{A}{0}, 1)$. The valuation defines the step size $(1)$ of the step-action. 

The set $\valuation$ denotes all the possible configurations of the co-simulation step for a given scenario. The execution of a co-simulation step $P$ is the execution of each action in $P$. We define such execution of $P$ using valuation $c$ as:
\begin{align}
  P(c) \triangleq \text{for each } i \in \dom{P} \ldotp P[i](c)
\end{align}
An execution of $P(c_j)$ yields another valuation $c_{j+1} \in \valuation$ where $P(c_j) = c_{j+1}$. The valuation $c_{j+1}: \tuple{H_1, guess_1}$ is obtained from the algorithm $P$ and valuation $c_j: \tuple{H, guess}$ by updating $H_1$ to the smallest step accepted by an SU during the execution of $P(c_j)$. And the function $guess_1$ has the same domain as $guess$, but the range is updated to the new value of the output coupled to the associated input in the domain of $guess$ after executing $P(c_j)$.
\vspace{-1em}
\begin{align}
  guess_{j+1}(u) = value(u,P(c_j)) \text{ and } H_1 = minStep(P(c_j))  
\end{align}  
The execution of a valuation $v: \tuple{H, guess}$ has converged if all SUs accept the step $H$, and all algebraic loops are stabilized (all values in the range of $guess$ are fixed-points). 
The domain of $guess$ is all the inputs in $\inputs{algebraic}$ for the scenario; this means that all configurations of the same scenario have the same domain.
\begin{definition}\label{def:convergent}
  Two configurations of the same scenario S $c_j:\tuple{H_1,guess_1} \in \valuation$ and $c_{j+1}: \tuple{H_2, guess_2} \in \valuation$ are convergent if:
  \begin{align*}
    c_j \approx c_{j+1} \triangleq H_1 = H_2 \land (\forall i \in \dom{guess} \ldotp guess_1[i] \approx guess_2[i])
  \end{align*}
  Two values $v1_E: (v_1, t_1)$ and $v2_E: (v_2, t_2)$ of type $\valuesExchanged$ converge if:
  \begin{align}
    v1_E \approx v2_E \triangleq \, \mid v_1 - v_2 \mid \ \leq \epsilon \land t_1 = t_2
  \end{align}
\end{definition}

Formally an execution of a co-simulation step $P$ of a valuation $c_j$ is stable or has converged if $P(c_j) = c_{j+1} \implies c_j \approx c_{j+1}$.

A complex scenario is a scenario where not all configurations are stable. Such a scenario can only be correctly simulated by an algorithm $P$ if a convergent valuation exists:

\begin{align}
  \exists c \in \valuation, \exists j \in \setnat \ldotp P(c_{j}) = c_{j+1} \implies c_{j} \approx c_{j+1}
\end{align}

Some measures should be taken to handle cases where no convergent valuation exists.

\subsection{Correct Co-simulation Algorithms}\label{sec:correctcosim}
To optimally simulate a co-simulation scenario using an algorithm $P$ requires more than a convergent valuation $c$. The algorithm $P$ should also successfully satisfy all the preconditions/contracts. To describe this, we introduce the sequence $\allcontracts$, which is a permutation of the set $\precondition$ (cf.\ \cref{def:precondition}).
The sequence $\allcontracts$ is constructed by a function $\allcontracts = \mathit{contracts(P, \precondition)}$ that for each action in $P$ finds the corresponding precondition $pre \in \precondition$ and adds it to $\allcontracts$ such that for an arbitrary index $i$ in $P$, $\allcontracts[i]$ is the precondition of the action $P[i]$.

If an action at index $i$ in $P$ satisfies its precondition $\allcontracts[i]$ using the valuation $c$, it is denoted as:
\begin{align}
  P[i](c) \models \allcontracts[i]
\end{align}
A co-simulation step $P$ using a valuation $c$ satisfies $\allcontracts$ if all actions satisfy its precondition. 
\begin{align}
  P(c) \models \allcontracts \triangleq \forall i \in \dom{P} \ldotp P[i](c) \models \allcontracts[i]
\end{align}
$P(c) \models \allcontracts$ means the algorithm respects the scenario's contracts.
Based on previous studies it is well-known that a non-convergent valuation $c$ does not respect all the contracts:
\begin{align}\label{eq:incorrectConf}
  c_j \not\approx c_{j+1} \implies P(c_j) \not\models \allcontracts
\end{align}
Therefore we only check the contracts of the scenario if the current valuation is convergent.
We can now describe what it means for an algorithm to be correct for a given scenario in the following Hoare triple.

\begin{definition}\label{def:correctalgo}
  An algorithm $P$ and valuation $c: \tuple{H, \dontcare}$ is correct if:
  \begin{align*}
     P(c) \models \allcontracts \quad \land \quad
     &\{\forall v \in \allinputs \cup \alloutputs \ldotp v = \tuple{t, \dontcare} \land \forall c \in \fmus \ldotp \ftime(\stateafter{c}{t}) = t\} \quad P(c) \\
     & \{\forall v \in \allinputs \cup \alloutputs \ldotp v = \tuple{t+H, \dontcare} \land \forall c \in \fmus \ldotp \ftime(\stateafter{c}{t+H}) = t+H \}
  \end{align*}
  Meaning all preconditions are satisfied and all SUs and inputs have moved from time $t$ to time $t+H$ through the execution of $P(c)$.
\end{definition}

Using \cref{def:correctalgo} we conclude that \cref{alg:algorithm_3} is correct while the others are incorrect since they break one or more of the defined preconditions. \Cref{alg:algorithm_1,alg:algorithm_2} violate the precondition of $\fdoStep{b}$ on line 2 by stepping it without having provided SU $b$ with a value on the reactive input $f$. 
These definitions form the basis for describing the approach and implementation used to verify co-simulation algorithms in this work.


\subsubsection{Design Space Exploration}
Design space exploration evaluates how different combinations of parameters (designs) affect the system's performance to determine which parameter combinations are 'optimal'.
The process can be roughly divided into the search and the design evaluation.
