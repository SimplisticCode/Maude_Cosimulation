% \section{Introduction}\label{sc:introduction}
% \begin{itemize}
%     \item Motivation for co-simulation
%     \begin{itemize}
%       \item Industry 4.0
%       \item Development of CPS
%       \item The result of co-simulation
%       \begin{itemize}
%       \item How to test and verify an OA - need for correct by construction algorithm
%       \item Design Space Exploration of the system - model checking 
%       \item Testing the configurations of the systems - model checking the contracts.
%       \item Dynamic observation of the system
%       \item Satisfying the contracts
%       \item Checking safety properties (possible to reach a bad state). - model checking might be needed because although each SU might have deterministic behavior, we might not know this - we have to consider a range of possible behaviors.
%       \item General problem with writing sound SU.
%       \item Time 
%     \end{itemize}
%     \end{itemize}
%     \item Background
%     \begin{itemize}
%       \item Rewriting Logic
%       \item Co-simulation
%     \end{itemize}
%     \item The Maude model
%     \item Analyses
%     \begin{itemize}
%       \item Confluent and deterministic algorithm
%       \item Verification of Algorithms
%       \item Design Space Exploration
%       \item Step negotiation (Non-deterministic behavior)
%       \item Contracts
%       \item Interaction with real-world SUs
%     \end{itemize}
%   \end{itemize}
  
%   Need for formal methods:
%   \begin{itemize}
%     \item Desireable to do model checking as run-time verification during the simulation.
%     \item Communication to external objects - continuous Interaction between formal tool.
%     \item Step negotiation
%     \item Fixed-point iteration (Algebraic loop)
%     \item Complex functions - Tarjan, fixed-point iteration.
%   \end{itemize}
  

  
%   Use of Maude:
%   \begin{itemize}
%     \item Addresses the challenges:
%     \item Non-distributed components
%     \item Supports functions and is very compressive
%     \item Supports model-checking - lets the user explore all different initialization of all the simulation units
%     \item Model checking allows one to explore that the SU does not reach a bad state
%     \item Most importantly, Maude supports communication with external objects so, in each simulation iteration, we can check and verify (model check) the algorithm used to simulate the next system step.
%   \end{itemize}
  
%   In this paper, we present a co-simulation Synthesizing engine and a Framework for performing various analyses in Maude of both the algorithm and the system of interest.
%   \begin{itemize}
%     \item Model checking approach is used to explore the system's instrumentation's design space - check all possible contracts to reach the best possible simulation result.
%     \item Given a state of the co-simulation system, we synthesize all correct orchestration (one of the algorithms might actually be better than another) for the next step of the co-simulation algorithm.
%     \item Model checking is used to show that all synthesized algorithms lead to a  
%     \item By defining abstract models of the system in Maude, we can perform model checking to explore violations of safety properties - to 
%     \item We then show have this framework can be used to run a co-simulation - to let Maude use as the orchestration engine.
%   \end{itemize}
  
%   We illustrate our techniques with some examples.
  
%   Related work
%   \begin{itemize}
%     \item Not a lot of formal methods on co-simulation
%     \begin{itemize}
%       \item All do work on a symbolic version of the simulation units
%       \item Generate only one algorithm
%     \end{itemize}
%   \end{itemize}

% Motivation for co-simulation
A CPS embodies physical processes controlled by digital devices.
CPSs are omnipresent and control more and more critical functions in our daily life.
Such systems are becoming increasingly complex~\cite{4519604}, which leads to the desire for techniques to assist in the development of dependable CPS.
Traditional modelling and simulation techniques, where a solver algorithm describes a model, are no longer sufficient to cope with the integrated development processes of a heterogeneous system such as a CPS~\cite{FMI2014}.
A CPS is typically developed in a distributed fashion using different tools and techniques. 
% Why and what is co-simulation
Co-simulation allows distributed development and is a promising solution to complex development processes.
Co-simulation allows iterative integration of constituents to explore the global system behavior without violating the constituents' Intellectual Property. 
Co-simulation is the study of how to coordinate multiple black-box simulation units (SUs) developed using different tools and formalisms.
An SU represents a sub-system and is responsible for calculating the sub-system's behavioral trace.
The co-simulation combines all the SU's behavioral traces to produce the global behavior of the system as a discrete trace (see, e.g., \cite{Kubler2000,Gomes2018}).

The SUs are coupled by an orchestration algorithm that interacts with each SU via its interface.
An example of such an SU is a Functional Mock-up Unit (FMU) defined by the Functional Mock-up Interface Standard~\cite{FMI2014} (FMI), which inspires the notion of an SU in this paper. FMI is a widely adopted standard used commercially and supported by many tools~\cite{Tools_FMI}.

%How to test and verify an OA - need for correct by construction algorithm
The challenge of co-simulation is ensuring trustworthy simulation results~\cite{Gomes2018}. 
A trustworthy result requires, among others, an implementation-aware orchestration algorithm~\cite{Gomes2019,Oakes2021,Gomes2018f,Schweizer2015c,hansen_verification_2021}.
The algorithm must respect the SUs' input approximation functions.

Not considering such details can lead to inaccurate co-simulation results.
The nature of co-simulation allows iterative cooperation. 
However, it also makes it extremely difficult to debug and find the cause of an inaccurate co-simulation result.
This problem was partly in \cite{Gomes2019,Oakes2021}.
They showed how to construct requirements on how the orchestrator can interact with the SUs during a simulation. 
Respecting the requirements leads to a substantial reduction of the co-simulation error.

An even more challenging class of scenarios to simulate is complex scenarios.
They are subject to either algebraic loops or step rejections. 
Complex scenarios are simulated using an iterative algorithm that adapts to the behavior of the SUs~\cite{thrane2021}. 
This enables the orchestrator to solve the algebraic loop (cyclic dependencies between the SUs) and to ensure that all SUs agree on a step; the latter is called step negotiation. 
Step negotiation is a technique for simulating scenarios with SUs refusing specific future state evaluations because they implement error estimation.
Step negotiation minimizes the simulation error while ensuring that the SUs move in lockstep.

We propose a model checking approach using rewriting logic in Maude that
allows a co-simulation practitioner to synthesize and verify co-simulation algorithms of simple and complex scenarios.
Furthermore, the approach enables various analyses such as design space exploration of the orchestration, scenario and co-simulation.
The design space exploration lets a co-simulation practitioner explore the consequences of changing the contracts and simulation parameters.
Moreover, the co-simulation practitioner can use their domain knowledge and, in Maude, place constraints on the co-simulation to let Maude find the parameters that lead to simulation with specific desirable properties. 

\textit{Contribution:}
% \begin{itemize}
%   \item Address the problems - obtaining good co-simulation algorithm
%   \item Perform co-simulation in Maude
%   \item Step negotiation
%   \item Fixed-point iteration (Algebraic loop)
%   \item Complex functions - Tarjan, fixed-point iteration.
% \end{itemize}
This paper describes an executable Maude formalization for synthesizing, verifying and executing co-simulation algorithms.
The formalization can be used to explore the co-simulation algorithm effect on the co-simulation result.
The approach covers complex scenarios subject to algebraic loops and adaptive steps.
Furthermore, the formalization enables multiple analyses of the generated algorithm and the system of interest, including various kinds of design space exploration using model checking. 

\textit{Structure:}
The paper starts with introducing rewriting logic, co-simulation and the verification challenge of co-simulation algorithms in \cref{sc:background}. 
%Then, \Cref{sc:related} describes other approaches for obtaining reliable and deterministic co-simulation results. 
Finally, \cref{sc:summary} concludes and present future work.