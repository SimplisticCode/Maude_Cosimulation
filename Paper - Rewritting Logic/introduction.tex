% Motivation for co-simulation
Cyber-physical systems (CPSs) are omnipresent and part of the critical infrastructure of the modern society.
A CPS is a hybrid system that embodies physical processes controlled by digital devices. Examples include everything from a controller opening and closing a valve to regulate the water level of a tank to autonomous vehicle.
CPSs are due to technical advancements becoming increasingly complex~\cite{4519604}, which leads to the desire for techniques to assist in the development of dependable CPS.
Traditional modeling and simulation techniques, where a solver algorithm describes a model, are no longer sufficient to cope with the integrated development processes of such systems~\cite{FMI2014}, which consists of heterogenous subsystems typically using different tools and techniques~\cite{Monti_2021}. 

% Why and what is co-simulation
Co-simulation solves the shortcomings of the traditional modeling techniques by letting the user operate in an environment where the subsystems can be integrated to explore the global system behavior without violating the constituents' Intellectual Property\cite{Gomes2018}. 
Co-simulation is the study of how to coordinate multiple black-box simulation units (SUs) developed using different tools and formalisms.
An SU represents a subsystem by calculating its behavioral trace using a dedicated solver.
The co-simulation combines the SUs in a scenario to produce their global behavior as a discrete trace (see, e.g., \cite{Kubler2000}).

Multiple SUs are composed using an orchestration algorithm that interacts with each SU via its interface.
An example of such an SU is a Functional Mock-up Unit (FMU) defined by the Functional Mock-up Interface Standard~\cite{FMI2014} (FMI), which inspires the notion of an SU in this paper. 
FMI is a widely adopted standard used commercially and supported by many tools~\cite{Tools_FMI}.

%How to test and verify an OA - need for correct by construction algorithm
The overarching challenge of co-simulation is ensuring accurate simulation results due to the many potential error sources of such a simulation~\cite{Gomes2018}.
The simulation result depends not only on the SUs but also on the co-simulation algorithm that composes them in simulation, which is often overlooked~\cite{Gomes2019,Oakes2021,Gomes2018f,Schweizer2015c,hansen_verification_2021}.
The co-simulation algorithm must specifically tailored to scenario that is respect the SUs' input approximation functions.

Not considering such details can lead to inaccurate co-simulation results, something that can be extremely difficult to debug and fix in practice.
The papers \cite{Gomes2019,Oakes2021,thrane2021} describe how to synthesize tailored co-simulation algorithms to substantial reduce the co-simulation error. by using contracts to define the .

Co-simulation creates an environment where different system designs can be explored to find the optimal design~\cite{dse,gamble_design_2014}; the process is called design space exploration.

We propose a framework in Maude where a co-simulation practitioner can synthesize and execute tailored co-simulation algorithms while exploring different system designs.
The approach works for both simple and complex scenarios.
Complex scenarios are subject to algebraic loops denoting cyclic dependencies between the SUs or step rejections, where an  SU refuses specific future state evaluations because it implements error estimation.
Complex scenarios are, in general, more challenging to simulate since the co-simulation algorithm needs to adapt to the behavior of the SUs~\cite{thrane2021} to solve the algebraic loop and ensure that all SUs move in lockstep; the latter is called step negotiation. 

The approach enables design space exploration of the co-simulation algorithm and the system's design.
It lets a co-simulation practitioner explore the consequences of changing the contracts and simulation parameters.
Moreover, the co-simulation practitioner can use their domain knowledge and, in Maude, place constraints on the co-simulation to let Maude find the parameters and contracts that result in a co-simulation with specific desirable properties. 

\paragraph{Contribution:}
% \begin{itemize}
%   \item Address the problems - obtaining good co-simulation algorithm
%   \item Perform co-simulation in Maude
%   \item Step negotiation
%   \item Fixed-point iteration (Algebraic loop)
%   \item Complex functions - Tarjan, fixed-point iteration.
% \end{itemize}
This paper describes an executable Maude framework for synthesizing and executing co-simulation algorithms for a given co-simulation scenario.
The framework addresses both simple and complex scenario  exploration the co-simulation algorithm effect on the co-simulation result.
The approach covers complex scenarios subject to algebraic loops and adaptive steps.
Furthermore, the formalization enables multiple analyses of the generated algorithm and the system of interest, including various kinds of design space exploration using model checking. 

\paragraph{Structure:}
\cref{sc:background} introduces the preliminaries rewriting logic, co-simulation and design space exploration.
Then, \cref{sec:model} describes the Maude model, before \cref{sc:synthesize} describes how co-simulation algorithms are synthesized and executed in Maude.

Then, \cref{sc:related} describes other approaches for obtaining reliable and deterministic co-simulation results. 
Finally, \cref{sc:summary} concludes and present future work.