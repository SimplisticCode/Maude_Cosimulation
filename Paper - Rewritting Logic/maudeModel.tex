\section{Modeling Co-simulation Scenarios in Maude}
This section describes how we model the individual SUs and their composition in a co-simulation scenario.

Due to space limitations, we cannot describe the entire model. 
In some places, we have parts of Maude code with ``...'' to hide irrelevant code parts.
The entire model, including synthesis and execution of co-simulation algorithms described in \cref{sc:synthesize} and the synthesize of instrumentations and parameters in section \cref{sc:DSE} is at is available online \footnote{\simon{create link}} and consist of \simon{find out}.

We formalize the co-simulation in an object-oriented style.
Where the global state \textit{GlobalState} of the system is denoted by:
\begin{alltt}
\small
op `{_`} : Configuration -> GlobalState .
\end{alltt}

The \textit{GlobalState} consists of a collection of SUs composed into a scenario and its orchestrator.


The formalization is described using a running example of a water tank system.
The system is a controller-based system that controls the tank's water level with a permanent inflow of water by opening and closing a valve at the bottom of the tank.
The system can be modeled using two SUs, and the scenario can be described by \cref{fig:simpleexample}. 

\subsection{Simulation Units}
An SU is modelled as an object instance of the following class.% a subsystem with parameters, ports, a state, and a time:
\begin{alltt}
  \small
class SU |
time : Nat, inputs : Configuration, outputs : Configuration, canReject : Bool, 
fmistate : fmiState, parameters : LocalState, localState : LocalState .
\end{alltt}

The attribute \textit{time} denotes the time of the SU.
\textit{Inputs} and \textit{outputs} denote the SU's input and output ports.
The attribute \textit{canReject} declares if the SU implement error estimation and therefore is an element of the set $\mayReject$.
The attribute \textit{fmistate} denotes the simulation mode defined in \cite{FMI2014} of the SU.
The internal state $\state{}$ of the SU is denote by the attribute \textit{localState} and the attribute \textit{parameters} describes the configurable parts of the SU.

Input and output ports are instances of the following classes:
\begin{alltt}
\small
class Port | value : FMIValue, time : Nat, status : PortStatus, ``...''. 
class Input | contract : Contract .
class Output | dependsOn : OidSet .
\end{alltt}

The attributes \textit{value} and \textit{time} denote time and value of the port described by the functions: $\runstate{\inputs{}}$, $\runstate{\outputs{}}$, and $\runstate{V}$ from \cref{def:runtime_state}.
The attribute \textit{status} denote if the port has been updated or not at the current timestamp.
The attribute \textit{contract} of the input class describes the input's instrumentation/contract.
The attribute \textit{dependsOn} denotes the set of inputs that feed through to the output.

The \textit{tank} SU of the water tank example is modelled as:
\begin{alltt}
  \small
< "tank" : SU | parameters : ("flow" |-> < 5 >), localState : ( "waterlevel" |-> < 0 > ) , time : 0, 
inputs : (< "valveState" : Input | value : < 0 >, time : 0, contract : delayed >), outputs : (< "waterlevel" : Output | value : < 0 >, time : 0, status : Undef, dependsOn : empty >)
canReject : false >
\end{alltt}

The \textit{tank} has one delayed input and one output, and the local state says that the tank initially is empty. 
The parameter \textit{flow} defines how many liters of water that flow into the tank per time instance.

The behavior of an SU (the functions in \cref{def:fmu}) is described using equations.
For example, the $\fget{}$ operation that updates the state of a set of output ports:

\begin{alltt}
  \small
  op getAction : Object OidSet -> Object .
  eq getAction(< SU1 : SU | >, empty) = < SU1 : SU | > .
  eq getAction(< SU1 : SU | time : T, 
                            outputs : (< O : Output | > OS) >, (O , P)) = 
    getAction(< SU1 : SU | outputs : 
    (< O : Output | time : T, status : Def > OS) >, P) .
\end{alltt}

The operator iterates over a defined set of output ports.
The \textit{time} and \textit{state} of the output port is update to the time $T$ and the input is marked as defined \textit{Def}.

%The precondition ($\fpreget{}$) is omitted from the operation \emph{getAction} since it is included in the functions calling it.
%The functions $\fget{}$ and $\fset{}$ are similar for all SUs described in the framework.

One can describe the concrete behavior of an SU by defining its $\fdoStep{}$ function.
It is possible to define quite complex behaviors, as seen below, where we define how the water level of the tank changes according to step duration \textit{STEP}, the parameter \textit{flow}, and the state (\textit{value}) of the input \textit{valve}.

\begin{alltt}
  \small
eq step(< "tank" : SU | time : T, parameters : ("flow" |-> < FLOW >), 
                    inputs : < "valve" : Input | value : < STATE > >, 
                    outputs : < "waterlevel" : Output | time : T >,
                    localState : ( "waterlevel" |-> < LEVEL > ) >,
                    STEP) = 
if STATE == 1 then 
  < "tank" : SU | time:(T + STEP), localState : ( "waterlevel" |-> < 0 > ),
  outputs : < "waterlevel" : Output | value : < 0 >, 
  time : (T + STEP), status : Undef > >
  else 
  < "tank" : SU | time : (T + STEP), 
  localState : ( "waterlevel" |-> < LEVEL + (STEP * FLOW) > ), 
  outputs : < "waterlevel" : Output | value : < LEVEL + (STEP * FLOW) >, 
  time : (T + STEP), status : Undef > > 
fi .
\end{alltt}

A scenario is a collection of SUs composed using a set of couplings/connections.
An connection connects an output with an input:
\begin{alltt}
  \small
op _==>_ : EPortId EPortId -> Connection [ctor] .
subsort Connection < Configuration .
\end{alltt}

The SUs of the water tank example are defined as the following multiset:
\begin{alltt}
  \small
eq simulationUnits = 
< "tank" : SU | parameters : ("flow" |-> < 100 >),
 localState : ( "waterlevel" |-> < 0 > ) , time : 0, 
 inputs : (< "valveState" : Input | value : < 0 >, type : integer, time : 0, contract : delayed, status : Undef  >), 
 outputs : (< "waterlevel" : Output | value : < 0 >, type : integer, time : 0, status : Undef, dependsOn : empty >), 
 fmistate : Instantiated, canReject : false >

< "ctrl" : SU | parameters : (("high" |-> < 5 >) , ("low" |-> < 0 >)), 
localState : ( "valve" |-> < false > ), time : 0, 
inputs : (< "waterlevel" : Input | value : < 0 >, type : integer, time : 0, contract : reactive, status : Undef  >), 
outputs : (< "valveState" : Output | value : < 0 >, type : integer, time : 0, status : Undef, dependsOn : empty >), 
fmistate : Instantiated, canReject : false > .
\end{alltt}

The couplings of the system are the multiset of connections.
The couplings of the water tank example is shown below:
\begin{alltt}
  \small
eq externalConnection = ('tank ! 'waterlevel ==> 'ctrl ! 'waterlevel) 
  ('ctrl ! 'valveState ==> 'tank ! 'valveState)  .
\end{alltt}


A scenario is described as a multiset of SUs and connections linking the ports.
A simulation is instantiated as a \textit{GlobalState} using the equation:
\begin{alltt}
\small
op setup : -> GlobalState .
ceq setup = { CONF }
  if MODEL := scenario(externalConnection, simulationUnits)
  \(\land\) LOOPS := tarjan(MODEL)
  \(\land\) NeSUIDs := getSUIDsOfScenario(MODEL)
  \(\land\) CONF := calculateSNSet(MODEL OData(1,LOOPS, NeSUIDs)) .
\end{alltt}

The property \textit{simulationUnits} defines the SUs of the scenario as a multiset.
The couplings are described as a multiset denoted by \textit{externalConnection}.
The equation \textit{scenario} constructs a scenario and validates that all couplings of the system.
It ensures that all inputs are coupled and that no input has two sources.

The equation \textit{tarjan} checks for algebraic loops in the scenario by searching for non-trivial strongly connected components in the graph constructed by the rules described in \cite{Gomes2019c}.  
The equation \textit{getSUIDsOfScenario} gets the set identifiers represented in the scenario.
The last equation \textit{calculateSNSet} checks if step negotiation should be applied in the simulation of the scenario.

We can, from a scenario, synthesize its co-simulation algorithms and simulate it in Maude.
The orchestrator responsible for the synthesizing and simulation is described in the following section.  