
\section{Modeling Co-simulation Scenarios in Maude}
\label{sec:model}

This section describes how we model  individual SUs and their
composition in a co-simulation scenario in Maude.
%
Due to space limitations, we only provide fragments of our Maude
model. 
The entire model, including the synthesis and execution of co-simulation
algorithms (\Cref{sc:synthesize}) and the synthesis of
instrumentations and parameters (\Cref{sc:DSE})  is
available at
\url{https://github.com/SimplisticCode/Co-simulation_WRLA} and
consists of around  
1400 LOC. 

We formalize  co-simulation scenarios in an object-oriented style. The
 state is a term
 \texttt{\char123}$\mathit{SUs}\;\mathit{connections}\;\mathit{orchObjects}$\texttt{\char125}
 of sort \texttt{GlobalState}, 
 where $\mathit{SUs}$ is set of objects modeling simulation units,
$\mathit{connections}$ denote the port couplings, and
$\mathit{orchObjects}$ are two additional objects used
during synthesis and execution of co-simulation algorithms (see
\Cref{sc:synthesize}). 

% We illustrate our  framework using a system where a
% \emph{controller} 
% controls the water level of a \emph{water tank} with constant inflow
% of water,  by opening and closing a valve
% at the bottom of the tank. 
% The system can be modeled using  one SU for the tank and one for
% the controller, and has the architecture shown in
% \cref{fig:simpleexample}.

%\subsection{Simulation Units}
A simulation unit  is modeled as an object instance of the following
class: % a
                                % subsystem with parameters, ports, a
% state, and a time: 
\small
\begin{alltt}
class SU | time\,\,: Nat,                inputs\,\,: Configuration,
           outputs\,\,: Configuration,   canReject\,\,: Bool,
           fmistate\,\,: fmiState,       parameters\,\,: LocalState,
           localState\,\,: LocalState .
\end{alltt}
\normalsize

\noindent The attribute \texttt{time} denotes the time of the SU; 
\texttt{inputs} and \texttt{outputs} denote the objects modeling the
SU's input and output 
ports; \texttt{canReject}  is \texttt{true} if  the SU
implements error estimation (i.e., is an element of the set
$\mayReject$);  
\texttt{fmistate} denotes the \emph{simulation mode}
(see~\cite{FMI2014}) of the SU; \texttt{localState} denotes the SU's internal
state; and \texttt{parameters} denotes the values of the SU's
parameters. 

Input and output ports are modeled as  instances of the following
classes:

\small
\begin{alltt}
class Port | value\,:\,\,FMIValue,\,time\,:\,\,Nat,\,status\,:\,\,PortStatus,\,type\,:\,\,FMIType\,. 
class Input | contract : Contract .
class Output | dependsOn : OidSet .     
subclasses Input Output < Port .
\end{alltt}
\normalsize

\noindent % The attributes
\texttt{value} and \texttt{time} denote, respectively, the
value of the port and the time of its last set/get operation; 
\texttt{status} is \texttt{true}  if the port was
updated  at the current time;   \texttt{contract} denotes the
input port's instrumentation (\texttt{delayed} or
\texttt{reactive}); and 
\texttt{dependsOn} denotes the set of inputs that feed
through to the output port. 

\begin{example}
  We illustrate our  framework using a system where a
\emph{controller} 
controls the water level of a \emph{water tank} with constant inflow
of water,  by opening and closing a valve
at the bottom of the tank. 
The system can be modeled using  one SU for the tank and one SU for
the controller, and has the architecture shown in
\cref{fig:simpleexample}.
%
The water tank  (in its initial state)  is modeled as an object
  
\scriptsize
\begin{alltt}
< "tank" : SU | parameters : ("flow" |-> <\,5\,>),  localState : ("waterlevel" |-> <\,0\,>),
                inputs : (< "valveState" : Input |\,value\,\,:\,\,<\,0\,>, time\,\,:\,\,0,\,contract\,\,:\,\,delayed >),
                outputs : (< "waterlevel" : Output | value : <\,0\,>, time : 0,
                                                     status : Undef, dependsOn : empty >)
                time : 0,  canReject : false >
\end{alltt}
\normalsize

\noindent The \texttt{tank} has one delayed input port and one output
port, and the local state indicates that the tank is empty.  
The parameter \texttt{flow} denotes the amount of water that flows
into the tank per time unit.
\end{example}

To formalize the behaviors of an SU we formalize the operations
\texttt{set}, \texttt{get}, and \texttt{step} in
\cref{def:fmu}. 
For example, the $\fget{}$ operation that updates the \texttt{time}
and \texttt{status}  of a set
of output ports is formalized as follows:\footnote{We do not show
  variable declarations, but follow the convention that variables are
  written with capital letters.} 

\small
\begin{alltt}
  op getAction : Object OidSet -> Object .
  eq getAction(< SU1 : SU | >, empty) = < SU1 : SU | > .
  eq getAction(< SU1 : SU | time : T, 
                            outputs : (< O : Output | > OS) >, (O , P)) = 
     getAction(< SU1 : SU | outputs : 
                     (< O : Output | time : T, status : Def > OS) >, P) .
\end{alltt}
\normalsize

% The operator iterates over a defined set of output ports.
% The \textit{time} and \textit{state} of the output port is update to
% the time $T$ and the input is marked as defined \textit{Def}. 

%The precondition ($\fpreget{}$) is omitted from the operation
%\emph{getAction} since it is included in the functions calling it. 
%The functions $\fget{}$ and $\fset{}$ are similar for all SUs
%described in the framework. 

\noindent The application-specific behavior of an SU is given by
defining its $\fdoStep{}$ 
function:

\begin{example}
The following definition of the \texttt{step} function in our running
example  defines how the  water level of the tank changes as a
function of the 
step duration \texttt{STEP}, the parameter \texttt{flow}, and the
state (\texttt{value}) of the input \texttt{valve}:

\scriptsize
\begin{alltt}
eq step(< "tank" : SU | time : T, parameters : ("flow" |-> <\,FLOW\,>), 
                        inputs : < "valve" : Input | value : <\,STATE\,> >, 
                        outputs : < "waterlevel" : Output | time : T >,
                        localState : ("waterlevel" |-> <\,LEVEL\,>) >,
        STEP) = 
  if STATE == 1 then    \emph{--- valve is open}
    < "tank" : SU | time : (T\,+\,STEP), localState : (\emph{"waterlevel" |-> <\,0\,>}),
          outputs : < "waterlevel" : Output | value\,\,:\,\,<\,0\,>, time\,\,:\,\,(T\,+\,STEP), status\,\,:\,\,Undef > >
  else                  \emph{--- valve is closed}
    < "tank" : SU | time : (T\,+\,STEP),  localState : (\emph{"waterlevel" |-> <\,LEVEL\,+\,(STEP\,*\,FLOW})\,>), 
                    outputs : < "waterlevel" : Output | value : < LEVEL + (STEP * FLOW) >, 
                                                        time : (T + STEP), status : Undef > > 
  fi .
\end{alltt}
\normalsize
\end{example}

%A scenario is a collection of SUs composed using a set of couplings/connections.
A connection/coupling connecting the output port $o$ of SU $\mathit{su}_1$ to
the input port $i$ of SU $\mathit{su}_2$ is represented by the term
$\mathit{su}_1$ \texttt{!} $o$ \texttt{==>}
$\mathit{su}_2$ \texttt{!} $i$.   %  of a subsort
% \texttt{Connection} of sort \texttt{Configuration}.


% ports connects an output with an input:
% \begin{alltt}
%   \small
% op _==>_ : EPortId EPortId -> Connection [ctor] .
% subsort Connection < Configuration .
% \end{alltt}

We define scenarios by defining constants \texttt{simulationUnits}
and \texttt{externalConnection} that denote, resp.,  the
simulation unit objects and  their connections. 

\begin{example}\label{ex:simulationunits}
The SUs and their couplings in our  example are defined as
follows:

\scriptsize
\begin{alltt}
eq simulationUnits = 
   < "tank" : SU | parameters : ("flow" |-> <\,100\,>),  localState : ("waterlevel" |-> <\,0\,>),
                   time : 0,  fmistate : Instantiated, canReject : false, 
                   inputs : (< "valveState" : Input | value : <\,0\,>, type : integer, time : 0,
                                                      contract : delayed, status : Undef >), 
                   outputs : (< "waterlevel" : Output | value : <\,0\,>, type\,:\,integer, time\,:\,0,
                                                        status : Undef, dependsOn : empty >)\,>
   < "ctrl" : SU | parameters : (("high" |-> <\,5\,>) , ("low" |-> <\,0\,>)), canReject : false, 
                   localState : ("valve" |-> <\,false\,>), fmistate : Instantiated, time : 0, 
                   inputs : (< "waterlevel" : Input | value : <\,0\,>, type : integer, time : 0,
                                                      contract : reactive, status : Undef >), 
                   outputs : (< "valveState" : Output | value : <\,0\,>, type\,:\,integer, time\,:\,0,
                                                        status : Undef,\,dependsOn : empty\,>)\,>\,.

eq externalConnection = ("tank" ! "waterlevel" ==> "ctrl" ! "waterlevel") 
                        ("ctrl" ! "valveState" ==> "tank" ! "valveState") .
\end{alltt}
\normalsize
\end{example}

%A scenario is described as a multiset of SUs and connections linking the ports.
%A simulation is instantiated as a \textit{GlobalState} using the equation:
The constant \texttt{setup} defines the initial state, and adds
appropriate initialized orchestration objects to the scenario:

\small
\begin{alltt}
op setup : -> GlobalState .
ceq setup = \char123INIT\char125
  if SCENARIO := externalConnection simulationUnits
  /\char92 validScenario(SCENARIO)
  /\char92 LOOPS := tarjan(SCENARIO)
  /\char92 NeSUIDs := getSUIDsOfScenario(SCENARIO)
  /\char92 INIT := calculateSNSet(SCENARIO OData(1,LOOPS, NeSUIDs)) .
\end{alltt}
\normalsize

\noindent The function \texttt{validScenario} checks whether all inputs are coupled and that no input has two sources.   
The function \texttt{tarjan} returns (a possibly empty) set  of algebraic loops in the scenario by searching for non-trivial strongly connected components in
the graph constructed using the rules  in \cite{Gomes2019c}.   
The function \texttt{getSUIDsOfScenario} returns  the set of all SU
identifiers. Finally, \texttt{calculateSNSet} checks if step negotiation 
should be applied in the simulation of the scenario, and generates a
global initial state with orchestration objects that store information
about the discovered algebraic loops and whether step negotiation is
needed.