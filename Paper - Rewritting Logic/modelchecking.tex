\section{Synthesizing and Executing Co-simulation Algorithms}\label{sc:synthesize}
This section describes how to synthesize and execute co-simulation algorithms of a scenario in Maude.

\subsection{Orchestrator}
The orchestrator simulates the scenario by exchanging values between couplings and calculating new states for each of the SUs.

The simulation requires that the orchestrator keeps track of both the co-simulation algorithm and some extra data to keep track of the current execution of the algorithm to ensure that all SUs move in lockstep and that it solves all algebraic loops of the scenario.
The orchestrator is divided into the following two classes \texttt{SimData} and \texttt{AlgoData}:
\small
\begin{alltt}
class SimData | SNSet : OidSet,           defaultStepSize : NzNat,
          actualStepSize : NzNat,         unsolvedSCC : AlgebraicLoopSet, 
          solvedSCC : AlgebraicLoopSet,   guessOn : PortSet,
          values : PortValueMap,          simulationTime : Nat,
          suids : NeOidSet .
\end{alltt}
\normalfont
The class \texttt{SimData} denotes the bookkeeping that the orchestrator needs to do during the simulation.
The attribute \texttt{SNSet} denotes the set $\mayReject$; \texttt{defaultStepSize} is the default step duration of the simulation; while the attribute \texttt{actualStepSize} is the negotiated step duration.
\emph{Note} that \texttt{actualStepSize} and \texttt{defaultStepSize} always are equal if $\mayReject = \emptyset$.
The union of \texttt{unsolvedSCC} and \texttt{solvedSCC} denotes the algebraic loops of the scenario; the attributes respectively denote the solved and unsolved algebraic loops.
The attribute \texttt{guessOn} is a set of ports, it is used to solve algebraic loops using the reduction technique described in \cite{thrane2021}; \texttt{values} denotes a map linking an input port with a value. 
The orchestrator uses \texttt{values} to track which values it has obtained but not set on an input port. 
The attribute \texttt{simulationTime} describes the current global time of the simulation and \texttt{suids} denotes the identifiers of the SUs.
\small
\begin{alltt}
class AlgoData | CosimStep : ActionList,   Initialization : ActionList, 
                 Termination : ActionList, endTime : NzNat .
\end{alltt}
\normalsize
The class \texttt{AlgoData} describes the co-simulation algorithm.
The co-simulation algorithm is divided into three subsequent parts.
The attributes \texttt{Initialization} and \texttt{Termination} denote the initialization procedure and termination procedure, respectively.
The attribute \texttt{CosimStep} denotes the co-simulation step procedure that the orchestrator applies until it reaches the end time of the simulation denoted by the attribute \texttt{endTime}.
All elements of the algorithm are of the type \texttt{ActionList}.
The type \texttt{ActionList} denotes as a list of SU operations defined according to:
\small
\begin{alltt}
ops Set Get Step Save : -> ActionType [ctor] . 
op portEvent:_SU:_PId:_ : ActionType SUID OidSet -> Action [ctor] .
subsort Action < ActionList .
op emptyList : -> ActionList [ctor] .
op _;_ : ActionList ActionList -> ActionList [ctor assoc id: emptyList] .
\end{alltt}
\normalfont
We have omitted the actions to handle complex scenarios.

The orchestrator in Maude has the following two objectives.
\begin{compactenum}
  \item Synthesize a co-simulation algorithm
  \item Execute the co-simulation algorithm.
\end{compactenum}

\subsection{Synthesizing Co-simulation Algorithms}
The framework synthesizes co-simulation algorithms of a scenario $\scenario$ by rewriting its \texttt{GlobalState} while it tracks the chosen rewritings.

The \texttt{GlobalState} is rewritten by a collection of rewrite rules that defines the different SU actions.
A rewrite rule of an action is only enabled if the \texttt{GlobalState} satisfies the precondition of the action.

The rule below describes a rewriting of using $\fget{}$ operation:
\small
\begin{alltt}
crl [get-syn] :
< SU1 : SU | fmistate : Simulation, inputs : IS, 
  outputs : (< O : Output | time : T, status : Undef, value : V, dependsOn : FT > OS) > 
(SU1 ! O ==> SU2 ! I)
< OCH : SimData | values : PV > 
< ALG : AlgoData | CoSimStep : ALGO >
=> getAction(< SU1 : SU | >, SU1 ! O)
  (SU1 ! O ==> SU2 ! I)
  < OCH : SimData | values : insert((SU2 ! I), < T ; V >, PV) >  
  < ALG : AlgoData | CoSimStep : (ALGO ; EVENT) >
if feedthroughSatisfied(FT, IS, T)
\(\land\) EVENT := portEvent: Get SU: SU1 PId: O . 
\end{alltt}
\normalsize
A value \texttt{V} can be obtained from the output \texttt{O} of SU \texttt{SU1} if the current state satisfies $\fpreget{}$.
It means that all inputs that the feed-through constraints \texttt{FT} of output \texttt{O} are satisfied, which the equation \texttt{feedthroughSatisfied} checks.
The status of the output \texttt{O} should furthermore be \texttt{Undef}.
The rule updates the output \texttt{O} using the operation \texttt{getAction} and inserts the outputs value and time \texttt{<T ;V >} in the map \texttt{values} such that it later can be set on the input \texttt{I} of SU \texttt{SU2} that is coupled to the output \texttt{O} of SU \texttt{SU1}.
Finally, it adds the action \texttt{portEvent: Get SU: SU1 PId: O} to the \texttt{CoSimStep}.

All the ``synthesis'' rules follow the same pattern shown by the rule above.
They rewrite the scenario while remembering how they did it.

Based on the rewrite rules, we can synthesize a co-simulation algorithm.
The rewriting starts from a consistent initial state, for example, the state of \cref{ex:simulationunits} and explores how a consistent final state can be established.
The rewriting ensures that we only generate correct algorithms respecting \cref{def:correctalgo}.  

An algorithm of a given scenario is synthesized using the following rule:
\small
\begin{alltt}
crl [getAlgortihm]: \{ INIT \} => \{ getOrchestrator(FINALSTATE) \}
if isInitialState(INIT)
  \(\land\) LOOPS := tarjan(INIT)
  \(\land\) SUIDsNE := getSUIDsOfScenario(INIT)
  \(\land\) SIMDATA := initialOrchestrationData(1,LOOPS,SUIDsNE)
  \(\land\) CONF := calculateSNSet(INIT) SIMDATA initialAlgorithmData(1)
  \(\land\) \{CONF\} => \{ FINALSTATE\} 
  \(\land\) allSUsinUnloaded(SUIDsNE, FINALSTATE) .
\end{alltt}
\normalfont
The rule \texttt{getAlgorithm} checks if the scenario \texttt{INIT} is in an consistent state using the equational predicate \texttt{isInitialState}.
After that, we construct a simulation as the GlobalState \texttt{CONF} from the consistent state \texttt{INIT} using the same strategy as defined in section 3.
It rewrites the GlobalState \texttt{CONF} to \texttt{FINALSTATE} using the nested rewriting rule $\{CONF\} => \{ FINALSTATE\}$.
The nested rewriting rule searches for a consistent final state \texttt{FINALSTATE} satisfying the equational predicate \texttt{allSUsinUnloaded}.
The equation \texttt{allSUsinUnloaded} ensures that all SUs have been properly simulated and unloaded.
The equation \emph{getOrchestrator} extracts the synthesized co-simulation algorithm from the final state.

\begin{example}
  Extracting an algorithm for the scenario described by \cref{ex:simulationunits} yields the algorithm:
  \small
  \begin{alltt}
  crl [getAlgortihm]: \{ INIT \} => \{ getOrchestrator(FINALSTATE) \}
  if isInitialState(INIT)
    \(\land\) LOOPS := tarjan(INIT)
    \(\land\) SUIDsNE := getSUIDsOfScenario(INIT)
    \(\land\) SIMDATA := initialOrchestrationData(1,LOOPS,SUIDsNE)
    \(\land\) CONF := calculateSNSet(INIT) SIMDATA initialAlgorithmData(1)
    \(\land\) \{CONF\} => \{ FINALSTATE\} 
    \(\land\) allSUsinUnloaded(SUIDsNE, FINALSTATE) .
  \end{alltt}
  \normalfont
\end{example}

The rewriting rules support co-simulation algorithms' synthesis for both simple and complex co-simulation scenarios; however, we cannot detail the synthesis of complex co-simulation algorithms due to space limitations.

Multiple rewrite rules can be simultaneously enabled, which means that multiple correct algorithms can be synthesized for the same scenario.

Once an algorithm has been synthesized, it can be executed in Maude to simulate a scenario.

\subsection{Execution of an algorithm}
This section describes how we run simulations using the generated algorithms on the scenario.

The execution of an algorithm rewrites a \emph{SimState}:
\small
\begin{alltt}
op run:_on:_with:_ : Object Configuration Object -> SimState [ctor]. 
\end{alltt}
\normalsize
The first component of type \texttt{Object} is the co-simulation algorithm, the second component of type \texttt{Configuration} is the co-simulation scenario, and the third component denotes the simulation data of type \texttt{SimState}.

A co-simulation algorithm is executed by sequentially performing the actions of the co-simulation algorithm.
We start by performing all actions in the \texttt{Initialization}, secondly we perform all actions of the \texttt{CoSimStep} before we finally execute all actions of the \texttt{Termination}. 

The rewrite rule below shows an execution of the $\fget{}$ action.
\small
\begin{alltt}
crl [get] : 
run: < ALG : AlgoData | CosimStep : ((action: Get SU: SU1 PId: O) ; ALGO) >
on: CONF
< SU1 : SU | outputs : (< O : Output | time : T, value : V, 
  dependsOn : FT > OS), inputs : IS > ( SU1 ! O ==> SU2 ! INPUT)
with: < OCH : SimData | values : PV >
=> 
run: < ALG : AlgoData | CosimStep : ALGO >
on: CONF getAction(< SU1 : SU | >, SU ! O) ( SU1 ! O ==> SU2 ! INPUT)
with: < OCH : SimData | values : insert((SU2 ! INPUT), < T ; V >, PV) > 
if feedthroughSatisfied(FT, IS, T) .
\end{alltt}
\normalsize
The rule performs the first action (\texttt{(action: Get SU: SU1 PId: O)}) of the list \texttt{CosimStep}.
The action state that we should get the value of output \texttt{O} of SU \texttt{SU1}.
The rule ensures that all feed-through requirements are satisfied.
The result of the rule is that the value \texttt{V} is saved in the map \texttt{values}, the output is updated, and that the performed action is removed from the list of actions defined by the \texttt{CoSimStep}.

The simulation finishes when all the actions have been exhausted, and no more rewritings can occur.

A simulation of a scenario is performed using the rule:
\small
\begin{alltt}
crl [runAlg] : runAnyAlgorithm INIT => run: ORC on: INIT with: SIMDATA
  if LOOPS := tarjan(INIT)
  \(\land\) SUIDsNE := getSUIDsOfScenario(INIT)
  \(\land\) SIMDATA := initialOrchestrationData(1,LOOPS,SUIDsNE)
  \(\land\) ALGO := initialAlgorithmData(1)
  \(\land\) CONF := calculateSNSet(INIT ALGO) SIMDATA 
  \(\land\) \{CONF\} => \{ FINALSTATE \} 
  \(\land\) ORC := getOrchestrator(FINALSTATE)
  \(\land\) allSUsinUnloaded(SUIDsNE, FINALSTATE) .
\end{alltt}
\normalsize
The rule first instantiates a scenario \texttt{CONF} from the initial state of the scenario \texttt{INIT} as previously described.
The scenario is rewriting using the nested rewrite rule \texttt{\{CONF\} => \{ FINALSTATE \}}. 
The nested rule rewrites the initial state \texttt{CONF} to the final state \texttt{FINALSTATE}, which satisfies the predicate \texttt{allSUsinUnloaded}.
The algorithm \texttt{ORC} to reach the final state is extracted using \texttt{getOrchestrator}.
The scenario is simulated using rewriting of the object \texttt{run: ORC on: INIT with: SIMDATA}.
The rewriting runs the simulation on the scenario \texttt{INIT} using the simulation data of the scenario that is generated by the equation \texttt{initialOrchestrationData}.

\begin{example}\label{ex:algoexecution}
The scenario described in \cref{ex:simulationunits} (\texttt{SCENARIO} below) can be simulated by rewriting it using the rule \texttt{runAlg}:
\small
\begin{alltt}
  frew (runAnyAlgorithm SCENARIO).
\end{alltt}
\normalsize
The rewriting returns the final simulation state:
\scriptsize
\begin{alltt}
run: < "Algorithm" : AlgorithmData | CosimStep : emptyList,Initialization : emptyList,
                                     Termination : emptyList,endTime : 1 > 
on: ("ctrl" ! "valveState" ==> "tank" ! "valveState") 
    ("tank" ! "waterlevel" ==> "ctrl" ! "waterlevel")
< "ctrl" : SU | canReject : false, fmistate : Unloaded, localState : "valve" |-> < true >,
inputs : < "waterlevel" : Input | contract : reactive, status : Def,time : 1,
                                  type : integer, value : < 100 > >,
outputs : < "valveState" : Output | dependsOn : empty, status : Def, time : 1,
                                    type : integer, value : < 1 > >,
parameters :("high" |-> < 5 >, "low" |-> < 0 >), time : 1 > 
< "tank" : SU | canReject : false, fmistate : Unloaded, localState : "waterlevel" |-> < 100 >,
inputs : < "valveState" : Input | contract : delayed,status : Def,
                                  time : 1, type : integer, value : < 1 > >,
outputs : < "waterlevel" : Output | dependsOn : empty, status : Def,time : 1,
                                    type : integer,value : < 100 > >,
parameters : "flow" |-> < 100 >,time : 1 > 
with: < "Orchestrator" : SimulationData | 
          SNSet : empty, actualStepSize : 1, defaultStepSize : 1, guessOn : empty,
          simulationTime : 1, solvedSCC : empty, suids :("ctrl", "tank"), 
          unsolvedSCC : empty, values : empty >
\end{alltt}
\normalsize
\end{example}

The execution of an algorithm in Maude enables different kinds of analyses described in the following sections.

\subsection{Ensuring Confluent Co-simulation Algorithms}
All the generated algorithms of the same scenario should result in the same simulation result; otherwise, the co-simulation practitioner's faith is in the hand of Maude.
The co-simulation practitioner would be in trouble if the simulation result depended on the algorithm that an arbitrary rewriting of the scenario produced.

To show that all algorithms lead to the same simulation, we use Maude to show that all generated co-simulation algorithms of a scenario result in the same co-simulation result such that co-simulation cannot detect any difference between the synthesized algorithms.
We say that a co-simulation practitioner cannot detect any differences between two co-simulations that has the same initial and final state.
For example, we two algorithms $P_1$ and $P_2$ are indistinguishable if $s \xrightarrow[\text{}]{P_1} s' \land s \xrightarrow[\text{}]{P_2} s'$ or any other words $P_1$ and $P_2$ are confluent.

The can unfortunately not prove in Maude that all the synthesized algorithms of an arbitrary scenario are confluent.
Instead, we can perform the check on case to case basis.  

\begin{example}
  We can check that all synthesized algorithms of a scenario \texttt{Scenario} are confluent by the following search command:
  \small
  \begin{alltt}
search (runAnyAlgorithm SCENARIO)  =>! S:SimState . 
  \end{alltt}
  \normalsize
The search exhaustively synthesizes all co-simulation algorithms of the scenario \texttt{SCENARIO}. 
Afterwards, it rewrites the scenario using the algorithm until it reaches a final state \texttt{S} that cannot be rewritten any further.
If \texttt{SCENARIO} was the scenario described by \cref{ex:simulationunits} the search would result in an single result similar to the result of \cref{ex:algoexecution}, which means that all algorithms are confluent.
\end{example}

Confluence of the synthesized co-simulation algorithms is essential; it ensures that all correct algorithms lead to the same simulation result.

Even though two algorithms are confluent, they can still possess different properties, such as memory overhead and execution time. 
The framework does currently not allow us to explore this aspect.
Nevertheless, we believe that this would be possible in a future version.