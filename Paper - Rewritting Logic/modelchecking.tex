\section{Synthesizing and Executing Co-simulation Algorithms}\label{sc:sc:synthesize}
This section describes how to synthesize and execute co-simulation algorithms of a scenario in Maude.

\subsection{Orchestrator}
The orchestrator simulates the scenario by exchanging values between couplings and calculating new states for each of the SUs.

To do this, it keeps track of the co-simulation state, the orchestration algorithm, and some extra data that enables step negotiation and exchange value between the SUs.

The orchestrator is divided into following classes:
\begin{alltt}
\small
class SimData | SNSet : OidSet, defaultStepSize : NzNat,
 actualStepSize : NzNat, unsolvedSCC : AlgebraicLoopSet, solvedSCC : AlgebraicLoopSet,
  guessOn : PortSet, values : PortValueMap, simulationTime : Nat,suids : NeOidSet .

class AlgoData | CosimStep : ActionList, Initialization : ActionList, 
Termination : ActionList, endTime : NzNat .
\end{alltt}

The class \texttt{SimData} describes different dynamic data structures that the orchestrator uses to simulate the system. 
The attribute \texttt{values} denotes a map linking a port with a value. 
The orchestrator uses the map to track which values it has obtained but not set on an input port. 
The class \texttt{AlgoData} denotes the co-simulation algorithm.
The co-simulation algorithm is divided into three subsequent parts.
The attribute \texttt{Initialization} denotes the initialization procedure that is responsible for making the scenario reading for simulation.
The attribute \texttt{CosimStep} denotes the co-simulation step procedure that the orchestrator applies until it reaches the end time of the simulation denoted by the attribute \texttt{endTime}.
The attribute \texttt{Termination} denotes the actions to terminate and unload the SUs.
The type \texttt{ActionList} denotes as a list of SU operations.

Our orchestrator in Maude has two objectives.
\begin{compactenum}
  \item Synthesize a co-simulation algorithm
  \item Execute the co-simulation algorithm.
\end{compactenum}

\subsection{Synthesizing Co-simulation Algorithms}
The framework synthesizes co-simulation algorithms of a scenario by rewriting the \texttt{GlobalState} while it tracks the chosen rewritings.

We have defined the different SU actions as rewrite rules.
These rules are only enabled if the co-simulation state satisfies the precondition of the performed action.

For example, the rule below describes when \texttt{GlobalState} can be rewritten by the $\fget{}$ operation as a part of the initialization procedure.

\begin{alltt}
  \small
crl [get-init] :
< SU1 : SU | fmistate : Initialize, inputs : IS, 
  outputs : (< O : Output | status : Undef, value : V, dependsOn : FT > OS) > 
(SU1 ! O ==> SU2 ! I)
< OCH : SimData | values : PV > 
< ALG : AlgoData | Initialization : ALGO >
=> getAction(< SU1 : SU | >, SU1 ! O)
  (SU1 ! O ==> SU2 ! I)
  < OCH : SimData | values : insert((SU2 ! I), < 0 ; V >, PV) >  
  < ALG : AlgoData | Initialization : (ALGO ; EVENT) >
if feedthroughSatisfied(FT, IS, 0)
\(\land\) EVENT := portEvent: Get SU: SU1 PId: O . 
\end{alltt}

We can get the value of the output \texttt{O} of SU \texttt{SU1} if the \texttt{GlobalState} satisfies $\fpreget{}$.
It means that all inputs that feed through \texttt{FT} to the output \texttt{O} are defined, which is checked by equation \texttt{feedthroughSatisfied}.
The output \texttt{O} should furthermore be \texttt{Undef}.
The $\fget{}$ operation updates the output \texttt{O} and saves the value \texttt{V} in the map \texttt{values} such that it later can be set on the input \texttt{I} of SU \texttt{SU2} that is coupled to the output \texttt{O} of SU \texttt{SU1}.
We also save that we did a $\fget{}$ operation on the output  output \texttt{O} of SU \texttt{SU1} in the \texttt{Initialization}.

All the rewrite rules that are part of the co-simulation algorithm synthesizing follow the pattern from the rule above.
The rewrite the \texttt{GlobalState} while it adds the performed rewriting to the co-simulation algorithm, changes the state of the affected SU, and potentially updates the \texttt{SimData} class.

An algorithm is synthesized by starting from a consistent initial state, from where we use the rewrite rules to see if we can establish a consistent final state.
The strategy ensures that we only generate correct algorithms respecting \cref{def:correctalgo}. 

It can ofter be the case that multiple rules are simultaneously enabled, which means that multiple algorithms can be synthesized for the same scenario.

All the algorithms of a given scenario are synthesized using the following rule:

\begin{alltt}
  \small
crl [getAlgortihm]: \{ INIT \} => \{ getOrchestrator(FINALSTATE) \}
if isInitialState(INIT)
  \(\land\) LOOPS := tarjan(INIT)
  \(\land\) SUIDsNE := getSUIDsOfScenario(INIT)
  \(\land\) SIMDATA := initialOrchestrationData(1,LOOPS,SUIDsNE)
  \(\land\) CONF := calculateSNSet(INIT) SIMDATA initialAlgorithmData(1)
  \(\land\) \{CONF\} => \{ FINALSTATE\} 
  \(\land\) allSUsinUnloaded(SUIDsNE, FINALSTATE) .
\end{alltt}

The rule first checks if the scenario \texttt{INIT} is in an consistent state using the equational predicate \texttt{isInitialState}.
After that, we construct a simulation as the GlobalState \texttt{CONF} from the consistent state \texttt{INIT} using the same strategy as defined in section 3.
It rewrites the GlobalState \texttt{CONF} to \texttt{FINALSTATE} using the nested rewriting rule $\{CONF\} => \{ FINALSTATE\}$.
The nested rewriting rule searches for all the final states \texttt{FINALSTATE} satisfying the equational predicate \texttt{allSUsinUnloaded}.
The equation \texttt{allSUsinUnloaded} ensures that all SUs of the scenario has been properly simulated and unloaded.
The rule uses the equation \emph{getOrchestrator} to obtain the synthesized co-simulation algorithm.

The described strategy can synthesize algorithms for both simple and complex co-simulation scenarios; however, we cannot detail the synthesis of complex co-simulation algorithms due to space limitations.

Once an algorithm has been synthesized, it can be executed in Maude to simulate a scenario.

\subsection{Executing}
This section describes how we run simulations using the generated algorithms on the scenario.

The execution of an algorithm rewrites a \emph{SimState}:
\small
\begin{alltt}
op run:_on:_with:_ : Object Configuration Object -> SimState [ctor]. 
\end{alltt}
\normalsize
The first component of type \texttt{Object} is the co-simulation algorithm, the second component of type \texttt{Configuration} is the co-simulation scenario, and the third component denotes the simulation data of type \texttt{SimState}.

A co-simulation algorithm is executed by sequentially performing the actions of the co-simulation algorithm.
We start by performing all actions in the \texttt{Initialization}, secondly we perform all actions of the \texttt{CoSimStep} before we finally execute all actions of the \texttt{Termination}. 

The rewrite rule below shows an execution of the $\fget{}$ action.
\small
\begin{alltt}
crl [get] : 
run: < ALG : AlgoData | CosimStep : ((action: Get SU: SU1 PId: O) ; ALGO) >
on: CONF
< SU1 : SU | outputs : (< O : Output | time : T, value : V, 
  dependsOn : FT > OS), inputs : IS > ( SU1 ! O ==> SU2 ! INPUT)
with: < OCH : SimData | values : PV >
=> 
run: < ALG : AlgoData | CosimStep : ALGO >
on: CONF getAction(< SU1 : SU | >, SU ! O) ( SU1 ! O ==> SU2 ! INPUT)
with: < OCH : SimData | values : insert((SU2 ! INPUT), < T ; V >, PV) > 
if feedthroughSatisfied(FT, IS, T) .
\end{alltt}
\normalsize
The rule performs the first action (\texttt{(action: Get SU: SU1 PId: O)}) of the list \texttt{CosimStep}.
The action state that we should get the value of output \texttt{O} of SU \texttt{SU1}.
The rule ensures that all feed-through requirements are satisfied.
The result of the rule is that the value \texttt{V} is saved in the map \texttt{values}, the output is updated, and that the performed action is removed from the list of actions defined by the \texttt{CoSimStep}.

The simulation finished when all the actions have been exhausted and no more rewritings can take place.

The execution of an algorithm in Maude enables different kinds of analyses.

\subsection{Analyzing the Algorithm}
All the generated algorithms of the same scenario must result in the same simulation result; otherwise, the co-simulation practitioner's faith is in the hand of Maude.
The co-simulation practitioner would be in trouble if the simulation result depended on the algorithm that an arbitrary rewriting of the scenario produced.

To show that this is not the case, we can use Maude's model checker to show that all generated co-simulation algorithms of a scenario result in the same co-simulation result.
The co-simulation practitioner should not be able to detect any difference between the algorithms.

We show that all algorithms of the scenario leads to the same state using the rule \texttt{runAlg}:
\small
\begin{alltt}
crl [runAlg] : runAnyAlgorithm INIT => run: ORC on: INIT with: SIMDATA
  if LOOPS := tarjan(INIT)
  \(\land\) SUIDsNE := getSUIDsOfScenario(INIT)
  \(\land\) SIMDATA := initialOrchestrationData(1,LOOPS,SUIDsNE)
  \(\land\) ALGO := initialAlgorithmData(1)
  \(\land\) CONF := calculateSNSet(INIT ALGO) SIMDATA 
  \(\land\) {CONF} => { FINALSTATE } 
  \(\land\) ORC := getOrchestrator(FINALSTATE)
  \(\land\) allSUsinUnloaded(SUIDsNE, FINALSTATE) .
\end{alltt}
\normalsize
The rule first instantiates a scenario from the initial state of the scenario \texttt{INIT} as previously described.
It uses the nested rewrite rule to rewrite the initial GlobalState \texttt{CONF} to the final GlobalState \texttt{FINALSTATE}, extracts the co-simulation algorithm \texttt{ORC} and runs the simulation on the scenario \texttt{INIT} using the simulation data of the scenario that is generated by the equation \texttt{initialOrchestrationData}.

Using Maude's search command, we can exhaustively check the rule \texttt{runAlg}:

\small
\begin{alltt}
  search (runAnyAlgorithm SCENARIO)  =>! S:SimulationState . 
\end{alltt}
\normalsize

The search exhaustively synthesizes all co-simulation algorithms of the scenario \textit{SCENARIO}. Afterward, it rewrites the scenario using the algorithm until it reaches a final state \textit{S} of type \textit{SimulationState} that cannot be rewritten any further.

We can use the search command above to check that all the different algorithms we can synthesize of a scenario from our semantics of \cref{sc:background} are confluent.

\simon{Should I show an example here?}

If the algorithms are confluent, we do not need to care about which algorithm we use since they all lead to the same simulation result.
Even though all the algorithms are confluent, they could still possess different properties, such as memory overhead and execution time. 
The framework does currently not allow us to explore this aspect.
Nevertheless, we believe that this would be possible in a future version.ssible in a future version.

