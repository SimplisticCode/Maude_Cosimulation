\section{Synthesizing and Executing Co-simulation Algorithms}\label{sc:synthesize}
This section describes how to synthesize and execute co-simulation algorithms of a scenario in Maude.

\subsection{Orchestrator}
The orchestrator simulates the scenario by exchanging values between couplings and calculating new states for each of the SUs.

The simulation requires that the orchestrator keeps track of both the co-simulation algorithm and some extra data to keep track of the current execution of the algorithm to ensure that all SUs move in lockstep and that it solves all algebraic loops of the scenario.
The orchestrator is divided into the following two classes \texttt{SimData} and \texttt{AlgoData}:
\small
\begin{alltt}
class SimData | SNSet : OidSet,           defaultStepSize : NzNat,
          actualStepSize : NzNat,         unsolvedSCC : AlgebraicLoopSet, 
          solvedSCC : AlgebraicLoopSet,   guessOn : PortSet,
          values : PortValueMap,          simulationTime : Nat,
          suids : NeOidSet .
\end{alltt}
\normalfont
The class \texttt{SimData} denotes the bookkeeping that the orchestrator needs to do during the simulation.
The attribute \texttt{SNSet} denotes the set $\mayReject$; \texttt{defaultStepSize} is the default step duration of the simulation; while the attribute \texttt{actualStepSize} is the negotiated step duration.
\emph{Note} that \texttt{actualStepSize} and \texttt{defaultStepSize} always are equal if $\mayReject = \emptyset$.
The union of \texttt{unsolvedSCC} and \texttt{solvedSCC} denotes the algebraic loops of the scenario; the attributes respectively denote the solved and unsolved algebraic loops.
The attribute \texttt{guessOn} is a set of ports, it is used to solve algebraic loops using the reduction technique described in \cite{thrane2021}; \texttt{values} denotes a map linking an input port with a value. 
The orchestrator uses \texttt{values} to track which values it has obtained but not set on an input port. 
The attribute \texttt{simulationTime} describes the current global time of the simulation and \texttt{suids} denotes the identifiers of the SUs.
\small
\begin{alltt}
class AlgoData | CosimStep : ActionList,   Initialization : ActionList, 
                 Termination : ActionList, endTime : NzNat .
\end{alltt}
\normalsize
The class \texttt{AlgoData} describes the co-simulation algorithm.
The co-simulation algorithm is divided into three subsequent parts.
The attributes \texttt{Initialization} and \texttt{Termination} denote the initialization procedure and termination procedure, respectively.
The attribute \texttt{CosimStep} denotes the co-simulation step procedure that the orchestrator applies until it reaches the end time of the simulation denoted by the attribute \texttt{endTime}.
All elements of the algorithm are of the type \texttt{ActionList}.
The type \texttt{ActionList} denotes as a list of SU operations defined according to:
\small
\begin{alltt}
ops Set Get Step Save : -> ActionType [ctor] . 
op portEvent:_SU:_PId:_ : ActionType SUID OidSet -> Action [ctor] .
subsort Action < ActionList .
op emptyList : -> ActionList [ctor] .
op _;_ : ActionList ActionList -> ActionList [ctor assoc id: emptyList] .
\end{alltt}
\normalfont
We have omitted the actions to handle complex scenarios.

The orchestrator in Maude has the following two objectives.
\begin{compactenum}
  \item Synthesize a co-simulation algorithm
  \item Execute the co-simulation algorithm.
\end{compactenum}

\subsection{Synthesizing Co-simulation Algorithms}
The framework synthesizes co-simulation algorithms of a scenario $\scenario$ by rewriting its \texttt{GlobalState} while it tracks the chosen rewritings.

The \texttt{GlobalState} is rewritten by a collection of rewrite rules that defines the different SU actions.
A rewrite rule of an action is only enabled if the \texttt{GlobalState} satisfies the precondition of the action.

The rule below describes a rewriting of using $\fget{}$ operation:
\small
\begin{alltt}
crl [get-syn] :
< SU1 : SU | fmistate : Simulation, inputs : IS, 
  outputs : (< O : Output | time : T, status : Undef, value : V, dependsOn : FT > OS) > 
(SU1 ! O ==> SU2 ! I)
< OCH : SimData | values : PV > 
< ALG : AlgoData | CoSimStep : ALGO >
=> getAction(< SU1 : SU | >, SU1 ! O)
  (SU1 ! O ==> SU2 ! I)
  < OCH : SimData | values : insert((SU2 ! I), < T ; V >, PV) >  
  < ALG : AlgoData | CoSimStep : (ALGO ; EVENT) >
if feedthroughSatisfied(FT, IS, T)
\(\land\) EVENT := portEvent: Get SU: SU1 PId: O . 
\end{alltt}
\normalsize
A value \texttt{V} can be obtained from the output \texttt{O} of SU \texttt{SU1} if the current state satisfies $\fpreget{}$.
It means that all inputs that the feed-through constraints \texttt{FT} of output \texttt{O} are satisfied, which the equation \texttt{feedthroughSatisfied} checks.
The status of the output \texttt{O} should furthermore be \texttt{Undef}.
The rule updates the output \texttt{O} using the operation \texttt{getAction} and inserts the outputs value and time \texttt{<T ;V >} in the map \texttt{values} such that it later can be set on the input \texttt{I} of SU \texttt{SU2} that is coupled to the output \texttt{O} of SU \texttt{SU1}.
Finally, it adds the action \texttt{portEvent: Get SU: SU1 PId: O} to the \texttt{CoSimStep}.

All the ``synthesis'' rules follow the same pattern shown by the rule above.
They rewrite the scenario while remembering how they did it.

Based on the rewrite rules, we can synthesize a co-simulation algorithm.
The rewriting starts from a consistent initial state, for example, the state of \cref{ex:simulationunits} and explores how a consistent final state can be established.
The rewriting ensures that we only generate correct algorithms respecting \cref{def:correctalgo}.  

An algorithm of a given scenario is synthesized using the following rule:
\small
\begin{alltt}
crl [getAlgortihm]: \{ INIT \} => \{ getOrchestrator(FINALSTATE) \}
if isInitialState(INIT)
  \(\land\) LOOPS := tarjan(INIT)
  \(\land\) SUIDsNE := getSUIDsOfScenario(INIT)
  \(\land\) SIMDATA := initialOrchestrationData(1,LOOPS,SUIDsNE)
  \(\land\) CONF := calculateSNSet(INIT) SIMDATA initialAlgorithmData(1)
  \(\land\) \{CONF\} => \{ FINALSTATE\} 
  \(\land\) allSUsinUnloaded(SUIDsNE, FINALSTATE) .
\end{alltt}
\normalfont
The rule \texttt{getAlgorithm} checks if the scenario \texttt{INIT} is in an consistent state using the equational predicate \texttt{isInitialState}.
After that, we construct a simulation as the GlobalState \texttt{CONF} from the consistent state \texttt{INIT} using the same strategy as defined in section 3.
It rewrites the GlobalState \texttt{CONF} to \texttt{FINALSTATE} using the nested rewriting rule $\{CONF\} => \{ FINALSTATE\}$.
The nested rewriting rule searches for a consistent final state \texttt{FINALSTATE} satisfying the equational predicate \texttt{allSUsinUnloaded}.
The equation \texttt{allSUsinUnloaded} ensures that all SUs have been properly simulated and unloaded.
The equation \emph{getOrchestrator} extracts the synthesized co-simulation algorithm from the final state.

\begin{example}
  Extracting an algorithm for the scenario described by \cref{ex:simulationunits} yields the algorithm:
  \small
  \begin{alltt}
  crl [getAlgortihm]: \{ INIT \} => \{ getOrchestrator(FINALSTATE) \}
  if isInitialState(INIT)
    \(\land\) LOOPS := tarjan(INIT)
    \(\land\) SUIDsNE := getSUIDsOfScenario(INIT)
    \(\land\) SIMDATA := initialOrchestrationData(1,LOOPS,SUIDsNE)
    \(\land\) CONF := calculateSNSet(INIT) SIMDATA initialAlgorithmData(1)
    \(\land\) \{CONF\} => \{ FINALSTATE\} 
    \(\land\) allSUsinUnloaded(SUIDsNE, FINALSTATE) .
  \end{alltt}
  \normalfont
\end{example}

The rewriting rules support co-simulation algorithms' synthesis for both simple and complex co-simulation scenarios; however, we cannot detail the synthesis of complex co-simulation algorithms due to space limitations.

Multiple rewrite rules can be simultaneously enabled, which means that multiple correct algorithms can be synthesized for the same scenario.

Once an algorithm has been synthesized, it can be executed in Maude to simulate a scenario.

\subsection{Execution of an algorithm}
This section describes how we run simulations using the generated algorithms on the scenario.

The execution of an algorithm rewrites a \emph{SimState}:
\small
\begin{alltt}
op run:_on:_with:_ : Object Configuration Object -> SimState [ctor]. 
\end{alltt}
\normalsize
The first component of type \texttt{Object} is the co-simulation algorithm, the second component of type \texttt{Configuration} is the co-simulation scenario, and the third component denotes the simulation data of type \texttt{SimState}.

A co-simulation algorithm is executed by sequentially performing the actions of the co-simulation algorithm.
We start by performing all actions in the \texttt{Initialization}, secondly we perform all actions of the \texttt{CoSimStep} before we finally execute all actions of the \texttt{Termination}. 

The rewrite rule below shows an execution of the $\fget{}$ action.
\small
\begin{alltt}
crl [get] : 
run: < ALG : AlgoData | CosimStep : ((action: Get SU: SU1 PId: O) ; ALGO) >
on: CONF
< SU1 : SU | outputs : (< O : Output | time : T, value : V, 
  dependsOn : FT > OS), inputs : IS > ( SU1 ! O ==> SU2 ! INPUT)
with: < OCH : SimData | values : PV >
=> 
run: < ALG : AlgoData | CosimStep : ALGO >
on: CONF getAction(< SU1 : SU | >, SU ! O) ( SU1 ! O ==> SU2 ! INPUT)
with: < OCH : SimData | values : insert((SU2 ! INPUT), < T ; V >, PV) > 
if feedthroughSatisfied(FT, IS, T) .
\end{alltt}
\normalsize
The rule performs the first action (\texttt{(action: Get SU: SU1 PId: O)}) of the list \texttt{CosimStep}.
The action state that we should get the value of output \texttt{O} of SU \texttt{SU1}.
The rule ensures that all feed-through requirements are satisfied.
The result of the rule is that the value \texttt{V} is saved in the map \texttt{values}, the output is updated, and that the performed action is removed from the list of actions defined by the \texttt{CoSimStep}.

The simulation finishes when all the actions have been exhausted, and no more rewritings can occur.

The execution of an algorithm in Maude enables different kinds of analyses.

\subsection{Analyzing the Algorithm}
All the generated algorithms of the same scenario must result in the same simulation result; otherwise, the co-simulation practitioner's faith is in the hand of Maude.
The co-simulation practitioner would be in trouble if the simulation result depended on the algorithm that an arbitrary rewriting of the scenario produced.

To show that this is not the case, we can use Maude's model checker to show that all generated co-simulation algorithms of a scenario result in the same co-simulation result.
The co-simulation practitioner should not be able to detect any difference between the algorithms.

We show that all algorithms of the scenario leads to the same state using the rule \texttt{runAlg}:
\small
\begin{alltt}
crl [runAlg] : runAnyAlgorithm INIT => run: ORC on: INIT with: SIMDATA
  if LOOPS := tarjan(INIT)
  \(\land\) SUIDsNE := getSUIDsOfScenario(INIT)
  \(\land\) SIMDATA := initialOrchestrationData(1,LOOPS,SUIDsNE)
  \(\land\) ALGO := initialAlgorithmData(1)
  \(\land\) CONF := calculateSNSet(INIT ALGO) SIMDATA 
  \(\land\) {CONF} => { FINALSTATE } 
  \(\land\) ORC := getOrchestrator(FINALSTATE)
  \(\land\) allSUsinUnloaded(SUIDsNE, FINALSTATE) .
\end{alltt}
\normalsize
The rule first instantiates a scenario from the initial state of the scenario \texttt{INIT} as previously described.
It uses the nested rewrite rule to rewrite the initial GlobalState \texttt{CONF} to the final GlobalState \texttt{FINALSTATE}, extracts the co-simulation algorithm \texttt{ORC} and runs the simulation on the scenario \texttt{INIT} using the simulation data of the scenario that is generated by the equation \texttt{initialOrchestrationData}.

Using Maude's search command, we can exhaustively check the rule \texttt{runAlg}:
\small
\begin{alltt}
  search (runAnyAlgorithm SCENARIO)  =>! S:SimulationState . 
\end{alltt}
\normalsize

The search exhaustively synthesizes all co-simulation algorithms of the scenario \texttt{SCENARIO}. 
Afterwards, it rewrites the scenario using the algorithm until it reaches a final state \texttt{S} of type \texttt{SimulationState} that cannot be rewritten any further.

We can use the search command above to check that all the different algorithms we can synthesize of a scenario from our semantics of \cref{sc:background} are confluent.

\simon{Should I show an example here?}

If the algorithms are confluent, we do not need to care about which algorithm we use since they all lead to the same simulation result.
Even though all the algorithms are confluent, they could still possess different properties, such as memory overhead and execution time. 
The framework does currently not allow us to explore this aspect.
Nevertheless, we believe that this would be possible in a future version.