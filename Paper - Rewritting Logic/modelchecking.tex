
\section{Executing Orchestration Algorithms}
This section describes how we run simulations using the generated algorithms.

An algorithm is executed by systematically interpreting the algorithm by going through it and executing one action at a time using rewriting.
Below we show the rule describing the $\fget{}$ action.
\begin{alltt}
\small
crl [get] : 
run: < ALG : AlgoData | CosimStep : ((portEvent: Get SU: SU1 PId: O) ; ALGO) >
on: CONF
    < SU1 : SU | outputs : (< O : Output | time : T, 
value : V, dependsOn : FT > OS), inputs : IS > 
    ( SU1 ! O ==> SU2 ! INPUT)
with: < OCH : SimData | values : PV >
=> 
run: < ALG : AlgoData | CosimStep : ALGO >
on: CONF < SU1 : SU | outputs : (< O : Output | status : Def > OS) > 
            ( SU1 ! O ==> SU2 ! INPUT)
with: < OCH : SimData | values : insert((SU2 ! INPUT), < T ; V >, PV) > 
if feedthroughSatisfied(FT, IS, T) .
\end{alltt}

We use the execution of an algorithm to perform different kinds of analysis of both the algorithms and the scenario itself.

We explore the different tailored algorithms generated to simulate the same scenario.
The simulation result should not depend on the algorithm we happen to extract. 
Therefore we would like that all tailored produces the same simulation result.
We can show this by defining a rule that extracts all algorithms for a scenario and afterwards runs a simulation for each algorithm starting from the same initial state.

\begin{alltt}
  \small
crl [runAlg] : runAnyAlgorithm INIT => run: ORC on: INIT with: SIMDATA
  if LOOPS := tarjan(INIT)
  \(\land\) SUIDsNE := getSUIDsOfScenario(INIT)
  \(\land\) SIMDATA := initialOrchestrationData(1,LOOPS,SUIDsNE)
  \(\land\) ALGO := initialAlgorithmData(1)
  \(\land\) CONF := calculateSNSet(INIT ALGO) SIMDATA 
  \(\land\) {CONF} => { FINALSTATE } 
  \(\land\) ORC := getOrchestrator(FINALSTATE)
  \(\land\) allSUsinUnloaded(SUIDsNE, FINALSTATE) .
\end{alltt}

On top of this, we use Maude's search command to check if all the different allowed simulations are confluent such that they result in the same final state.

\begin{lemma}[Deterministic Orchestration Algorithms]
  All tailored orchestration algorithms of a scenario produce the same co-simulation result.
\end{lemma}

This property can be verified using the following search command.

\begin{alltt}
  search (runAnyAlgorithm INIT)  =>! S:SimulationState . 
\end{alltt}
The search command uses the rewriting rules first to generate all the different orchestration algorithms for the scenario.
After that, it executes each algorithm from the same initial state to check its final state.

The property ensures we do not need to care about which tailored algorithm we use since they all lead to the same simulation result.
However, the different algorithms naturally have different properties; the most interesting is probably the algorithm's execution time. 
We currently do not have the setup in place to explore this aspect.
Nevertheless, it could be interesting to explore this in the future.


\subsection{Design Space Exploration}
Using Maude's integrated LTL model checker, the Maude framework also allows two different kinds of design space exploration.
This analysis enables a co-simulation practitioner to see how different model parameters change the co-simulation result.
We describe the two independently even though they can be combined.
We start by describing how one can explore different instrumentations of a scenario.
Hereafter, we will describe how to explore different parameters for the simulation units.  

\subsubsection{Instrumentation of a Scenario}
As shown in \cite{Gomes2019,Oakes2021,hansen_verification_2021} contracts on the input ports can be used to achieve more accurate co-simulation results.
However, it is challenging for co-simulation practitioners to adapt their scenarios, especially because none of the current FMU-exporting tools provide this information on the SUs.

To ease the transition, we use Maude's model checker to explore the consequences of using different instrumentations of a scenario.

To explore different instrumentations of a scenario, we have defined the contract: \textit{noContract}.
The contract can be used if the user does not know the input contract.
We consider a scenario where the contract of at least one input is defined to be \textit{noContract} to be uninstrumented.

A scenario can only be simulated if it is instrumented.
A scenario is instrumented if no input in the scenario has a contract defined to be \textit{noContract}.


This allows Maude to play with different instrumentations of the scenario (different version of the function $\allreactivity$) such that for each input with the contract \textit{noContract} Maude tries to perform a simulation where the input is delayed and a simulation where the input is reactive.
The rewriting rules for this is given below:
\begin{alltt}
  \small
rl [instr-delayed]: 
findInstr(< SU1 : SU | inputs : (< I : Input | contract : noContract > IS) > C)
=>
findInstr(< SU1 : SU | inputs : (< I : Input | contract : delayed > IS) > C) .

rl [instr-reactive]: 
findInstr(< SU1 : SU | inputs : (< I : Input | contract : noContract > IS) > C)
=>
findInstr(< SU1 : SU | inputs : (< I : Input | contract : reactive > IS) > C) .

crl [remove-findInstr]: findInstr(CONF) => CONF 
  if allConstraintsDefined(CONF) .
\end{alltt}

The co-simulation practitioner can use the rewriting rule below to experiment with different instrumentations of the scenario.

\begin{alltt}
  \small
  crl [findInstrumentation]: findContacts(INIT) => CONF
      if findInstr(INIT) => CONF
      \(\land\) empty == tarjan(CONF) *** No loops
      \(\land\) runAnyAlgorithm CONF => run: ORC on: FINAL with: SIMDATA
      \(\land\) shouldSatisfy(FINAL) .
  \end{alltt}

The rule generates all the different instrumentations of the scenario that satisfy specific properties.
It does so by first instrumenting the scenario to generate the instrumented scenario ``CONF''.
Hereafter it simulates the instrumented scenario ``CONF'' to check the resulting simulation.
The user can limit the explored instrumentations in desired ways.
For example, in the rule above, we have specified that we are not interested in instrumentations that generate algebraic loops in the scenario.

Furthermore, the framework allows the co-simulation practitioner to specify concrete constraints on the simulation result result.
The constraints are above specified using the predicate \emph{shouldSatisfy}.

The different instrumentations are explored using Maude's search command.

\begin{alltt}
  \small
  search findContacts(Scenario) =>! C:Configuration .
\end{alltt}
  
This returns all the configurations/instrumentations of the scenarios that satisfy the desired properties defined in the above rule.

\subsubsection{Parameters of the Simulation Units}
An SU may have different parameters affecting its behavior.
This means that different parameters might lead to different simulation results.
Design space exploration explores how different valuations of the parameters affect the co-simulation result.
Design space exploration can therefore be used to find the optimal valuation of the parameters. 

The Maude framework allows design space exploration by letting the user specify the valuation a parameter as a set of possible valuations inside the \emph{choose}-operator as we shown below.
\begin{alltt}
  \small
< "tank" : SU | parameters : ("flow" |-> choose((< 1 >,< 2 >,< 30 >))) >
\end{alltt}

The \emph{choose}-operator non-deterministically picks a valuation in the set.
The framework uses the model checker to try out to run a simulation using all the different combinations of valuations for the desired properties.
This is done using the following rewriting rule.

\begin{alltt}
  \small
  crl [dse] : selectParams(UNITIALIZEDCONF) => CONF 
  if UNITIALIZEDCONF => CONF
  \(\land\) runAnyAlgorithm CONF => 
      run: < ALG : AlgData | Initialization : emptyList, 
      CosimStep : emptyList, Termination : emptyList > 
      on: FINALSTATE
      with: SIMULATIONDATA
  \(\land\) above10(FINALSTATE) .
\end{alltt}

The rule finds the valuations of the parameters that result in a simulation satisfying specific user-defined properties.
In the above rule, the valuation must ensure that the simulation satisfies the predicate \emph{above10}.

The parameters of the scenario can be found using a search command starting from a scenario with multiple valuations.
\begin{alltt}
  \small
  search selectParams(initConfDSE)  =>! C:Configuration .
\end{alltt}

\subsubsection{Combining Instrumentation and Parameter Search}
It is possible to combine the two searches to search both for the instrumentation and parameters of the scenario to obtain a given simulation.

This is done by defining an uninstrumented scenario where some parameters can take different valuations.


\subsection{Limitation of the approach}
We have performed the analyses on different scenarios. 
The state-space explosion is, of course, also applying to our work. 
However, we have been able to find the correct instrumentation and the contracts on systems with \simon{Create big scenario and test} SUs.

Also, we do not currently support adaptive co-simulations~\cite{Inci2021} where the instrumentation changes during the simulation. 
However, this is our impression that this feature trivial can be added.