\section{Synthesizing and Executing Co-simulation Algorithms}\label{sc:sc:synthesize}
This section describes how to synthesize and execute co-simulation algorithms of a scenario in Maude.

\subsection{Orchestrator}
The orchestrator simulates the scenario by exchanging values between couplings and calculating new states for each of the SUs.

To do this, it keeps track of the co-simulation state, the orchestration algorithm, and some extra data that enables step negotiation and exchange value between the SUs.

The orchestrator is divided into following classes:
\begin{alltt}
\small
class SimData | SNSet : OidSet, defaultStepSize : NzNat,
 actualStepSize : NzNat, unsolvedSCC : AlgebraicLoopSet, solvedSCC : AlgebraicLoopSet,
  guessOn : PortSet, values : PortValueMap, simulationTime : Nat,suids : NeOidSet .

class AlgoData | CosimStep : ActionList, Initialization : ActionList, 
Termination : ActionList, endTime : NzNat .
\end{alltt}

The class \textit{SimData} describes different dynamic data structures that the orchestrator uses to simulate the system. 
The attribute \textit{values} denotes a map linking a port with a value. 
The orchestrator uses the map to track which values it has obtained but not set on an input port. 
The class \textit{AlgoData} denotes the co-simulation algorithm.
The co-simulation algorithm is divided into three subsequent parts.
The attribute \textit{Initialization} denotes the initialization procedure that is responsible for making the scenario reading for simulation.
The attribute \textit{CosimStep} denotes the co-simulation step procedure that the orchestrator applies until it reaches the end time of the simulation denoted by the attribute \textit{endTime}.
The attribute \textit{Termination} denotes the actions to terminate and unload the SUs.
The type \textit{ActionList} denotes as a list of SU operations.

Our orchestrator in Maude has two objectives.
\begin{compactenum}
  \item Synthesize a co-simulation algorithm
  \item Execute the co-simulation algorithm.
\end{compactenum}

\subsection{Synthesizing Co-simulation Algorithms}
The framework synthesizes co-simulation algorithms of a scenario by rewriting the co-simulation state while it keeps track of the performed rewriting rules.
%This way, we can synthesize correct-by-construction/tailored algorithms.

Based on \cref{def:getout,def:setin,def:step}, we have defined the different SU actions as conditional rewrite rules.
These rewrite rules are only enabled if the co-simulation state satisfies the respective precondition.

An example of a rewrite rule is the rule below; the rule describes the semantic of the $\fget{}$ operation in the initialization phase of the simulation.

\begin{alltt}
  \small
  crl [get-init] :
  < SU1 : SU | fmistate : Initialize, inputs : IS, 
    outputs : (< O : Output | status : Undef, value : V, dependsOn : FT > OS) > 
  (SU1 ! O ==> SU2 ! I)
  < OCH : SimData | values : PV > 
  < ALG : AlgoData | Initialization : ALGO >
  => < SU1 : SU | outputs : (< O : Output | status : Def > OS) > 
    (SU1 ! O ==> SU2 ! I)
    < OCH : SimData | values : insert((SU2 ! I), < 0 ; V >, PV) >  
    < ALG : AlgoData | Initialization : (ALGO ; EVENT) >
if feedthroughSatisfied(FT, IS, 0)
  \(\land\) EVENT := portEvent: Get SU: SU1 PId: O . 
\end{alltt}

The rewrite rule is only enabled if the co-simulation state satisfies the precondition $\fpreget{}$.
The precondition is not directly specified; it is represented by the predicate $\mathit{feedthroughSatisfied}$ and state pattern defined on the left-hand side of the rewriting.

These conditional rewriting rules are defined on the level of the orchestrator.
It means that the above rule changes the SU's state and changes the orchestrator's state.
The orchestrator logs the chosen rewriting/action and saves the output's value into a map.
The saved value can be set on an input later in the simulation; the action is logged as a part of the synthesizing approach. 

As a result of this, an orchestration algorithm can be synthesized by rewriting the scenario until a final state is reached. 

The rewriting starts from a consistent initial state and uses the rewriting rules to see if it can establish a consistent final state.

This strategy ensures that we only generate a tailored algorithm. 
The argument is that all the rewriting rules are defined using the semantics of \cref{def:setin,def:getout,def:step}; we can therefore be sure that we only perform actions in which preconditions are satisfied.

Since we explore all possible valid rewriting of the scenario, we often extract multiple tailored algorithms.

All the algorithms of a given scenario are synthesized using the following rewrite rule.
\begin{alltt}
  \small
crl [getAlgortihm]: \{ INIT \} => \{ getOrchestrator(FINALSTATE) \}
if isInitialState(INIT)
  \(\land\) LOOPS := tarjan(INIT)
  \(\land\) SUIDsNE := getSUIDsOfScenario(INIT)
  \(\land\) SIMDATA := initialOrchestrationData(1,LOOPS,SUIDsNE)
  \(\land\) CONF := calculateSNSet(INIT) SIMDATA initialAlgorithmData(1)
  \(\land\) \{CONF\} => \{ FINALSTATE\} 
  \(\land\) allSUsinUnloaded(SUIDsNE, FINALSTATE) .
\end{alltt}

The rule constructs a GlobalState ``CONF'' from the initial consistent state of the Scenario ``INIT''.
Hereafter, it uses the nested rewriting rule $\{CONF\} => \{ FINALSTATE\} $ to search for all the consistent final states ``'FINALSTATE' that can be obtained by rewriting the initial state ``CONF''.
The rule terminates with a constructed algorithm once all SUs reaches the final state.

The framework can synthesize algorithms for both simple and complex scenarios; however, due to space limitations, we cannot go into details about the synthesis of complex orchestration algorithms.

Once an algorithm has been synthesized, it can be executed in Maude to simulate a scenario.
The simulation in Maude can be used to perform different kinds of design space exploration, and more concretely, it can check different properties of the extracted algorithms.

\subsection{Executing}
This section describes how we run simulations using the generated algorithms on the scenario.

The execution of an algorithm rewrites a \emph{SimState}:
\begin{alltt}
\small
op run:_on:_with:_ : Object Configuration Object -> SimState [ctor]. 
\end{alltt}
The first component is the sequentially executed algorithm, the second component is the co-simulation state, and the third component denotes the simulation data.
The rewrite rule below shows an execution of the $\fget{}$ action.

\begin{alltt}
\small
crl [get] : 
run: < ALG : AlgoData | CosimStep : ((action: Get SU: SU1 PId: O) ; ALGO) >
on: CONF
< SU1 : SU | outputs : (< O : Output | time : T, value : V, 
  dependsOn : FT > OS), inputs : IS > ( SU1 ! O ==> SU2 ! INPUT)
with: < OCH : SimData | values : PV >
=> 
run: < ALG : AlgoData | CosimStep : ALGO >
on: CONF getAction(< SU1 : SU | >, SU ! O) ( SU1 ! O ==> SU2 ! INPUT)
with: < OCH : SimData | values : insert((SU2 ! INPUT), < T ; V >, PV) > 
if feedthroughSatisfied(FT, IS, T) .
\end{alltt}

The simulation in Maude enables different analyses of both the algorithms and the scenario itself.

\subsection{Analyzing the Algorithm}
An essential property of all the generated algorithms of the same scenario scenarios is that they result in the same simulation.
The co-simulation practitioner would be in trouble if the simulation result depended on the algorithm that an arbitrary rewriting of the system produced.
Therefore we would like to show that all tailored results in the same co-simulation result - a co-simulation practitioner should not be able to detect any difference between the different algorithms.
We show this by defining a rule that extracts all scenario algorithms and afterwards runs a simulation for each algorithm starting from the same initial state.

\begin{alltt}
  \small
crl [runAlg] : runAnyAlgorithm INIT => run: ORC on: INIT with: SIMDATA
  if LOOPS := tarjan(INIT)
  \(\land\) SUIDsNE := getSUIDsOfScenario(INIT)
  \(\land\) SIMDATA := initialOrchestrationData(1,LOOPS,SUIDsNE)
  \(\land\) ALGO := initialAlgorithmData(1)
  \(\land\) CONF := calculateSNSet(INIT ALGO) SIMDATA 
  \(\land\) {CONF} => { FINALSTATE } 
  \(\land\) ORC := getOrchestrator(FINALSTATE)
  \(\land\) allSUsinUnloaded(SUIDsNE, FINALSTATE) .
\end{alltt}

The rule can be exhaustively checked using Maude's search command.


% \begin{lemma}[Deterministic Orchestration Algorithms]
%   All tailored orchestration algorithms of a scenario produce the same co-simulation result.
% \end{lemma}

\begin{alltt}
  search (runAnyAlgorithm INIT)  =>! S:SimulationState . 
\end{alltt}

The search exhaustively checks if all the different allowed simulations are confluent such that they result in the same final state.

The property ensures we do not need to care about which tailored algorithm we use since they all lead to the same simulation result.
However, the different algorithms naturally have different properties; the most interesting is probably the algorithm's execution time. 
We currently do not have the setup in place to explore this aspect.
Nevertheless, it could be interesting to explore this in the future.

