\section{Synthesizing and Executing Co-simulation Algorithms}\label{sc:synthesize}
This section describes how co-simulation algorithms for a given scenario can be synthesized and when executed in in Maude.

\subsection{Orchestrator}
The orchestrator is responsible for the simulation of a scenario.
The simulation requires a co-simulation algorithm to be synthesized and executed.
The orchestration of a scenario requires that we keep track of the co-simulation algorithm and additional data about the current execution of the algorithm.

The orchestration is modeled by instances of the following classes \texttt{SimData} and \texttt{AlgoData}:

\small
\begin{alltt}
class SimData | SNSet : OidSet,           defaultStepSize : NzNat,
          actualStepSize : NzNat,         unsolvedSCC : AlgebraicLoopSet, 
          solvedSCC : AlgebraicLoopSet,   guessOn : PortSet,
          values : PortValueMap,          simulationTime : Nat,
          suids : NeOidSet .
\end{alltt}
\normalsize

The class \texttt{SimData} contains data needed for the orchestration during the simulation.
The attribute \texttt{SNSet} denotes the set $\mayReject$ (see \cref{def:cosim_scenario}); \texttt{defaultStepSize} is the default step duration of the simulation; while the attribute \texttt{actualStepSize} is the negotiated step duration.
The attributes \texttt{actualStepSize} and \texttt{defaultStepSize} are equal if $\mayReject = \emptyset$.
The attributes \texttt{unsolvedSCC} and \texttt{solvedSCC} respectively denote the solved and unsolved algebraic loops.
The attribute \texttt{guessOn} is the set of ports, which is used to solve algebraic loops using the reduction technique described in \cite{thrane2021}; \texttt{values} is a map linking an input port with a value. 
The orchestration uses \texttt{values} to track which values it has obtained but not set on an input port. 
The attribute \texttt{simulationTime} describes the current global time of the simulation, and \texttt{suids} denotes the identifiers of the SUs.

\small
\begin{alltt}
class AlgoData | CosimStep : ActionList,   Initialization : ActionList, 
                 Termination : ActionList, endTime : NzNat .
\end{alltt}
\normalsize

The class \texttt{AlgoData} describes the co-simulation algorithm, which is divided into three parts.
The attributes \texttt{Initialization} and \texttt{Termination} denote the initialization procedure and termination procedure, respectively.
The attribute \texttt{CosimStep} denotes the co-simulation step procedure that the orchestration applies until it reaches the end time of the simulation, which is denoted by the attribute \texttt{endTime}.
All elements of the algorithm are of the sort \texttt{ActionList}, which is a list of SU operations:

\small
\begin{alltt}
ops Set Get Step Save : -> ActionType [ctor] . 
op portEvent:_SU:_PId:_ : ActionType SUID OidSet -> Action [ctor] .
subsort Action < ActionList .
op emptyList : -> ActionList [ctor] .
op _;_ : ActionList ActionList -> ActionList [ctor assoc id: emptyList] .
\end{alltt}
\normalsize

We have omitted the actions to handle complex scenarios.

% The orchestrator in Maude has the following two objectives.
% \begin{compactenum}
%   \item Synthesize a co-simulation algorithm
%   \item Execute the co-simulation algorithm.
% \end{compactenum}

\subsection{Synthesis of Co-simulation Algorithms}
The framework synthesizes co-simulation algorithms for a scenario $\scenario$ by (1) performing and recording all possible SU actions and (2) when searching for consistent reachable final states.
Any sequence sequence of SU actions leading to such a state gives us a co-simulation algorithm.

A number of rewrite rules model the different SU actions.

For example, the following describes a $\fget{}$ operation:\simon{Align this better}
\small
\begin{alltt}
crl [get-syn] :
< SU1 : SU | fmistate : Simulation, inputs : IS, 
             outputs : (< O : Output | time : T, status : Undef, 
                                       value : V, dependsOn : FT > OS) > 
(SU1 ! O ==> SU2 ! I)
< OCH : SimData | values : PV > 
< ALG : AlgoData | CoSimStep : ALGO >
=> getAction(< SU1 : SU | >, SU1 ! O)
   (SU1 ! O ==> SU2 ! I)
   < OCH : SimData | values : insert((SU2 ! I), < T ; V >, PV) >  
   < ALG : AlgoData | CoSimStep : (ALGO ; EVENT) >
if feedthroughSatisfied(FT, IS, T)
/\char92 EVENT := portEvent: Get SU: SU1 PId: O . 
\end{alltt}
\normalsize
A value \texttt{V} can be obtained from the output \texttt{O} of SU \texttt{SU1} if the current state satisfy all the feed-through constraints \texttt{FT} of the output \texttt{O}, which is checked by the function \texttt{feedthroughSatisfied}.
The rule updates the output \texttt{O} using the operation \texttt{getAction} and inserts the output's value and time \texttt{<T ;V >} in the map \texttt{values}.
Finally, it adds the performed action \texttt{portEvent: Get SU: SU1 PId: O} to its record of performed actions \texttt{CoSimStep}.

All such ``synthesis'' rules in our model follow the same pattern.
They rewrite the scenario while remembering how they did it.

We can synthesize a co-simulation algorithm by starting from a consistent initial state and explore how a consistent final state can be established.
An algorithm for a given scenario is, therefore, synthesized using the following rule:

\small
\begin{alltt}
crl [getAlgortihm]: \{INIT\} => \{getOrchestrator(FINALSTATE)\}
if isInitialState(INIT)
  /\char92 LOOPS := tarjan(INIT)
  /\char92 SUIDsNE := getSUIDsOfScenario(INIT)
  /\char92 SIMDATA := initialOrchestrationData(1,LOOPS,SUIDsNE)
  /\char92 CONF := calculateSNSet(INIT) SIMDATA initialAlgorithmData(1)
  /\char92 \{CONF\} => \{FINALSTATE\} 
  /\char92 allSUsinUnloaded(SUIDsNE, FINALSTATE) .
\end{alltt}
\normalsize

The rule \texttt{getAlgorithm} checks if the scenario \texttt{INIT} is in a suitable initial state using the predicate \texttt{isInitialState}.
Then we construct an initial simulation configuration \texttt{CONF} as in section 3.
It rewrites the GlobalState \texttt{CONF} to \texttt{FINALSTATE} using the nested rewriting rule 
The key condition that does all the work is the rewrite condition \texttt{\{CONF\} => \{FINALSTATE\}}, which searches all states reachable from \texttt{CONF} until it finds one such state \texttt{FINALSTATE} that satisfies the property \texttt{allSUsinUnloaded}, which ensures that all SUs have been properly simulated and unloaded.
The function \texttt{getOrchestrator} extracts the synthesized co-simulation algorithm from this final state.

\begin{example}
  Extracting an algorithm for the scenario described by \cref{ex:simulationunits} yields six different algorithms is performed using the search command below:

  \small
  \begin{alltt}
    search scenario => FINALSTATE::GlobalState .
  \end{alltt}
  \normalsize

%   \small
% \begin{alltt}
% Solution 1
% {< "Algorithm" : AlgorithmData | 
% CosimStep :
%   ((stepEvent: "tank" StepSize: 1);
%   (portEvent: Get SU: "tank" PId: "waterlevel");
%   (portEvent: Set SU: "ctrl" PId: "waterlevel");
%   (stepEvent: "ctrl" StepSize: 1);
%   (portEvent: Get SU: "ctrl" PId: "valveState");
%   portEvent: Set SU: "tank" PId: "valveState"),
% Initialization :
%   ((fmiEvent: CreateExp SUs:("ctrl", "tank"));(
%   fmiEvent: EnterInitialization SUs:("ctrl", "tank"));
%     (portEvent: Get SU: "ctrl" PId: "valveState");
%     (portEvent: Get SU: "tank" PId: "waterlevel");
%     (portEvent: Set SU: "ctrl" PId: "waterlevel");
%     (portEvent: Set SU: "tank" PId: "valveState");
%   fmiEvent: ExitInitialization SUs:("ctrl", "tank")),
% Termination :
%   ((fmiEvent: Terminate SUs:("ctrl", "tank"));
%   (fmiEvent: FreeInstance SUs:("ctrl", "tank"));
%   fmiEvent: Unload SUs:("ctrl", "tank")),
% endTime : 1 >}

% Solution 2
% {< "Algorithm" : AlgorithmData | 
% CosimStep :
%   ((stepEvent: "tank" StepSize: 1);
%   (portEvent: Get SU: "tank" PId: "waterlevel");
%   (portEvent: Set SU: "ctrl" PId: "waterlevel");
%   (stepEvent: "ctrl" StepSize: 1);
%   (portEvent: Get SU: "ctrl" PId: "valveState");
%   portEvent: Set SU: "tank" PId: "valveState"),
% Initialization :
%   ((fmiEvent: CreateExp SUs:("ctrl", "tank"));(
%   fmiEvent: EnterInitialization SUs:("ctrl", "tank"));
%     (portEvent: Get SU: "ctrl" PId: "valveState");
%     (portEvent: Get SU: "tank" PId: "waterlevel");
%     (portEvent: Set SU: "tank" PId: "valveState");
%     (portEvent: Set SU: "ctrl" PId: "waterlevel");
%   fmiEvent: ExitInitialization SUs:("ctrl", "tank")),
% Termination :
%   ((fmiEvent: Terminate SUs:("ctrl", "tank"));
%   (fmiEvent: FreeInstance SUs:("ctrl", "tank"));
%   fmiEvent: Unload SUs:("ctrl", "tank")),
% endTime : 1 >}


% Solution 3
% {< "Algorithm" : AlgorithmData | 
% CosimStep :
%   ((stepEvent: "tank" StepSize: 1);
%   (portEvent: Get SU: "tank" PId: "waterlevel");
%   (portEvent: Set SU: "ctrl" PId: "waterlevel");
%   (stepEvent: "ctrl" StepSize: 1);
%   (portEvent: Get SU: "ctrl" PId: "valveState");
%   portEvent: Set SU: "tank" PId: "valveState"),
% Initialization :
%   ((fmiEvent: CreateExp SUs:("ctrl", "tank"));(
%   fmiEvent: EnterInitialization SUs:("ctrl", "tank"));
%     (portEvent: Get SU: "ctrl" PId: "valveState");
%     (portEvent: Set SU: "tank" PId: "valveState");
%     (portEvent: Get SU: "tank" PId: "waterlevel");
%     (portEvent: Set SU: "ctrl" PId: "waterlevel");
%   fmiEvent: ExitInitialization SUs:("ctrl", "tank")),
% Termination :
%   ((fmiEvent: Terminate SUs:("ctrl", "tank"));
%   (fmiEvent: FreeInstance SUs:("ctrl", "tank"));
%   fmiEvent: Unload SUs:("ctrl", "tank")),
% endTime : 1 >}

% Solution 4
% {< "Algorithm" : AlgorithmData | 
% CosimStep :
%   ((stepEvent: "tank" StepSize: 1);
%   (portEvent: Get SU: "tank" PId: "waterlevel");
%   (portEvent: Set SU: "ctrl" PId: "waterlevel");
%   (stepEvent: "ctrl" StepSize: 1);
%   (portEvent: Get SU: "ctrl" PId: "valveState");
%   portEvent: Set SU: "tank" PId: "valveState"),
% Initialization :
%   ((fmiEvent: CreateExp SUs:("ctrl", "tank"));(
%   fmiEvent: EnterInitialization SUs:("ctrl", "tank"));
%     (portEvent: Get SU: "tank" PId: "waterlevel");
%     (portEvent: Get SU: "ctrl" PId: "valveState");
%     (portEvent: Set SU: "ctrl" PId: "waterlevel");
%     (portEvent: Set SU: "tank" PId: "valveState")
%   fmiEvent: ExitInitialization SUs:("ctrl", "tank")),
% Termination :
%   ((fmiEvent: Terminate SUs:("ctrl", "tank"));
%   (fmiEvent: FreeInstance SUs:("ctrl", "tank"));
%   fmiEvent: Unload SUs:("ctrl", "tank")),
% endTime : 1 >}

% Solution 5
% {< "Algorithm" : AlgorithmData | 
% CosimStep :
%   ((stepEvent: "tank" StepSize: 1);
%   (portEvent: Get SU: "tank" PId: "waterlevel");
%   (portEvent: Set SU: "ctrl" PId: "waterlevel");
%   (stepEvent: "ctrl" StepSize: 1);
%   (portEvent: Get SU: "ctrl" PId: "valveState");
%   portEvent: Set SU: "tank" PId: "valveState"),
% Initialization :
%   ((fmiEvent: CreateExp SUs:("ctrl", "tank"));(
%   fmiEvent: EnterInitialization SUs:("ctrl", "tank"));
%     (portEvent: Get SU: "tank" PId: "waterlevel");
%     (portEvent: Get SU: "ctrl" PId: "valveState");
%     (portEvent: Set SU: "tank" PId: "valveState");
%     (portEvent: Set SU: "ctrl" PId: "waterlevel");
%   fmiEvent: ExitInitialization SUs:("ctrl", "tank")),
% Termination :
%   ((fmiEvent: Terminate SUs:("ctrl", "tank"));
%   (fmiEvent: FreeInstance SUs:("ctrl", "tank"));
%   fmiEvent: Unload SUs:("ctrl", "tank")),
% endTime : 1 >}

% Solution 6
% {< "Algorithm" : AlgorithmData | 
% CosimStep :
%   ((stepEvent: "tank" StepSize: 1);
%   (portEvent: Get SU: "tank" PId: "waterlevel");
%   (portEvent: Set SU: "ctrl" PId: "waterlevel");
%   (stepEvent: "ctrl" StepSize: 1);
%   (portEvent: Get SU: "ctrl" PId: "valveState");
%   portEvent: Set SU: "tank" PId: "valveState"),
% Initialization :
%   ((fmiEvent: CreateExp SUs:("ctrl", "tank"));(
%   fmiEvent: EnterInitialization SUs:("ctrl", "tank"));
%   (portEvent: Get SU: "tank" PId: "waterlevel");
%   (portEvent: Set SU: "ctrl" PId: "waterlevel");
%   (portEvent: Get SU: "ctrl" PId: "valveState");
%   (portEvent: Set SU: "tank" PId: "valveState");
%   fmiEvent: ExitInitialization SUs:("ctrl", "tank")),
% Termination :
%   ((fmiEvent: Terminate SUs:("ctrl", "tank"));
%   (fmiEvent: FreeInstance SUs:("ctrl", "tank"));
%   fmiEvent: Unload SUs:("ctrl", "tank")),
% endTime : 1 >}
% \end{alltt}
% \normalsize
We can see that all the synthesized algorithms have the same co-simulation step that is similar to \cref{alg:algorithm_3}.
\end{example}

Our framework also supports synthesizing co-simulation algorithms synthesis for complex co-simulation scenarios see online model for details.

Many SU actions can happen at the same time , which means that multiple correct algorithms can be synthesized for the same scenario.

For example, there exists six different algorithms to simulate the water tank example.

\subsection{Execution of Co-Simulation Algorithms}
This section describes how we run simulations using the generated algorithms on the scenario in Maude.

The execution of an algorithm rewrites a \emph{SimState}:
\small
\begin{alltt}
op run:_on:_with:_ : Object Configuration Object -> SimState [ctor]. 
\end{alltt}
\normalsize
The first component of type \texttt{Object} is the co-simulation algorithm, the second component of type \texttt{Configuration} is the co-simulation scenario, and the third component denotes the simulation data of type \texttt{SimState}.

A co-simulation algorithm is executed by sequentially performing the actions of the co-simulation algorithm.
We start by performing all actions in the \texttt{Initialization}, secondly we perform all actions of the \texttt{CoSimStep} before we finally execute all actions of the \texttt{Termination}. 

The rewrite rule below shows an execution of the $\fget{}$ action.
\small
\begin{alltt}
crl [get] : 
run: < ALG : AlgoData | CosimStep : ((action: Get SU: SU1 PId: O) ; ALGO) >
on: CONF
< SU1 : SU | outputs : (< O : Output | time : T, value : V, 
  dependsOn : FT > OS), inputs : IS > ( SU1 ! O ==> SU2 ! INPUT)
with: < OCH : SimData | values : PV >
=> 
run: < ALG : AlgoData | CosimStep : ALGO >
on: CONF getAction(< SU1 : SU | >, SU ! O) ( SU1 ! O ==> SU2 ! INPUT)
with: < OCH : SimData | values : insert((SU2 ! INPUT), < T ; V >, PV) > 
if feedthroughSatisfied(FT, IS, T) .
\end{alltt}
\normalsize
The rule performs the first action (\texttt{(action: Get SU: SU1 PId: O)}) of the list \texttt{CosimStep}.
The action state that we should get the value of output \texttt{O} of SU \texttt{SU1}.
The rule ensures that all feed-through requirements are satisfied.
The result of the rule is that the value \texttt{V} is saved in the map \texttt{values}, the output is updated, and that the performed action is removed from the list of actions defined by the \texttt{CoSimStep}.

The simulation finishes when all the actions have been exhausted, and no more rewritings can occur.

A simulation of a scenario is performed using the rule:
\small
\begin{alltt}
crl [runAlg] : runAnyAlgorithm INIT => run: ORC on: INIT with: SIMDATA
  if LOOPS := tarjan(INIT)
  /\char92 SUIDsNE := getSUIDsOfScenario(INIT)
  /\char92 SIMDATA := initialOrchestrationData(1,LOOPS,SUIDsNE)
  /\char92 ALGO := initialAlgorithmData(1)
  /\char92 CONF := calculateSNSet(INIT ALGO) SIMDATA 
  /\char92 \{CONF\} => \{ FINALSTATE \} 
  /\char92 ORC := getOrchestrator(FINALSTATE)
  /\char92 allSUsinUnloaded(SUIDsNE, FINALSTATE) .
\end{alltt}
\normalsize
The rule first instantiates a scenario \texttt{CONF} from the initial state of the scenario \texttt{INIT} as previously described.
The scenario is rewriting using the nested rewrite rule \texttt{\{CONF\} => \{ FINALSTATE \}}. 
The nested rule rewrites the initial state \texttt{CONF} to the final state \texttt{FINALSTATE}, which satisfies the predicate \texttt{allSUsinUnloaded}.
The algorithm \texttt{ORC} to reach the final state is extracted using \texttt{getOrchestrator}.
The scenario is simulated using rewriting of the object \texttt{run: ORC on: INIT with: SIMDATA}.
The rewriting runs the simulation on the scenario \texttt{INIT} using the simulation data of the scenario that is generated by the equation \texttt{initialOrchestrationData}.

\begin{example}\label{ex:algoexecution}
The scenario described in \cref{ex:simulationunits} (\texttt{SCENARIO} below) can be simulated by rewriting it using the rule \texttt{runAlg}:
\small
\begin{alltt}
  frew (runAnyAlgorithm SCENARIO).
\end{alltt}
\normalsize
The rewriting returns the final simulation state:
\scriptsize
\begin{alltt}
run: < "Algorithm" : AlgorithmData | CosimStep : emptyList,Initialization : emptyList,
                                     Termination : emptyList,endTime : 1 > 
on: ("ctrl" ! "valveState" ==> "tank" ! "valveState") 
    ("tank" ! "waterlevel" ==> "ctrl" ! "waterlevel")
< "ctrl" : SU | canReject : false, fmistate : Unloaded, localState : "valve" |-> < true >,
inputs : < "waterlevel" : Input | contract : reactive, status : Def,time : 1,
                                  type : integer, value : < 100 > >,
outputs : < "valveState" : Output | dependsOn : empty, status : Def, time : 1,
                                    type : integer, value : < 1 > >,
parameters :("high" |-> < 5 >, "low" |-> < 0 >), time : 1 > 
< "tank" : SU | canReject : false, fmistate : Unloaded, localState : "waterlevel" |-> < 100 >,
inputs : < "valveState" : Input | contract : delayed,status : Def,
                                  time : 1, type : integer, value : < 1 > >,
outputs : < "waterlevel" : Output | dependsOn : empty, status : Def,time : 1,
                                    type : integer,value : < 100 > >,
parameters : "flow" |-> < 100 >,time : 1 > 
with: < "Orchestrator" : SimulationData | 
          SNSet : empty, actualStepSize : 1, defaultStepSize : 1, guessOn : empty,
          simulationTime : 1, solvedSCC : empty, suids :("ctrl", "tank"), 
          unsolvedSCC : empty, values : empty >
\end{alltt}
\normalsize
\end{example}

The execution of an algorithm in Maude enables different kinds of analyses described in the following sections.

\subsection{Ensuring Confluent Co-simulation Algorithms}
All the generated algorithms of the same scenario should result in the same simulation result; otherwise, the co-simulation practitioner's faith is in the hand of Maude.
The co-simulation practitioner would be in trouble if the simulation result depended on the algorithm that an arbitrary rewriting of the scenario produced.

To show that all algorithms lead to the same simulation, we use Maude to show that all generated co-simulation algorithms of a scenario result in the same co-simulation result such that co-simulation cannot detect any difference between the synthesized algorithms.
We say that a co-simulation practitioner cannot detect any differences between two co-simulations that has the same initial and final state.
For example, we two algorithms $P_1$ and $P_2$ are indistinguishable if $s \xrightarrow[\text{}]{P_1} s' \land s \xrightarrow[\text{}]{P_2} s'$ or any other words $P_1$ and $P_2$ are confluent.

The can unfortunately not prove in Maude that all the synthesized algorithms of an arbitrary scenario are confluent.
Instead, we can perform the check on case to case basis.  

\begin{example}
  We can check that all synthesized algorithms of a scenario \texttt{Scenario} are confluent by the following search command:
  \small
  \begin{alltt}
  search (runAnyAlgorithm SCENARIO)  =>! S:SimState . 
  \end{alltt}
\normalsize
The search exhaustively synthesizes all co-simulation algorithms of the scenario \texttt{SCENARIO}. 
Afterwards, it rewrites the scenario using the algorithm until it reaches a final state \texttt{S} that cannot be rewritten any further.
If \texttt{SCENARIO} was the scenario described by \cref{ex:simulationunits} the search would result in an single result similar to the result of \cref{ex:algoexecution}, which means that all algorithms are confluent.
\end{example}

Confluence of the synthesized co-simulation algorithms is essential; it ensures that all correct algorithms lead to the same simulation result.

Even though two algorithms are confluent, they can still possess different properties, such as memory overhead and execution time. 
The framework does currently not allow us to explore this aspect since this relies on concrete SUs of the system.
Nevertheless, we believe this aspect could be explored in an extension of the tool using Maude's capability to communicate with external objects of a socket connection.