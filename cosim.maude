(omod Ports is 
 protecting QID + NAT .
 sorts PortId Mode PortStatus PortIdSet .
 subsorts Qid < PortId < Oid .
 subsort PortId < PortIdSet .

 sorts Connection SUID EPortId EPortIdSet .
 subsort EPortId < EPortIdSet .
 subsorts Qid < SUID < Oid .
 op _==>_ : EPortId EPortId -> Connection [ctor format(niy! d d d)] .
 subsort Connection < Configuration .
 op _!_ : SUID PortId -> EPortId [ctor] .

 class Port | time : Nat, status : PortStatus . 
 class Input | type : Mode .
 class Output | dependsOn : PortIdSet .
 subclasses Input Output < Port . 
 ops d r : -> Mode [ctor] .   *** d = delayed, r = Reactive.
 ops Def Undef : -> PortStatus [ctor] .

 op emptySet : -> PortIdSet [ctor] .
 op _::_ : PortIdSet PortIdSet -> PortIdSet [ctor assoc comm id: emptySet] .

 op emptyLoop : -> EPortIdSet [ctor] .
 op _;;_ : EPortIdSet EPortIdSet -> EPortIdSet [ctor assoc comm id: emptyLoop] .
 op _in_ : EPortId EPortIdSet -> Bool . 
 op _in_ : Connection Configuration -> Bool . 

 var P : EPortId .
 var PSet : EPortIdSet .
 var Cons : Configuration .
 var C : Connection .

 eq P in P ;; PSet = true .
 eq P in PSet = false [owise] .

 eq C in C Cons = true .
 eq C in Cons = false [owise] .

endom)

(omod Algorithm is 
 protecting Ports .
 sorts ActionType FMIActionType ComplexActionType SUIdSet ActionList Action LoopType Algebraic AlgebraicLoops .
 subsort SUID < SUIdSet .
 subsort Action < ActionList .
 subsort Algebraic < AlgebraicLoops .
    
 *** Types
 ops CreateExp EnterInitialization ExitInitialization Terminate FreeInstance Unload : -> FMIActionType [ctor] . 
 ops Set Get Step Save CreateExp : -> ActionType [ctor] . 
 ops StepNegotiation Loop : -> ComplexActionType [ctor] . 
 ops F R : -> LoopType [ctor] . 
 op fmiEvent:_SU:_ : FMIActionType PortId -> Action [ctor format(nib! d d d d)] .
 op event:_SU:_PId:_ : ActionType SUID PortIdSet -> Action [ctor format(nib! d d d d d d)] .
 op complexEvent:_SaveSUs:_RestoreSUs:_Actions:_ : ComplexActionType SUIdSet SUIdSet ActionList -> Action [ctor format(nib! d d d d d d d d)] .
 op AlgebraicLoop:_Type:_ : EPortIdSet LoopType -> Algebraic[ctor] . 
 
 *** Configuration fields
 op Algorithm:_ : ActionList -> Configuration [ctor format(nir! d d)] . 
 op SNSet:_ : SUIdSet -> Configuration [ctor format(ni d d)] .
 op stepSize:_ : NzNat -> Configuration [ctor format(nig! d d)] . 
 op endTime:_ : NzNat -> Configuration [ctor format(nim! d d)] . 
 op SCC:_ : AlgebraicLoops -> Configuration [ctor format(nim! d d)] . 

 ***Operations
 op emptySUSet : -> SUIdSet [ctor] .
 op _++_ : SUIdSet SUIdSet -> SUIdSet [ctor assoc comm id: emptySUSet] .

 op _in_ : SUID SUIdSet -> Bool . 
 op _memberOf_ : EPortId AlgebraicLoops -> Bool . 

 op emptyList : -> ActionList [ctor] .
 op _;_ : ActionList ActionList -> ActionList [ctor assoc id: emptyList] .

 op noLoops : -> AlgebraicLoops [ctor] .
 op _#_ : AlgebraicLoops AlgebraicLoops -> AlgebraicLoops [ctor assoc id: noLoops] .

 op getSUs : EPortIdSet SUIdSet -> SUIdSet .

 var ID : SUID .
 var SUSet : SUIdSet .
 var L : AlgebraicLoops .
 var P : EPortId .
 var T : LoopType .
 var PSet : EPortIdSet .
 var PID : PortId .

 eq ID in ID ++ SUSet = true .
 eq ID in SUSet = false [owise] .

 eq P memberOf (AlgebraicLoop: (P ;; PSet)  Type: T) # L = true .
 eq P memberOf L = false [owise] .

 eq getSUs(emptyLoop, SUSet) = SUSet .
 eq getSUs((ID ! PID) ;; PSet, ID ++ SUSet) = getSUs(PSet, SUSet) .
 eq getSUs((ID ! PID) ;; PSet, SUSet) = getSUs(PSet, ID ++ SUSet) [owise] .

endom)

(omod SimulationUnit is
   protecting Ports + Algorithm .
   sort fmiState .

   ops Instantiated ExperimentSetup Initialize Simulation Terminated InstanceFreed Unloaded : -> fmiState [ctor] . *** The different states of the FMI standard

   ***Classes
   class SU | time : Nat, inputs : Configuration, outputs : Configuration, canReject : Bool, state : fmiState .

   op askStepSize : Object Nat -> Nat .
   op feedthroughSatisfied : PortIdSet Configuration Nat -> Bool .
   op allDef : Configuration Nat -> Bool .
   op undefPorts : Configuration Nat -> Configuration .
   op undefInputs : Configuration -> Configuration .  
   op allInputsDef : Configuration Nat Nat -> Bool .
   op allInputsSet : Configuration -> Bool .
   op canStep : Nat Nat Configuration Configuration -> Bool .

   var ID1 : SUID .
   var PId : PortId .
   vars T  SUTime FutureTime : Nat .
   vars C Inputs Outputs : Configuration .
   var Status : PortStatus .
   var feedthrough : PortIdSet .

   *** Checks if all feedthrough constraints are satisfied
   eq feedthroughSatisfied(emptySet, C, T) = true .
   eq feedthroughSatisfied(PId :: feedthrough, < PId : Input | status : Undef > C, T) = false .
   eq feedthroughSatisfied(PId :: feedthrough, < PId : Input | time : T, status : Def > C, T) =  feedthroughSatisfied(feedthrough, C, T) .

   eq allDef(none, T) = true .
   eq allDef(< PId : Port | status : Status, time : T > C, T) = Status == Def and allDef(C, T) .

   eq allInputsDef(none, SUTime, FutureTime) = true .
   eq allInputsDef(< PId : Input | time : SUTime, type : d, status : Status > C, SUTime, FutureTime) = Status == Def and allInputsDef(C, SUTime, FutureTime) .
   eq allInputsDef(< PId : Input | time : FutureTime, type : r,  status : Status > C, SUTime, FutureTime ) = Status == Def and allInputsDef(C, SUTime, FutureTime) .

   eq undefPorts(none, T) = none .
   eq undefPorts(< PId : Port | > C, T) =  < PId : Port | status : Undef, time : T > undefPorts(C, T) .

   eq undefInputs(none) = none .
   eq undefInputs(< PId : Port | > C) =  < PId : Port | status : Undef > undefInputs(C) .

   eq allInputsSet(none) = true .
   eq allInputsSet(< ID1 : SU | inputs : Inputs > C) = allDef(Inputs, 0) and allInputsSet(C) .

   eq canStep(SUTime, FutureTime, Inputs, Outputs) =  allInputsDef(Inputs, SUTime, FutureTime) and allDef(Outputs, SUTime) . 

   *** For the moment we allow all steps - should updated to reflect the nondeterminism of the step negotiation!
   eq askStepSize(< ID1 : SU | time : SUTime, inputs : Inputs >, T) = T .

endom)

(omod PerformActions is
  protecting SimulationUnit .
  
  op getAction : Configuration PortId -> Configuration .
  op setAction : Configuration PortId Nat -> Configuration .
  op stepAction : Configuration NzNat -> Configuration .

***Why can't I use these functions in other places
  var ID1 : SUID .
  vars I O : PortId .
  var Step : NzNat .
  vars Inputs Outputs S : Configuration .
  var T : Nat .

  *** Updates the time and status of the input
  eq getAction(< ID1 : SU | time : T, outputs : (< O : Output | > Outputs) >, O) = < ID1 : SU | outputs : (< O : Output | time : T, status : Def > Outputs) > .
  eq getAction(S, O) = S [owise] .


  eq setAction(< ID1 : SU | inputs : (< I : Input | > Inputs) > , I, T) =  < ID1 : SU | inputs : (< I : Input | time : T, status : Def > Inputs) > .
  eq setAction(S, I, T) = S [owise] .

  *** Updates the time and the status of the outputs
  eq stepAction(< ID1 : SU | time : T, outputs : Outputs >, Step) = < ID1 : SU | time : (T + Step), outputs : undefPorts(Outputs, (T + Step)) > .
  eq stepAction(S, Step) = S [owise] .

endom)



(omod LOOPSolver is 
  protecting PerformActions .
    op solveLoop : Configuration Algebraic  -> Configuration . 
    op breakLoop : EPortIdSet Configuration LoopType -> Configuration .
    op loopStepActions : EPortIdSet Configuration ActionList -> ActionList .

    var K : LoopType .
    vars C Outputs Inputs : Configuration .
    vars I O : PortId .
    vars ID1 ID2 : SUID .
    var PSet : EPortIdSet .
    var AL : ActionList .
    var T : Nat .
    var Step : NzNat .
    var feedthrough : PortIdSet .


    eq solveLoop(C Algorithm: AL, AlgebraicLoop: PSet Type: K) = C 
        Algorithm: (AL ; (complexEvent: Loop SaveSUs: getSUs(PSet, emptySUSet) RestoreSUs: getSUs(PSet, emptySUSet) Actions: loopStepActions(PSet, breakLoop(PSet, C, K), emptyList))) .


    *** Forget All Delayed Connections
    eq breakLoop((ID1 ! I) ;; PSet,   
                     < ID1 : SU | inputs : (< I : Input | type : d > Inputs) > 
                     < ID2 : SU | outputs : (< O : Output | > Outputs) > (ID2 ! O ==> ID1 ! I) C, F) = 
                        breakLoop((ID1 ! I) ;; PSet, < ID1 : SU | > < ID2 : SU | > C , F) .

    *** Forget All Reactive Connections
    eq breakLoop((ID1 ! I) ;; PSet,
                 < ID1 : SU | inputs : (< I : Input | type : r > Inputs) > 
                 < ID2 : SU | outputs : (< O : Output | > Outputs) > (ID2 ! O ==> ID1 ! I) C , R) = 
                breakLoop((ID1 ! I) ;; PSet, < ID1 : SU | > < ID2 : SU | > C , R) .

    eq breakLoop(PSet, C, K) = C [owise] .

    *** Guess on input
    ceq loopStepActions((ID1 ! I) ;; (ID2 ! O) ;; PSet, 
                      < ID1 : SU | time : T, inputs : (< I : Input | status : Undef > Inputs) > 
                      < ID2 : SU | outputs : (< O : Output | > Outputs) > C stepSize: Step, AL) = 
              loopStepActions((ID2 ! O) ;; PSet, 
                      (setAction(< ID1 : SU | time : T, inputs : (< I : Input | status : Undef > Inputs) >, I, (T + Step)))
                      < ID2 : SU | > C, 
                      (AL ; (event: Set SU: ID1 PId: I)))                       
                    if not (ID2 ! O ==> ID1 ! I) in C .


    *** Set value on input
    eq loopStepActions((ID1 ! I) ;; (ID2 ! O) ;; PSet, 
                      < ID1 : SU | inputs : (< I : Input | status : Undef > Inputs) > 
                      < ID2 : SU | outputs : (< O : Output | time : T, status : Def > Outputs) > 
                        (ID2 ! O ==> ID1 ! I) C, AL) = 
              loopStepActions((ID2 ! O) ;; PSet, 
                      (setAction(< ID1 : SU | inputs : (< I : Input | status : Undef > Inputs) >, I, T))
                      < ID2 : SU | > (ID2 ! O ==> ID1 ! I) C, 
                      (AL ; (event: Set SU: ID1 PId: I))) .

    *** Get output value - remember feed through
    eq loopStepActions((ID1 ! O) ;; PSet, 
                    < ID1 : SU | time : T, outputs : (< O : Output | dependsOn : feedthrough > Outputs) > C, AL) = 
                    loopStepActions(PSet,
                      (getAction(< ID1 : SU | time : T, outputs : (< O : Output | dependsOn : feedthrough > Outputs) >, O)) C, 
                      (AL ; (event: Get SU: ID2 PId: O))) .

    *** Step
    ceq loopStepActions((ID1 ! O) ;; PSet,  
                    < ID1 : SU | outputs : Outputs, inputs : Inputs > stepSize: Step C, AL) = 
                  loopStepActions((ID1 ! O) ;; PSet,
                      (stepAction(< ID1 : SU | outputs : Outputs, inputs : Inputs >, (T + Step))) stepSize: Step C,
                              (AL ; (event: Step SU: ID1 PId: emptySet)))
                    if canStep(T, (T + Step), Inputs, Outputs) .

    eq loopStepActions(emptyLoop,C, AL) = AL .

endom)

eof


(omod StepFinder is
  protecting PerformActions .
  
  *** Current State x Initial State -> Nat
  op findStep : SUIdSet Configuration Configuration -> NzNat .
  op getStepAction : SUIdSet Configuration ActionList -> ActionList .
  op calculateSNSet : Configuration -> Configuration .

   vars ID1 ID2 : SUID .
   var SUIDs : SUIdSet .
   vars I O : PortId .
   vars T T1 T2 Step : Nat .
   vars Inputs Outputs : Configuration . 
   vars C C1 : Configuration .
   var AL : ActionList .
   var feedthrough : PortIdSet .

   *** Calculation of the members of the set of SUs that should be backtracked in the step negotiation
  ceq calculateSNSet(< ID1 : SU | inputs : (< I : Input | type : r > Inputs) > 
                     < ID2 : SU | outputs : (< O : Output | > Outputs) > (ID2 ! O ==> ID1 ! I) (SNSet: (ID1 ++ SUIDs))  C) = 
                                         calculateSNSet(< ID1 : SU | > < ID2 : SU | canReject : true > (ID2 ! O ==> ID1 ! I) 
                                         (SNSet: (ID1 ++ ID2 ++ SUIDs)) C) 
                                         if not ID2 in SUIDs .
  
  ceq calculateSNSet(< ID1 : SU | canReject : true > (SNSet: SUIDs) C ) = calculateSNSet(< ID1 : SU | > (SNSet: (ID1 ++ SUIDs)) C )
                                         if not ID1 in SUIDs .                                    
  eq calculateSNSet(C) = C [owise] .

  ***Stepping case
  ceq findStep(ID1 ++ SUIDs,  
                    < ID1 : SU | time : T, outputs : Outputs, inputs : Inputs > stepSize: Step C, C1) = 
                  findStep(ID1 ++ SUIDs,
                         stepAction(< ID1 : SU | >, (T + (askStepSize(< ID1 : SU | >, Step)))) C, C1)
                    if canStep(T, (T + Step), Inputs, Outputs) .

   *** Get case (only on reactive outputs) - remember feedthrough
   eq findStep(ID1 ++ SUIDs, 
                    < ID2 : SU | outputs : (< O : Output | status : Undef, dependsOn : feedthrough > Outputs) >
                    < ID1 : SU | inputs : (< I : Input | type : r > Inputs) > (ID2 ! O ==> ID1 ! I) C, C1) = 
                    findStep(ID1 ++ SUIDs,
                      getAction(< ID2 : SU | >, O) < ID1 : SU | > (ID2 ! O ==> ID1 ! I) C, C1) .

   *** Set case
   eq findStep(ID1 ++ ID2 ++ SUIDs, 
                      < ID1 : SU | inputs : (< I : Input | status : Undef, type : r > Inputs) > 
                      < ID2 : SU | outputs : (< O : Output | time : T, status : Def > Outputs) > 
                        (ID2 ! O ==> ID1 ! I) C, C1) = 
              findStep(ID1 ++ ID2 ++ SUIDs, 
                      setAction(< ID1 : SU | >, I, T)
                      < ID2 : SU | > (ID2 ! O ==> ID1 ! I) C, C1) .

  *** Restart search and and update step size for next iteration of search
  ceq findStep(ID1 ++ ID2 ++ SUIDs, 
                        < ID1 : SU | time : T1 > 
                        < ID2 : SU | time : T2 > C, C1 stepSize: T) = 
              findStep(ID1 ++ ID2 ++ SUIDs, 
                      C1 stepSize: min(T1, T2), 
                      C1 stepSize: min(T1, T2))   
                    if T1 > 0 and T2 > 0 and T1 =/= T2 . *** The simulations should both have stepped, but not to the same time
   
   eq findStep(SUIDs, C (stepSize: T), C1) = T [owise] . 


   ***Stepping case
  ceq getStepAction(ID1 ++ SUIDs,  
                    < ID1 : SU | time : T, outputs : Outputs, inputs : Inputs > stepSize: Step C, AL) = 
                  getStepAction(ID1 ++ SUIDs,
                      stepAction(< ID1 : SU | >, (T + Step)) stepSize: Step C,
                              (AL ; (event: Step SU: ID1 PId: emptySet)))
                    if canStep(T, (T + Step), Inputs, Outputs) .

   *** Get case (only on reactive outputs) - remember feedthrough
   eq getStepAction(ID1 ++ SUIDs, 
                    < ID2 : SU | outputs : (< O : Output | status : Undef, dependsOn : feedthrough > Outputs) >
                    < ID1 : SU | inputs : (< I : Input | type : r > Inputs) > (ID2 ! O ==> ID1 ! I) C, AL) = 
                    getStepAction(ID1 ++ SUIDs,
                      getAction(< ID2 : SU | >, O)
                      < ID1 : SU | > (ID2 ! O ==> ID1 ! I) C, 
                      (AL ; (event: Get SU: ID2 PId: O))) .

   *** Set case
   eq getStepAction(ID1 ++ ID2 ++ SUIDs, 
                      < ID1 : SU | inputs : (< I : Input | status : Undef, type : r > Inputs) > 
                      < ID2 : SU | outputs : (< O : Output | time : T, status : Def > Outputs) > 
                        (ID2 ! O ==> ID1 ! I) C, AL) = 
              getStepAction(ID1 ++ ID2 ++ SUIDs, 
                      setAction(< ID1 : SU | >, I, T)
                      < ID2 : SU | > (ID2 ! O ==> ID1 ! I) C, 
                      (AL ; (event: Set SU: ID1 PId: I))).

   eq getStepAction(SUIDs, C, AL) = AL [owise] . 


endom)


(omod COSIMULATION is 
   protecting StepFinder .
   sort GlobalState .

   op needsStepNegotiation : SUIdSet -> Bool .
   op containsCycle : AlgebraicLoops -> Bool .
   op performStepNegotiation : Configuration -> Configuration .
   op performGlobalStep : Configuration -> Configuration .
   op allSUinSimulation : Configuration -> Bool .
   op `{_`} : Configuration -> GlobalState .
   op getPorts : Configuration EPortIdSet -> EPortIdSet .
   *** All Ports X Connections X SCC -> SCC 

   vars ID1 ID2 : SUID .
   var SUIDs : SUIdSet .
   vars I O : PortId .
   vars T T1 T2 Step : Nat .
   vars Inputs Outputs : Configuration . 
   var S : fmiState .
   vars C C1 : Configuration .
   var Status : PortStatus .
   var AL : ActionList .
   var feedthrough : PortIdSet .
   var P P1 P2 : EPortIdSet .
   var L : AlgebraicLoops .  

  *** Step Negotiation
  ceq performStepNegotiation(C SNSet: SUIDs stepSize: T Algorithm: AL) = 
                              C SNSet: emptySUSet Algorithm: (AL ; (complexEvent: StepNegotiation SaveSUs: SUIDs RestoreSUs: SUIDs Actions: getStepAction(SUIDs, C stepSize: T, emptyList)))
                              (stepSize: findStep(SUIDs, C stepSize: T,C stepSize: T)) if needsStepNegotiation(SUIDs) .

  ceq performStepNegotiation(C SNSet: SUIDs) = C if not needsStepNegotiation(SUIDs) .  


  *** Get All ports in the scenario:
  ceq getPorts(< ID1 : SU | inputs : (< I : Input | > Inputs) > C, P) = getPorts(< ID1 : SU | > C,  (ID1 ! I) ;; P )
            if not (ID1 ! I) in P .

  ceq getPorts(< ID1 : SU | outputs : (< O : Output | > Outputs) > C, P) = getPorts(< ID1 : SU | > C,  (ID1 ! O) ;; P )
            if not (ID1 ! O) in P .

  eq getPorts(C, P) = P [owise] . 

  ***Calculation of Algebraic Loops
  *** External Connection 

  *** All SUs are in the simulation state
  eq allSUinSimulation(< ID1 : SU | state : S > C) = S == Simulation and allSUinSimulation(C) . 
  eq allSUinSimulation(C) = true [owise] .

  *** Perform the global simulation step
  *** Set reactive
  ceq performGlobalStep(C < ID1 : SU | time : T1, inputs : (< I : Input | time : T1, type : r > Inputs) > 
                          < ID2 : SU | outputs : (< O : Output | time : T2, status : Def > Outputs) > 
                         (ID2 ! O ==> ID1 ! I) Algorithm: AL) = 
            performGlobalStep(C < ID1 : SU | inputs : (< I : Input | time : T2, status : Def > Inputs) > 
                         < ID2 : SU | > 
                         (ID2 ! O ==> ID1 ! I) Algorithm: (AL ; (event: Set SU: ID1 PId: I)))
                         if T1 < T2 .
  *** Set delayed
  ceq performGlobalStep(C < ID1 : SU | time : T, inputs : (< I : Input | time : T1, type : d > Inputs) > 
                          < ID2 : SU | outputs : (< O : Output | time : T, status : Def > Outputs) > 
                         (ID2 ! O ==> ID1 ! I) Algorithm: AL) = 
        performGlobalStep(C < ID1 : SU | inputs : (< I : Input | time : T, status : Def > Inputs) > 
                         < ID2 : SU | > 
                         (ID2 ! O ==> ID1 ! I) Algorithm: (AL ; (event: Set SU: ID1 PId: I)))
                         if T1 < T .

  *** Step
  ceq performGlobalStep(C < ID1 : SU | time : T, inputs : Inputs, outputs : Outputs > stepSize: Step endTime: T2 Algorithm: AL)  = 
      performGlobalStep(C < ID1 : SU | outputs : undefPorts(Outputs, (T + Step)), time : (T + Step) > 
                        stepSize: Step endTime: T2 Algorithm: (AL ; (event: Step SU: ID1 PId: emptySet)))
                        if canStep(T, (T + Step), Inputs, Outputs) and (T + Step) <= T2 . 

  *** Get
  ceq performGlobalStep(C < ID1 : SU | time : T, inputs : Inputs, outputs : (< O : Output | status : Undef, dependsOn : feedthrough > Outputs) > Algorithm: AL) =
                    performGlobalStep(C < ID1 : SU | outputs : (< O : Output | time : T, status : Def > Outputs) > Algorithm: (AL ; (event: Get SU: ID1 PId: O)))  
                    if feedthroughSatisfied(feedthrough, Inputs, T) .

  eq performGlobalStep(C) = C [owise] .


  *** Step negotiation is needed if at least one SU can reject a Step
  eq needsStepNegotiation(emptySUSet) = false .
  eq needsStepNegotiation(SUIDs) = true [owise] .

  *** Does the scenario contain any loop
  eq containsCycle(noLoops) = false .
  eq containsCycle(L) = true [owise] .

  *** FMI-standard state transition:

  rl [setExp] : < ID1 : SU | state : Instantiated > Algorithm: AL 
                 => < ID1 : SU | state : ExperimentSetup > Algorithm: (AL ; (fmiEvent: CreateExp SU: ID1)) .

  rl [init] : < ID1 : SU | inputs : Inputs , outputs : Outputs , state : ExperimentSetup >  Algorithm: AL 
          => < ID1 : SU | inputs : undefPorts(Inputs, 0), outputs : undefPorts(Outputs, 0), state : Initialize > 
              Algorithm: (AL ; (fmiEvent: EnterInitialization SU: ID1)).

  crl [simulate] : < ID1 : SU | inputs : Inputs , outputs : Outputs, state : Initialize > C Algorithm: AL 
                => < ID1 : SU | state : Simulation > C Algorithm: (AL ; (fmiEvent: ExitInitialization SU: ID1))
                if allDef(Inputs, 0) and allDef(Outputs, 0) and allInputsSet(C) .

  crl [terminate] : < ID1 : SU | time : T1, inputs : Inputs , outputs : Outputs , state : Simulation > endTime: T1 Algorithm: AL 
                 => < ID1 : SU | state : Terminated > endTime: T1 Algorithm: (AL ; (fmiEvent: Terminate SU: ID1))
                 if allDef(Outputs, T1) and allDef(Inputs, T1) .

  rl [free] : < ID1 : SU | state : Terminated > Algorithm: AL 
           => < ID1 : SU | state : InstanceFreed > Algorithm: (AL ; (fmiEvent: FreeInstance SU: ID1)) .

  rl [unload] : < ID1 : SU | state : InstanceFreed > Algorithm: AL
              => < ID1 : SU | state : Unloaded > Algorithm: (AL ; (fmiEvent: Unload SU: ID1)) .


   *** Initalization Procedure 
   crl [get-init] :  < ID1 : SU | outputs : ((< O : Output | status : Undef , dependsOn : feedthrough >) Outputs) , inputs : Inputs, state : Initialize > Algorithm: AL 
                  => < ID1 : SU | outputs : ((< O : Output | status : Def >) Outputs) >  Algorithm: (AL ; (event: Get SU: ID1 PId: O)) if feedthroughSatisfied(feedthrough, Inputs, 0) .

   *** Inputs can only rely on one connection 
   rl [set-init] :  < ID1 : SU | inputs : (< I : Input | status : Undef > Inputs), state : Initialize > Algorithm: AL 
                          < ID2 : SU | outputs : (< O : Output | status : Def > Outputs) > (ID2 ! O ==> ID1 ! I)
                        => < ID1 : SU | inputs : (< I : Input | status : Def > Inputs) > 
                           < ID2 : SU | > (ID2 ! O ==> ID1 ! I) Algorithm: (AL ; (event: Set SU: ID1 PId: I)) .

   ***Simulation
***(
   crl [get] :  < ID1 : SU | time : T1, outputs : (< O : Output | status : Undef , dependsOn : feedthrough > Outputs), inputs : Inputs, state : Simulation > Algorithm: AL 
                  => < ID1 : SU | outputs : (< O : Output | time : T1 , status : Def > Outputs) >  Algorithm: (AL ; (event: Get SU: ID1 PId: O)) if feedthroughSatisfied(feedthrough, Inputs, T1) .

   crl [set-reactive] :  < ID1 : SU | time : T1, inputs : (< I : Input | status : Undef, type : r > Inputs), state : Simulation >  Algorithm: AL 
                          < ID2 : SU | outputs : (< O : Output | time : T2, status : Def > Outputs) > (ID2 ! O ==> ID1 ! I)
                        => < ID1 : SU | inputs : (< I : Input | time : T2 , status : Def > Inputs) > 
                           < ID2 : SU | > (ID2 ! O ==> ID1 ! I) Algorithm: (AL ; (event: Set SU: ID1 PId: I)) if T2 > T1 .

   rl [set-delayed] :  < ID1 : SU | time : T1, inputs : (< I : Input | status : Undef, type : d > Inputs), state : Simulation > Algorithm: AL 
                          < ID2 : SU | outputs : (< O : Output | time : T1, status : Def > Outputs) > (ID2 ! O ==> ID1 ! I)
                        => < ID1 : SU | inputs : (< I : Input | time : T1, status : Def > Inputs) > 
                           < ID2 : SU | > (ID2 ! O ==> ID1 ! I) Algorithm: (AL ; (event: Set SU: ID1 PId: I)).


   *** A step makes the SU stepped and sets all output ports to not get
   crl [step] :  < ID1 : SU | inputs : Inputs, outputs : Outputs, time : T1, state : Simulation > stepSize: Step endTime: T2 Algorithm: AL 
             =>  < ID1 : SU | outputs : undefPorts(Outputs, (T1 + Step)), inputs : undefInputs(Inputs), time : (T1 + Step), state : Simulation > stepSize: Step endTime: T2 Algorithm: (AL ; (event: Step SU: ID1 PId: emptySet)) 
             if Step > 0 and canStep(T1, (T1 + Step), Inputs, Outputs) and (T1 + Step) <= T2 . 
)***

  ***Complex scenarios with save and restore - this should 
  *** Recognise Loop and treat them


  ***If the scenario contains SUs that require step negotiation
  ***The step negotiation
  crl [stepNego] : { C SNSet: SUIDs} => 
          { performStepNegotiation(C SNSet: SUIDs)}
          if needsStepNegotiation(SUIDs) and allSUinSimulation(C) .

  crl [simulationStep]: { C SNSet: SUIDs} => 
          { performGlobalStep(C SNSet: SUIDs) }
        if (not needsStepNegotiation(SUIDs)) and allSUinSimulation(C) .

 
  *** Definition of system
  op externalConnection : ->  Configuration .    *** External Connections - all ports have unique name
  op simulationUnits : -> Configuration .      *** SUs - ID * input ports * and outputs

  op setup : -> GlobalState .

  ***Encoding of the Scenario 

eq externalConnection = ('msd1 ! 'x1 ==> 'msd2 ! 'x1) ('msd1 ! 'v1 ==> 'msd2 ! 'v1) ('msd2 ! 'fk ==> 'msd1 ! 'fk) ('msd2 ! 'fk ==> 'msd3 ! 'fk) .

eq simulationUnits = 
(< 'msd2 : SU | time : 0, inputs : (< 'x1 : Input | time : 0, type : r, status : Undef  >) (< 'v1 : Input | time : 0, type : r, status : Undef  >), outputs : (< 'fk : Output | time : 0, status : Undef, dependsOn : ( 'x1 :: 'v1 ) >), state : Instantiated, canReject : false >)

 (< 'msd1 : SU | time : 0, inputs : (< 'fk : Input | time : 0, type : d, status : Undef  >), outputs : (< 'x1 : Output | time : 0, status : Undef, dependsOn : emptySet >) (< 'v1 : Output | time : 0, status : Undef, dependsOn : emptySet >), state : Instantiated, canReject : true >)

 (< 'msd3 : SU | time : 0, inputs : (< 'fk : Input | time : 0, type : d, status : Undef  >), outputs : none, state : Instantiated, canReject : false >) .


  eq setup = { calculateSNSet(simulationUnits externalConnection stepSize: 1 endTime: 1 Algorithm: emptyList SNSet: emptySUSet) } .

endom)

eof

*** Create strategies and look for parallel actions

(smod CO-SIMULATION-STRAT is
  protecting COSIMULATION .

  strat fmi_rules_setExpt @ GlobalState .

  vars M1 M2 : SUID .
  var FS : fmiState .
  var  S : GlobalState .

  sd fmi_rules_setExpt := 
     (matchrew S s.t. < M1 : SU | state : Instantiated > /\ < M2 : SU | state : FS > /\ FS =/= Instantiated  by
              S using setExp[ID1 <- M1] 
     ) ! .


endsm)

*** Check for termination - not useful 
(search setup =>! X:Configuration . )
show search graph .

( frew setup . )

( frew [20] setup using fmi_rules_setExpt . )
( red needsStepNegotiation(setup) . )
( red allSUinSimulation(setup) . )
( red findStep(setup,setup) . )
( red getPorts(simulationUnits, emptyLoop) . )

set trace on .
trace exclude FULL-MAUDE . set trace substitution off . set trace eq off . 
  ***(

 )***


*** Why can't I rewrite the system?
*** I think some of the cases should match

*** Feed through



