(omod Ports is 
 protecting QID .
 protecting NAT .
 sorts PortId Mode PortStatus PortIdSet .
 subsorts Qid < PortId < Oid .
 subsort PortId < PortIdSet .

 sorts Connection SUID EPortId .
 subsorts Qid < SUID < Oid .
 op _==>_ : EPortId EPortId -> Connection [ctor] .
 subsort Connection < Configuration .
 op _!_ : SUID PortId -> EPortId [ctor] .

 class Port | time : Nat, status : PortStatus . 
 class Input | type : Mode .
 class Output | dependsOn : PortIdSet .
 subclasses Input Output < Port . 
 ops d r : -> Mode [ctor] .   *** d = delayed, r = Reactive.
 ops Def Undef : -> PortStatus [ctor] .

 op emptySet : -> PortIdSet [ctor] .
 op _::_ : PortIdSet PortIdSet -> PortIdSet [ctor assoc comm id: emptySet] .

endom)


(omod CO-SIMULATION is 
   protecting Ports .
   sort fmiState .

   op stepSize:_ : Nat -> Configuration [ctor] . 
  
   ***Classes
   class SU | time : Nat, inputs : Configuration, outputs : Configuration, canReject : Bool, state : fmiState .

   op feedthroughSatisfied : PortIdSet Configuration -> Bool .

   op allInputDef : Configuration -> Bool .

   op undefInput : Configuration -> Configuration .

   ops Instantiated ExperimentSetup Initialize Simulation Terminated InstanceFreed Unloaded : -> fmiState [ctor] . *** The different states of the FMI standard

   vars ID1 ID2 : SUID .
   vars I O PId : PortId .
   vars T1 T2 Step : Nat .
   vars Inputs Outputs : Configuration . 
   var S : fmiState .
   var C : Configuration .
   var t : Mode .
   var P : Port .
   var Status : PortStatus .

   var feedthrough : PortIdSet .

   eq feedthroughSatisfied(emptySet, C) = true .
   eq feedthroughSatisfied(PId :: feedthrough, < PId : Input | status : Undef > C ) = false .
   eq feedthroughSatisfied(PId :: feedthrough, < PId : Input | status : Def > C ) =  feedthroughSatisfied(feedthrough, C) .

   eq allInputDef(none) = true .
   eq allInputDef(< PId : Input | status : Status > C ) = Status == Def and allInputDef(C) .

   eq undefInput(none) = none .
   eq undefInput(< PId : Input | > C) =  < PId : Input |  status : Undef > undefInput(C) .

  *** FMI state transition:

  rl [create_Exp] : < ID1 : SU | state : Instantiated >
                => < ID1 : SU | state : ExperimentSetup > .

  rl [init] : < ID1 : SU | state : ExperimentSetup >
          => < ID1 : SU | state : Initialize > .

  rl [simulate] : < ID1 : SU | inputs : Inputs , state : Initialize >
              => < ID1 : SU | inputs : undefInput(Inputs) , state : Simulation > .

  crl [terminate] : < ID1 : SU | time : T1 , state : Simulation > 
                => < ID1 : SU | state : Terminated > if T1 > 0 .

  rl [free] : < ID1 : SU | state : Terminated > 
          => < ID1 : SU | state : InstanceFreed > .

  rl [unload] : < ID1 : SU | state : InstanceFreed > 
            => < ID1 : SU | state : Unloaded > .


   *** Initalization Procedure 

   crl [get-init] :  < ID1 : SU | outputs : ((< O : Output | status : Undef , dependsOn : feedthrough >) Outputs) , inputs : Inputs, state : Initialize >
                  => < ID1 : SU | outputs : ((< O : Output | status : Def >) Outputs) > if feedthroughSatisfied(feedthrough, Inputs) .

   *** Inputs can only rely on one connection 
   rl [set-init] :  < ID1 : SU | inputs : (< I : Input | status : Undef > Inputs), state : Initialize > 
                          < ID2 : SU | outputs : (< O : Output | status : Def > Outputs), state : Initialize > (ID2 ! O ==> ID1 ! I)
                        => < ID1 : SU | inputs : (< I : Input | status : Def > Inputs) > 
                           < ID2 : SU | > (ID2 ! O ==> ID1 ! I) .

   ***Simulation

   crl [get] :  < ID1 : SU | outputs : (< O : Output | status : Undef > Outputs), state : Simulation >
                  => < ID1 : SU | outputs : (< O : Output | status : Def > Outputs) > if feedthroughSatisfied(feedthrough, Inputs) .

   crl [set-reactive] :  < ID1 : SU | inputs : (< I : Input | time : T1, status : Undef, type : r > Inputs), state : Simulation > 
                          < ID2 : SU | outputs : (< O : Output | time : T2, status : Def > Outputs), state : Simulation > (ID2 ! O ==> ID1 ! I)
                        => < ID1 : SU | inputs : (< I : Input | time : T2 , status : Def > Inputs) > 
                           < ID2 : SU | > (ID2 ! O ==> ID1 ! I) if T2 > T1 .

   rl [set-delayed] :  < ID1 : SU | inputs : (< I : Input | time : T1, status : Undef, type : d > Inputs), state : Simulation > 
                          < ID2 : SU | outputs : (< O : Output | time : T1, status : Def > Outputs), state : Simulation > (ID2 ! O ==> ID1 ! I)
                        => < ID1 : SU | inputs : (< I : Input | status : Def > Inputs) > 
                           < ID2 : SU | > (ID2 ! O ==> ID1 ! I) .


   *** A step makes the SU stepped and sets all output ports to not get
   crl [step] :  < ID1 : SU | inputs : Inputs, time : T1, state : Simulation, canReject : false > stepSize: Step 
             =>  < ID1 : SU | inputs : undefInput(Inputs), time : (T1 + Step), state : Simulation > stepSize: Step 
             if Step > 0 and allInputDef(Inputs) . *** If all inputD are set

  ***Complex scenarios with save and restore - this should 
  *** Recognise Loop and treat them


  *** Definition of system
  op externalConnection : ->  Configuration .    *** External Connections - all ports have unique name
  op simulationUnits : -> Configuration .      *** SUs - ID * input ports * and outputs


  op setup : -> Configuration .

  ***Encoding of the Scenario 
  eq externalConnection = ('MSD1 ! 'x1 ==> 'MSD2 ! 'x1) ('MSD1 ! 'v1 ==> 'MSD2 ! 'v1) ('MSD2 ! 'fk ==> 'MSD1 ! 'fk) ('MSD2 ! 'fk ==> 'MSD3 ! 'fk) .

  eq simulationUnits = 
   (< 'MSD1 : SU | time : 0, inputs : < 'fk : Input | time : 0 , type : d, status : Undef >, outputs : (< 'x1 : Output | time : 0 , status : Undef, dependsOn : emptySet  > < 'v1 : Output | time : 0, status : Undef, dependsOn : emptySet >), state : Instantiated, canReject : false > )
   (< 'MSD2 : SU | time : 0, inputs : (< 'v1 : Input | time : 0 , type : d, status : Undef >  < 'x1 : Input | time : 0 , type : d > ), outputs: < 'fk : Output | time : 0, status : Undef, dependsOn : emptySet >, state : Instantiated, canReject: false  > )
   < 'MSD3 : SU | time : 0, inputs : < 'fk : Input | time : 0 , type : d, status : Undef > , outputs: none, state : Instantiated, canReject: false  > .


  eq setup = simulationUnits externalConnection .

endom)

*** Check for termination - not useful 
search setup =>! X:State .
show search graph .

rewrite setup .


*** Why can't I rewrite the system?
*** I think some of the cases should match

*** Feed through