(omod Ports is 
 protecting QID + NAT .
 sorts PortId Mode PortStatus PortIdSet .
 subsorts Qid < PortId < Oid .
 subsort PortId < PortIdSet .

 sorts Connection SUID EPortId .
 subsorts Qid < SUID < Oid .
 op _==>_ : EPortId EPortId -> Connection [ctor] .
 subsort Connection < Configuration .
 op _!_ : SUID PortId -> EPortId [ctor] .

 class Port | time : Nat, status : PortStatus . 
 class Input | type : Mode .
 class Output | dependsOn : PortIdSet .
 subclasses Input Output < Port . 
 ops d r : -> Mode [ctor] .   *** d = delayed, r = Reactive.
 ops Def Undef : -> PortStatus [ctor] .

 op emptySet : -> PortIdSet [ctor] .
 op _::_ : PortIdSet PortIdSet -> PortIdSet [ctor assoc comm id: emptySet] .

endom)

(omod Algorithm is 
 protecting Ports .
 sorts ActionType FMIActionType ComplexActionType SUIdSet ActionList Action .
 subsort SUID < SUIdSet .
 subsort Action < ActionList .

 ops CreateExp EnterInitialization ExitInitialization Terminate FreeInstance Unload : -> FMIActionType [ctor] . 
 ops Set Get Step Save CreateExp : -> ActionType [ctor] . 
 ops StepNegotiation AlgebraicLoop : -> ComplexActionType [ctor] . 

 op fmiEvent:_SU:_ : FMIActionType PortId -> Action [ctor] .
 op event:_SU:_PId:_ : ActionType SUID PortIdSet -> Action [ctor] .
 op complexEvent:_SaveSUs:_RestoreSUs:_Actions:_ : ComplexActionType SUIdSet SUIdSet ActionList -> Action [ctor] .

 op emptySUSet : -> SUIdSet [ctor] .
 op _++_ : SUIdSet SUIdSet -> SUIdSet [ctor assoc comm id: emptySUSet] .

 op _in_ : SUID SUIdSet -> Bool . 

 op emptyList : -> ActionList [ctor] .
 op _;_ : ActionList ActionList -> ActionList [ctor assoc id: emptyList] .

 op Algorithm:_ : ActionList -> Configuration [ctor] . 
 op SNSet:_ : SUIdSet -> Configuration [ctor] .
 op stepSize:_ : NzNat -> Configuration [ctor] . 
 op endTime:_ : NzNat -> Configuration [ctor] . 

 var ID : SUID .
 var SUSet : SUIdSet .

 eq ID in ID ++ SUSet = true .
 eq ID in  SUSet = false [owise] .
endom)

(omod SimulationUnit is
   protecting Ports + Algorithm .
   sort fmiState .

   ops Instantiated ExperimentSetup Initialize Simulation Terminated InstanceFreed Unloaded : -> fmiState [ctor] . *** The different states of the FMI standard

   ***Classes
   class SU | time : Nat, inputs : Configuration, outputs : Configuration, canReject : Bool, state : fmiState .

   op askStepSize : Object Nat -> Nat .
   op feedthroughSatisfied : PortIdSet Configuration Nat -> Bool .
   op allDef : Configuration Nat -> Bool .
   op undefPorts : Configuration Nat -> Configuration .
   op undefInputs : Configuration -> Configuration .  
   op allInputsDef : Configuration Nat Nat -> Bool .
   op allInputsSet : Configuration -> Bool .
   op canStep : Nat Nat Configuration Configuration -> Bool .

   var ID1 : SUID .
   var PId : PortId .
   vars T  SUTime FutureTime : Nat .
   vars C Inputs Outputs : Configuration .
   var Status : PortStatus .
   var feedthrough : PortIdSet .

   *** Checks if all feedthrough constraints are satisfied
   eq feedthroughSatisfied(emptySet, C, T) = true .
   eq feedthroughSatisfied(PId :: feedthrough, < PId : Input | status : Undef > C, T) = false .
   eq feedthroughSatisfied(PId :: feedthrough, < PId : Input | time : T, status : Def > C, T) =  feedthroughSatisfied(feedthrough, C, T) .

   eq allDef(none, T) = true .
   eq allDef(< PId : Port | status : Status, time : T > C, T) = Status == Def and allDef(C, T) .

   eq allInputsDef(none, SUTime, FutureTime) = true .
   eq allInputsDef(< PId : Input | time : SUTime, type : d, status : Status > C, SUTime, FutureTime) = Status == Def and allInputsDef(C, SUTime, FutureTime) .
   eq allInputsDef(< PId : Input | time : FutureTime, type : r,  status : Status > C, SUTime, FutureTime ) = Status == Def and allInputsDef(C, SUTime, FutureTime) .

   eq undefPorts(none, T) = none .
   eq undefPorts(< PId : Port | > C, T) =  < PId : Port | status : Undef, time : T > undefPorts(C, T) .

   eq undefInputs(none) = none .
   eq undefInputs(< PId : Port | > C) =  < PId : Port | status : Undef > undefInputs(C) .

   eq allInputsSet(none) = true .
   eq allInputsSet(< ID1 : SU | inputs : Inputs > C) = allDef(Inputs, 0) and allInputsSet(C) .

   eq canStep(SUTime, FutureTime, Inputs, Outputs) =  allInputsDef(Inputs, SUTime, FutureTime) and allDef(Outputs, SUTime) . 

   *** For the moment we allow all steps - should updated to reflect the nondeterminism of the step negotiation!
   eq askStepSize(< ID1 : SU | time : T, inputs : Inputs >, T) = T .

endom)


(omod CO-SIMULATION is 
   protecting SimulationUnit .

   op calculateSNSet : Configuration -> Configuration .
   op needsStepNegotiation : Configuration -> Bool .
   op containsCycle : Configuration Configuration -> Bool .
   op performStepNegotiation : Configuration -> Configuration .
   op allSUinSimulation : Configuration -> Bool .
 
    *** Current State x Initial State -> Nat
    op findStep : Configuration Configuration -> Nat .

   vars ID1 ID2 : SUID .
   var SUIDs : SUIdSet .
   vars I O : PortId .
   vars T T1 T2 Step : Nat .
   vars Inputs Outputs : Configuration . 
   var S : fmiState .
   vars C C1 : Configuration .
   var Status : PortStatus .
   var AL : ActionList .

   var feedthrough : PortIdSet .

   *** Calculation of the members of the set of SUs that should be backtracked in the step negotiation
  ceq calculateSNSet(< ID1 : SU | inputs : (< I : Input | type : r > Inputs) > 
                     < ID2 : SU | outputs : (< O : Output | > Outputs) > (ID2 ! O ==> ID1 ! I) (SNSet: (ID1 ++ SUIDs))  C) = 
                                         calculateSNSet(< ID1 : SU | > < ID2 : SU | canReject : true > (ID2 ! O ==> ID1 ! I) 
                                         (SNSet: (ID1 ++ ID2 ++ SUIDs)) C) 
                                         if not ID2 in SUIDs .
  
  ceq calculateSNSet(< ID1 : SU | canReject : true > (SNSet: SUIDs) C ) = calculateSNSet(< ID1 : SU | > (SNSet: (ID1 ++ SUIDs)) C )
                                         if not ID1 in SUIDs .                                    
  eq calculateSNSet(C) = C [owise] .


  *** All SUs are in the simulation state
  eq allSUinSimulation(none) = true .
  eq allSUinSimulation(< ID1 : SU | state : S > C) = S == Simulation and allSUinSimulation(C) . 


   *** Step Negotiation
  ceq performStepNegotiation(C) = C (stepSize: findStep(C,C) SNSet: emptySUSet) if needsStepNegotiation(C) .
  eq performStepNegotiation(C) = C [owise] .  

   ***Stepping case
  ceq findStep((SNSet: (ID1 ++ SUIDs)) < ID1 : SU | time : T, outputs : Outputs, inputs : Inputs > stepSize: Step C, C1) = 
                    findStep((SNSet: (ID1 ++ SUIDs)) < ID1 : SU | time : (T + askStepSize(< ID1 : SU | time : T, inputs : Inputs, outputs : undefPorts(Outputs, (T + Step)) >, Step)), outputs : undefPorts(Outputs, (T + askStepSize(< ID1 : SU | time : T, inputs : Inputs >, Step))), inputs : Inputs > stepSize: askStepSize(< ID1 : SU | time : T, inputs : Inputs >, Step) C, C1)
                    if canStep(T, (T + Step), Inputs, Outputs) .

   *** Get case
   eq findStep((SNSet: (ID1 ++ SUIDs)) < ID2 : SU | outputs : (< O : Output | status : Undef > Outputs) >
                            < ID1 : SU | inputs : (< I : Input | type : r > Inputs) >  (ID2 ! O ==> ID1 ! I) C, C1) = 
                            findStep( (SNSet: (ID1 ++ SUIDs))  < ID2 : SU | outputs : (< O : Output | status : Def > Outputs) > 
                              < ID1 : SU | > (ID2 ! O ==> ID1 ! I) C, C1) .
   *** Set case
   eq findStep((SNSet: (ID1 ++ ID2 ++ SUIDs)) < ID1 : SU | inputs : (< I : Input | status : Undef, type : r > Inputs) > 
                                  < ID2 : SU | outputs : (< O : Output | status : Def > Outputs) > (ID2 ! O ==> ID1 ! I) C, C1) = 
                                  findStep((SNSet: (ID1 ++ ID2 ++ SUIDs)) < ID1 : SU | inputs : (< I : Input | status : Def > Inputs) > 
                                  < ID2 : SU | > (ID2 ! O ==> ID1 ! I) C, C1) .

    *** Restart search and and update step size for next iteration of search
  ceq findStep((SNSet: (ID1 ++ ID2 ++ SUIDs)) < ID1 : SU | time : T1 > 
                                  < ID2 : SU | time : T2 > C, C1 stepSize: T) = 
                                    findStep(C1 stepSize: min(T1, T2), C1 stepSize: min(T1, T2))   
                                    if T1 > 0 and T2 > 0 and T1 =/= T2 . *** The simulations should both have stepped, but not to the same time
   
   eq findStep(C (stepSize: T), C1) = T [owise] . 

  *** Step negotiation is needed if at least one SU can reject a Step
  eq needsStepNegotiation(SNSet: emptySUSet) = false .
  eq needsStepNegotiation(C) = true [owise] .


  ***eq containsCycle(< ID1 : SU |  : false > C) , )

  *** FMI-standard state transition:

  rl [setExp] : < ID1 : SU | state : Instantiated > Algorithm: AL 
                 => < ID1 : SU | state : ExperimentSetup > Algorithm: (AL ; (fmiEvent: CreateExp SU: ID1)) .

  rl [init] : < ID1 : SU | inputs : Inputs , outputs : Outputs , state : ExperimentSetup >  Algorithm: AL 
          => < ID1 : SU | inputs : undefPorts(Inputs, 0), outputs : undefPorts(Outputs, 0), state : Initialize > 
              Algorithm: (AL ; (fmiEvent: EnterInitialization SU: ID1)).

  crl [simulate] : < ID1 : SU | inputs : Inputs , outputs : Outputs, state : Initialize > C Algorithm: AL 
                => < ID1 : SU | state : Simulation > C Algorithm: (AL ; (fmiEvent: ExitInitialization SU: ID1))
                if allDef(Inputs, 0) and allDef(Outputs, 0) and allInputsSet(C) .

  crl [terminate] : < ID1 : SU | time : T1, inputs : Inputs , outputs : Outputs , state : Simulation > endTime: T1 Algorithm: AL 
                 => < ID1 : SU | state : Terminated > endTime: T1 Algorithm: (AL ; (fmiEvent: Terminate SU: ID1))
                 if allDef(Outputs, T1) and allDef(Inputs, T1) .

  rl [free] : < ID1 : SU | state : Terminated > Algorithm: AL 
           => < ID1 : SU | state : InstanceFreed > Algorithm: (AL ; (fmiEvent: FreeInstance SU: ID1)) .

  rl [unload] : < ID1 : SU | state : InstanceFreed > Algorithm: AL
              => < ID1 : SU | state : Unloaded > Algorithm: (AL ; (fmiEvent: Unload SU: ID1)) .


   *** Initalization Procedure 

   crl [get-init] :  < ID1 : SU | outputs : ((< O : Output | status : Undef , dependsOn : feedthrough >) Outputs) , inputs : Inputs, state : Initialize > Algorithm: AL 
                  => < ID1 : SU | outputs : ((< O : Output | status : Def >) Outputs) >  Algorithm: (AL ; (event: Get SU: ID1 PId: O)) if feedthroughSatisfied(feedthrough, Inputs, 0) .

   *** Inputs can only rely on one connection 
   rl [set-init] :  < ID1 : SU | inputs : (< I : Input | status : Undef > Inputs), state : Initialize > Algorithm: AL 
                          < ID2 : SU | outputs : (< O : Output | status : Def > Outputs) > (ID2 ! O ==> ID1 ! I)
                        => < ID1 : SU | inputs : (< I : Input | status : Def > Inputs) > 
                           < ID2 : SU | > (ID2 ! O ==> ID1 ! I) Algorithm: (AL ; (event: Set SU: ID1 PId: I)) .

   ***Simulation

   crl [get] :  < ID1 : SU | time : T1, outputs : (< O : Output | status : Undef , dependsOn : feedthrough > Outputs), inputs : Inputs, state : Simulation > Algorithm: AL 
                  => < ID1 : SU | outputs : (< O : Output | time : T1 , status : Def > Outputs) >  Algorithm: (AL ; (event: Get SU: ID1 PId: O)) if feedthroughSatisfied(feedthrough, Inputs, T1) .

   crl [set-reactive] :  < ID1 : SU | time : T1, inputs : (< I : Input | status : Undef, type : r > Inputs), state : Simulation >  Algorithm: AL 
                          < ID2 : SU | outputs : (< O : Output | time : T2, status : Def > Outputs) > (ID2 ! O ==> ID1 ! I)
                        => < ID1 : SU | inputs : (< I : Input | time : T2 , status : Def > Inputs) > 
                           < ID2 : SU | > (ID2 ! O ==> ID1 ! I) Algorithm: (AL ; (event: Set SU: ID1 PId: I)) if T2 > T1 .

   rl [set-delayed] :  < ID1 : SU | time : T1, inputs : (< I : Input | status : Undef, type : d > Inputs), state : Simulation > Algorithm: AL 
                          < ID2 : SU | outputs : (< O : Output | time : T1, status : Def > Outputs) > (ID2 ! O ==> ID1 ! I)
                        => < ID1 : SU | inputs : (< I : Input | time : T1, status : Def > Inputs) > 
                           < ID2 : SU | > (ID2 ! O ==> ID1 ! I) Algorithm: (AL ; (event: Set SU: ID1 PId: I)).


   *** A step makes the SU stepped and sets all output ports to not get
   crl [step] :  < ID1 : SU | inputs : Inputs, outputs : Outputs, time : T1, state : Simulation, canReject : false > stepSize: Step endTime: T2 Algorithm: AL 
             =>  < ID1 : SU | outputs : undefPorts(Outputs, (T1 + Step)), inputs : undefInputs(Inputs), time : (T1 + Step), state : Simulation > stepSize: Step endTime: T2 Algorithm: (AL ; (event: Step SU: ID1 PId: emptySet)) 
             if Step > 0 and canStep(T1, (T1 + Step), Inputs, Outputs) and (T1 + Step) <= T2 . 


  ***Complex scenarios with save and restore - this should 
  *** Recognise Loop and treat them


  ***If the scenario contains SUs that require step negotiation
  ***The step negotiation
  crl [simulationStep] : C SNSet: SUIDs Algorithm: AL => 
          performStepNegotiation(C SNSet: SUIDs) Algorithm: (AL ; (complexEvent: StepNegotiation SaveSUs: SUIDs RestoreSUs: SUIDs Actions: emptyList))
          if needsStepNegotiation(SNSet: SUIDs) and allSUinSimulation(C) .
 
***(
  If the scenario contains SUs that require algebraic loop (cycles that blocks the scenario)
 crl [algebraic-loop] : C ==> 
          if containsCycle(C) .
  )***

  *** Definition of system
  op externalConnection : ->  Configuration .    *** External Connections - all ports have unique name
  op simulationUnits : -> Configuration .      *** SUs - ID * input ports * and outputs

  op setup : -> Configuration .

  ***Encoding of the Scenario 

eq externalConnection = ('msd1 ! 'x1 ==> 'msd2 ! 'x1) ('msd1 ! 'v1 ==> 'msd2 ! 'v1) ('msd2 ! 'fk ==> 'msd1 ! 'fk) ('msd2 ! 'fk ==> 'msd3 ! 'fk) .

eq simulationUnits = 
 (< 'msd2 : SU | time : 0, inputs : (< 'x1 : Input | time : 0, type : r, status : Undef  >) (< 'v1 : Input | time : 0, type : r, status : Undef  >), outputs : (< 'fk : Output | time : 0, status : Undef, dependsOn : ( 'x1 :: 'v1 ) >), state : Instantiated, canReject : false >)
 (< 'msd1 : SU | time : 0, inputs : (< 'fk : Input | time : 0, type : d, status : Undef  >), outputs : (< 'x1 : Output | time : 0, status : Undef, dependsOn : emptySet >) (< 'v1 : Output | time : 0, status : Undef, dependsOn : emptySet >), state : Instantiated, canReject : true >)
 (< 'msd3 : SU | time : 0, inputs : (< 'fk : Input | time : 0, type : d, status : Undef  >), outputs : none, state : Instantiated, canReject : false >) .



  eq setup = calculateSNSet(simulationUnits externalConnection stepSize: 1 endTime: 1 Algorithm: emptyList SNSet: emptySUSet) .
endom)

eof

*** Check for termination - not useful 
(search setup =>! X:Configuration . )
show search graph .

( frew [1000] setup . )
( red needsStepNegotiation(setup) . )
( red allSUinSimulation(setup) . )


  ***(

 )***


*** Why can't I rewrite the system?
*** I think some of the cases should match

*** Feed through