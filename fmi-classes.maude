(omod Ports is 
 protecting QID .
 protecting NAT .
 sorts PortId Mode PortStatus PortIdSet .
 subsorts Qid < PortId < Oid .
 subsort PortId < PortIdSet .

 sorts Connection SUID EPortId .
 subsorts Qid < SUID < Oid .
 op _==>_ : EPortId EPortId -> Connection [ctor] .
 subsort Connection < Configuration .
 op _!_ : SUID PortId -> EPortId [ctor] .

 class Port | time : Nat, status : PortStatus . 
 class Input | type : Mode .
 class Output | dependsOn : PortIdSet .
 subclasses Input Output < Port . 
 ops d r : -> Mode [ctor] .   *** d = delayed, r = Reactive.
 ops Def Undef : -> PortStatus [ctor] .

 op emptySet : -> PortIdSet [ctor] .
 op _::_ : PortIdSet PortIdSet -> PortIdSet [ctor assoc comm id: emptySet] .

endom)

*** Tried to use this to keep track of the algorithm
(omod Algorithm is 
 protecting Ports .
 sorts AlgId ActionType .
 subsorts Qid < AlgId < Oid .

 class Action | AcType : ActionType, SU : SUID, Port : PortId . 
 ops Set Get Step Save Restore : -> ActionType [ctor] . 
endom)




(omod CO-SIMULATION is 
   protecting Ports .
   sort fmiState .

   op stepSize:_ : Nat -> Configuration [ctor] . 
   op endTime:_ : Nat -> Configuration [ctor] . 
   op Algorithm:_ : Configuration -> Configuration [ctor] . 

   ***Classes
   class SU | time : Nat, inputs : Configuration, outputs : Configuration, canReject : Bool, state : fmiState .

   op feedthroughSatisfied : PortIdSet Configuration Nat -> Bool .
   op allDef : Configuration Nat -> Bool .
   op undefPorts : Configuration Nat -> Configuration .
   op undefInputs : Configuration -> Configuration .  
   op allInputsDef : Configuration Nat Nat -> Bool .
   op allInputsSet : Configuration -> Bool .


   op calculateB : Configuration -> Configuration .
   op containsStepNegotiation : Configuration -> Bool .
   op containsCycle : Configuration Configuration -> Bool .
 
   ops Instantiated ExperimentSetup Initialize Simulation Terminated InstanceFreed Unloaded : -> fmiState [ctor] . *** The different states of the FMI standard

   vars ID1 ID2 : SUID .
   vars I O PId : PortId .
   vars T T1 T2 Step SUTime, FutureTime : Nat .
   vars Inputs Outputs : Configuration . 
   var S : fmiState .
   vars C Alg : Configuration .
   var t : Mode .
   var P : Port .
   var Status : PortStatus .

   var feedthrough : PortIdSet .

   *** Checks if all feedthrough constraints are satisfied
   eq feedthroughSatisfied(emptySet, C, T) = true .
   eq feedthroughSatisfied(PId :: feedthrough, < PId : Input | status : Undef > C, T) = false .
   eq feedthroughSatisfied(PId :: feedthrough, < PId : Input | time : T, status : Def > C, T) =  feedthroughSatisfied(feedthrough, C, T) .

   
   eq allDef(none, T) = true .
   eq allDef(< PId : Port | status : Status, time : T > C, T) = Status == Def and allDef(C, T) .


   eq allInputsDef(none, SUTime, FutureTime) = true .
   eq allInputsDef(< PId : Input | time : SUTime, type : d, status : Status > C, SUTime, FutureTime) = Status == Def and allInputsDef(C, SUTime, FutureTime) .
   eq allInputsDef(< PId : Input | time : FutureTime, type : r,  status : Status > C, SUTime, FutureTime ) = Status == Def and allInputsDef(C, SUTime, FutureTime) .

   eq undefPorts(none, T) = none .
   eq undefPorts(< PId : Port | > C, T) =  < PId : Port | status : Undef, time : T > undefPorts(C, T) .

   eq undefInputs(none) = none .
   eq undefInputs(< PId : Port | > C) =  < PId : Port | status : Undef > undefInputs(C) .

   eq allInputsSet(none) = true .
   eq allInputsSet(< ID1 : SU | inputs : Inputs > C) = allDef(Inputs, 0) and allInputsSet(C) .


   *** Calculation of the members of the set of SUs that should be backtracked in the step negotiation
   eq calculateB(< ID1 : SU | inputs : (< I : Input | type : r > Inputs) , canReject : true > 
                                         < ID2 : SU | outputs : (< O : Output | > Outputs) , canReject : false > (ID2 ! O ==> ID1 ! I) C) = 
                                         calculateB(< ID1 : SU | > < ID2 : SU | canReject : true > C ) .
   eq calculateB(C) = C [owise] .


  eq needsStepNegotiation(none) = false .
  eq needsStepNegotiation(< ID1 : SU | canReject : false > C) = containsStepNegotiation(C) . *** Is this case necessary
  eq needsStepNegotiation(< ID1 : SU | canReject : true > C) = true .


  ***eq containsCycle(< ID1 : SU |  : false > C) , )

  *** FMI state transition:

  rl [create_Exp] : < ID1 : SU | state : Instantiated >
                 => < ID1 : SU | state : ExperimentSetup > .

  rl [init] : < ID1 : SU | inputs : Inputs , outputs : Outputs , state : ExperimentSetup >
          => < ID1 : SU | inputs : undefPorts(Inputs, 0), outputs : undefPorts(Outputs, 0), state : Initialize > .

  crl [simulate] : < ID1 : SU | inputs : Inputs , outputs : Outputs, state : Initialize > C
                => < ID1 : SU | state : Simulation > C if allDef(Inputs, 0) and allDef(Outputs, 0) and allInputsSet(C) .

  crl [terminate] : < ID1 : SU | time : T1, inputs : Inputs , outputs : Outputs , state : Simulation > endTime: T1
                 => < ID1 : SU | state : Terminated > endTime: T1 if allDef(Outputs, T1) and allDef(Inputs, T1) .

  rl [free] : < ID1 : SU | state : Terminated > 
           => < ID1 : SU | state : InstanceFreed > .

  rl [unload] : < ID1 : SU | state : InstanceFreed > 
            => < ID1 : SU | state : Unloaded > .


   *** Initalization Procedure 

   crl [get-init] :  < ID1 : SU | outputs : ((< O : Output | status : Undef , dependsOn : feedthrough >) Outputs) , inputs : Inputs, state : Initialize >
                  => < ID1 : SU | outputs : ((< O : Output | status : Def >) Outputs) > if feedthroughSatisfied(feedthrough, Inputs, 0) .

   *** Inputs can only rely on one connection 
   rl [set-init] :  < ID1 : SU | inputs : (< I : Input | status : Undef > Inputs), state : Initialize > 
                          < ID2 : SU | outputs : (< O : Output | status : Def > Outputs) > (ID2 ! O ==> ID1 ! I)
                        => < ID1 : SU | inputs : (< I : Input | status : Def > Inputs) > 
                           < ID2 : SU | > (ID2 ! O ==> ID1 ! I) .

   ***Simulation

   crl [get] :  < ID1 : SU | time : T1, outputs : (< O : Output | status : Undef , dependsOn : feedthrough > Outputs), inputs : Inputs, state : Simulation >
                  => < ID1 : SU | outputs : (< O : Output | time : T1 , status : Def > Outputs) > if feedthroughSatisfied(feedthrough, Inputs, T1) .

   crl [set-reactive] :  < ID1 : SU | time : T1, inputs : (< I : Input | status : Undef, type : r > Inputs), state : Simulation > 
                          < ID2 : SU | outputs : (< O : Output | time : T2, status : Def > Outputs) > (ID2 ! O ==> ID1 ! I)
                        => < ID1 : SU | inputs : (< I : Input | time : T2 , status : Def > Inputs) > 
                           < ID2 : SU | > (ID2 ! O ==> ID1 ! I) if T2 > T1 .

   rl [set-delayed] :  < ID1 : SU | time : T1, inputs : (< I : Input | status : Undef, type : d > Inputs), state : Simulation > 
                          < ID2 : SU | outputs : (< O : Output | time : T1, status : Def > Outputs) > (ID2 ! O ==> ID1 ! I)
                        => < ID1 : SU | inputs : (< I : Input | time : T1, status : Def > Inputs) > 
                           < ID2 : SU | > (ID2 ! O ==> ID1 ! I) .


   *** A step makes the SU stepped and sets all output ports to not get
   crl [step] :  < ID1 : SU | inputs : Inputs, outputs : Outputs, time : T1, state : Simulation, canReject : false > stepSize: Step endTime: T2 
             =>  < ID1 : SU | outputs : undefPorts(Outputs, (T1 + Step)), inputs : undefInputs(Inputs), time : (T1 + Step), state : Simulation > stepSize: Step endTime: T2 
             if Step > 0 and allInputsDef(Inputs, T1, (T1 + Step)) and allDef(Outputs, T1) and (T1 + Step) <= T2 . 


  ***Complex scenarios with save and restore - this should 
  *** Recognise Loop and treat them

***(
  If the scenario contains SUs that require step negotiation
  The step negotiation 
 crl [step-negotiation] : C ==> 
          if needsStepNegotiation(C) .
  )***

***(
  If the scenario contains SUs that require algebraic loop (cycles that blocks the scenario)
 crl [algebraic-loop] : C ==> 
          if containsCycle(C) .
  )***

  *** Definition of system
  op externalConnection : ->  Configuration .    *** External Connections - all ports have unique name
  op simulationUnits : -> Configuration .      *** SUs - ID * input ports * and outputs


  op setup : -> Configuration .

  ***Encoding of the Scenario 
  eq externalConnection = ('MSD1 ! 'x1 ==> 'MSD2 ! 'x1) ('MSD1 ! 'v1 ==> 'MSD2 ! 'v1) ('MSD2 ! 'fk ==> 'MSD1 ! 'fk) ('MSD2 ! 'fk ==> 'MSD3 ! 'fk) .

  eq simulationUnits = 
   (< 'MSD1 : SU | time : 0, inputs : < 'fk : Input | time : 0 , type : d, status : Undef >, outputs : (< 'x1 : Output | time : 0 , status : Undef, dependsOn : emptySet  > < 'v1 : Output | time : 0, status : Undef, dependsOn : emptySet >), state : Instantiated, canReject : false > )
   (< 'MSD2 : SU | time : 0, inputs : (< 'v1 : Input | time : 0 , type : d, status : Undef >  < 'x1 : Input | time : 0 , type : d, status : Undef > ), outputs : < 'fk : Output | time : 0, status : Undef, dependsOn : emptySet >, state : Instantiated, canReject : false  > )
   < 'MSD3 : SU | time : 0, inputs : < 'fk : Input | time : 0 , type : d, status : Undef > , outputs : none, state : Instantiated, canReject : false  > .


  eq setup = calculateB(simulationUnits externalConnection stepSize: 1 endTime: 1 Algorithm: none) .


endom)

eof

*** Check for termination - not useful 
(search setup =>! X:Configuration . )
show search graph .

( frew [550000] setup . )

  ***(

 )***


*** Why can't I rewrite the system?
*** I think some of the cases should match

*** Feed through