mod PORTLIST 
   is protecting QID .
 sorts PortId Mode PortStatus PortList .
 subsorts Qid < PortId .

 class Port | time: Nat , status: Status . 
 class Input | type: Mode .
 class Output .
 subclasses Input Output < Port . 
 op emptyList : -> PortList .
 op _;_ : PortList PortList -> PortList [ctor assoc id: emptyList] .
 ops d r : -> Mode .   *** d = delayed, r = Reactive.
 ops Def Undef : -> PortStatus .
endm


fmod Connections is protecting NAT .
 sort Object List .
 subsorts Object < List .
 op nil : -> List .
 op _;_ : List List -> List [assoc id: nil] .
endfm

*** How to divide up the project
*** And how does it work with the object?



mod CO-SIMULATION is 
   protecting NAT .
   protecting  QID .
   sorts Oid Mode fmiS Att Atts Configuration State Connection Connections Class List Object .
   ***sort EPortId .
   subsort Oid < Qid .
   subsorts Object < List .
   subsorts Connection < Connections < Configuration .
   subsorts Att < Atts .  *** Atts is set of attribute-value pairs
   subsorts Object < Configuration . 

   op none : -> Configuration [ctor] .
   op _ _ : Configuration Configuration -> Configuration
                       [ctor config assoc comm id: none] . 

   op [_,_] : Oid Oid -> Connection [ctor] . *** Input port x Output port

   op stepSize:_ : Nat -> Configuration [ctor] . 
   op savedSUs:_ : List -> Configuration [ctor] . 
   op externalConnections:_ : Connections -> Configuration [ctor] . 
   op internalConnections:_ : Connections -> Configuration [ctor] . 

   op no : -> Atts .
   op _,_ : Atts Atts -> Atts [ctor assoc comm id: no] .

   op nil : -> List .
   op _;_ : List List -> List [ctor assoc id: nil] .

   op inputU:_ : List -> Att [ctor] . *** inputU = undefined inputs
   op inputD:_ : List -> Att [ctor] . *** inputD = defined inputs
   op outputU:_ : List -> Att [ctor] . *** OutputU = undefined outputs
   op outputD:_ : List -> Att [ctor] .  *** OutputD = defined outputs
   op time:_ : Nat -> Att [ctor] . *** Time of object is natural
   op canReject:_ : Bool -> Att [ctor] .  *** Can the SU reject a step
   op type:_ : Mode -> Att [ctor] .
   op fmiState:_ : fmiS ->  Att [ctor] .
   
   ***Classes
   ops Input Output SU : -> Class [ctor] .
   op <_:_|_> : Oid Class Atts -> Object [ctor] .

   op {_} : Configuration -> State [ctor] . 

   op feedthroughSatisfied : Oid List Connections -> Bool .

   ops Instantiated ExperimentSetup Initialize Simulation Terminated InstanceFreed Unloaded : -> fmiS . *** The different states of the FMI standard
   ops d r : -> Mode .   *** d = delayed, r = Reactive.


   vars ID1 ID2 O I : Oid .
   vars T1 T2 Step : Nat .
   vars L Q H J : List . 
   var atb atb2 : Atts . 
   var S : fmiS .
   var C : Configuration .
   var Con : Connections .
   var t : Mode .

  *** FMI state transition:

  rl[create_Exp] : { < ID1 : SU | atb, fmiState: Instantiated > C }
                => { < ID1 : SU | atb, fmiState: ExperimentSetup > C } .

  rl[init] : { < ID1 : SU | time: 0 , inputU: L, inputD: Q, atb, fmiState: ExperimentSetup > C }
          => { < ID1 : SU | time: 0 , inputU: (L ; Q), inputD: nil, atb, fmiState: Initialize > C } .

  rl[simulate] : { < ID1 : SU | time: 0, inputU: nil, inputD: Q, fmiState: Initialize, atb > C }
              => { < ID1 : SU | time: 0, inputU: Q, inputD: nil, fmiState: Simulation, atb > C } .

  crl[terminate] : { < ID1 : SU | time: T1 , inputU: nil, inputD: Q, atb, fmiState: Simulation > C }
                => { < ID1 : SU | time: T1 , inputU: nil, inputD: Q, atb, fmiState: Terminated > C } if T1 > 0 .

  rl[free] : { < ID1 : SU | atb, fmiState: Terminated > C }
          => { < ID1 : SU | atb, fmiState: InstanceFreed > C } .

  rl[unload] : { < ID1 : SU | atb, fmiState: InstanceFreed > C }
            => { < ID1 : SU | atb, fmiState: Unloaded > C } .


   *** Initalization Procedure 

   crl [get-init] :  { < ID1 : SU | time: 0 , atb, outputU: (< O : Output | time: 0 > ; H), outputD: J, inputD: Q, fmiState: Initialize > internalConnections: Con  C }
             => { < ID1 : SU | time: 0 , atb, outputU: H, outputD: (< O : Output | time: 0 > ; J), inputD: Q, fmiState: Initialize > internalConnections: Con C } if feedthroughSatisfied(O, Q, Con) .

   *** Inputs can only rely on one connection 
   rl [set-init] :  { < ID1 : SU | time: 0 , inputU: (< I : Input | time: 0 , type: t > ; L), inputD: Q, atb, fmiState: Initialize > 
                          < ID2 : SU | time: 0 , atb2, outputD: (< O : Output | time: 0 > ; J), fmiState: Initialize > externalConnections: ([O , I] Con)  C }
                        => { < ID1 : SU | time: 0 , inputU: L, inputD: (< I : Input | time: 0 , type: t > ; Q), atb, fmiState: Initialize > 
                             < ID2 : SU | time: 0 , atb2, outputD: (< O : Output | time: 0 > ; J), fmiState: Initialize > externalConnections: ([O , I] Con) C } .

   *** Maybe two cases - one with feed-through and one without
   crl [get] :  { < ID1 : SU | atb, inputD: Q, outputU: (< O : Output | time: T1 > ; H), outputD: J, inputD: Q, fmiState: Simulation > internalConnections: Con  C }
            => { < ID1 : SU | atb, inputD: Q, outputU: H, outputD: (< O : Output | time: T1 > ; J), inputD: Q, fmiState: Simulation > internalConnections: Con  C } if feedthroughSatisfied(O, Q, Con) .

   crl [set-reactive] :  { < ID1 : SU | time: T1 , inputU: (< I : Input | time: T1 , type: r > ; L), inputD: Q, atb, fmiState: Simulation > 
                           < ID2 : SU | time: T2 , atb2, outputD: (< O : Output | time: T2 > ; J), fmiState: Simulation > externalConnections: ([O , I] Con) C }
                        => { < ID1 : SU | time: T1 , inputU: L, inputD: (< I : Input | time: T2 , type: r > ; Q), atb, fmiState: Simulation > 
                           < ID2 : SU | time: T2 , atb2, outputD: (< O : Output | time: T2 > ; J), fmiState: Simulation > externalConnections: ([O , I] Con) C } if T2 > T1 . *** If value obtained at a greater time

   rl [set-delayed] :  { < ID1 : SU | time: T1 , inputU: (< I : Input | time: T1 , type: d > ; L), inputD: Q, atb, fmiState: Simulation > 
                         < ID2 : SU | time: T1 , atb2, outputD: (< O : Output | time: T1 > ; J), fmiState: Simulation > externalConnections: ([O , I] Con) C }
                        => { < ID1 : SU | time: T1 , inputU: L, inputD: (< I : Input | time: T1 , type: d > ; Q), atb, fmiState: Simulation >  
                             < ID2 : SU | time: T1 , atb2, outputD: (< O : Output | time: T1 > ; J), fmiState: Simulation > externalConnections: ([O , I] Con) C } . 

   *** A step makes the SU stepped and sets all output ports to not get
   crl [step] :  { < ID1 : SU | inputU: nil, inputD: Q, outputU: H, outputD: J, time: T1, fmiState: Simulation, canReject: false, atb > stepSize: Step C }
             =>  { < ID1 : SU | inputU: Q, inputD: nil, outputU: (H ; J), outputD: nil, time: (T1 + Step), fmiState: Simulation, canReject: false, atb > stepSize: Step C } if Step > 0 . *** If all inputD are set

  ***Complex scenarios with save and restore - this should 
  *** Recognise Loop and treat them


  *** Definition of system
  op externalConnection : ->  Configuration .    *** External Connections - all ports have unique name
  op internalConnection : ->  Configuration .    *** Internal Connections - all ports have unique name
  op simulationUnits : -> Configuration .      *** SUs - ID * input ports * and outports


  op setup : -> State .

  ***Encoding of the Scenario 
  eq externalConnection = ['msd1_x1, 'msd2_x1] ['msd1_v1,'msd2_v1] ['msd2_fk,'msd1_fk] ['msd2_fk,'msd3_fk] .
  eq internalConnection = ['msd2_x1, 'msd2_fk] ['msd2_v1, 'msd2_fk] .

  eq simulationUnits = 
   < 'MSD1 : SU | inputU: < 'msd1_fk : Input | time: 0 , type: d >, inputD: nil, outputU: (< 'msd1_x1 : Output | time: 0 > ; < 'msd1_v1 : Output | time: 0 >) , outputD: nil, time: 0, fmiState: Instantiated, canReject: false > 
   < 'MSD2 : SU | inputU: (< 'msd2_v1 : Input | time: 0 , type: d > ; < 'msd2_x1 : Input | time: 0 , type: d > ), inputD: nil, outputU: < 'msd2_fk : Output | time: 0 > , outputD: nil, time: 0, fmiState: Instantiated, canReject: false  > 
   < 'MSD3 : SU | inputU: < 'msd3_fk : Input | time: 0 , type: d > , inputD: nil, outputU: nil, outputD: nil, time: 0, fmiState: Instantiated, canReject: false  > .


  eq setup = { simulationUnits 
                externalConnections: externalConnection 
                internalConnections: internalConnection
              } .

endm

*** Check for termination - not useful 
search setup =>! X:State .
show search graph .

rewrite setup .


*** Why can't I rewrite the system?
*** I think some of the cases should match

*** Feed through